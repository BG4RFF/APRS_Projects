   1               		.file	"ser.c"
   2               	__SREG__ = 0x3f
   3               	__SP_H__ = 0x3e
   4               	__SP_L__ = 0x3d
   5               	__CCP__ = 0x34
   6               	__tmp_reg__ = 0
   7               	__zero_reg__ = 1
   8               		.global __do_copy_data
   9               		.global __do_clear_bss
  10               		.text
  11               	.Ltext0:
  12               		.cfi_sections	.debug_frame
  13               		.section	.text.ser_putchar,"ax",@progbits
  15               	ser_putchar:
  16               	.LFB49:
  17               		.file 1 "bertos/drv/ser.c"
   1:bertos/drv/ser.c **** /**
   2:bertos/drv/ser.c ****  * \file
   3:bertos/drv/ser.c ****  * <!--
   4:bertos/drv/ser.c ****  * This file is part of BeRTOS.
   5:bertos/drv/ser.c ****  *
   6:bertos/drv/ser.c ****  * Bertos is free software; you can redistribute it and/or modify
   7:bertos/drv/ser.c ****  * it under the terms of the GNU General Public License as published by
   8:bertos/drv/ser.c ****  * the Free Software Foundation; either version 2 of the License, or
   9:bertos/drv/ser.c ****  * (at your option) any later version.
  10:bertos/drv/ser.c ****  *
  11:bertos/drv/ser.c ****  * This program is distributed in the hope that it will be useful,
  12:bertos/drv/ser.c ****  * but WITHOUT ANY WARRANTY; without even the implied warranty of
  13:bertos/drv/ser.c ****  * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
  14:bertos/drv/ser.c ****  * GNU General Public License for more details.
  15:bertos/drv/ser.c ****  *
  16:bertos/drv/ser.c ****  * You should have received a copy of the GNU General Public License
  17:bertos/drv/ser.c ****  * along with this program; if not, write to the Free Software
  18:bertos/drv/ser.c ****  * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
  19:bertos/drv/ser.c ****  *
  20:bertos/drv/ser.c ****  * As a special exception, you may use this file as part of a free software
  21:bertos/drv/ser.c ****  * library without restriction.  Specifically, if other files instantiate
  22:bertos/drv/ser.c ****  * templates or use macros or inline functions from this file, or you compile
  23:bertos/drv/ser.c ****  * this file and link it with other files to produce an executable, this
  24:bertos/drv/ser.c ****  * file does not by itself cause the resulting executable to be covered by
  25:bertos/drv/ser.c ****  * the GNU General Public License.  This exception does not however
  26:bertos/drv/ser.c ****  * invalidate any other reasons why the executable file might be covered by
  27:bertos/drv/ser.c ****  * the GNU General Public License.
  28:bertos/drv/ser.c ****  *
  29:bertos/drv/ser.c ****  * Copyright 2003, 2004, 2006 Develer S.r.l. (http://www.develer.com/)
  30:bertos/drv/ser.c ****  * Copyright 2000 Bernie Innocenti <bernie@codewiz.org>
  31:bertos/drv/ser.c ****  * -->
  32:bertos/drv/ser.c ****  *
  33:bertos/drv/ser.c ****  * \brief Buffered serial I/O driver
  34:bertos/drv/ser.c ****  *
  35:bertos/drv/ser.c ****  * The serial rx interrupt buffers incoming data in a software FIFO
  36:bertos/drv/ser.c ****  * to decouple the higher level protocols from the line speed.
  37:bertos/drv/ser.c ****  * Outgoing data is buffered as well for better performance.
  38:bertos/drv/ser.c ****  * This driver is not optimized for best performance, but it
  39:bertos/drv/ser.c ****  * has proved to be fast enough to handle transfer rates up to
  40:bertos/drv/ser.c ****  * 38400bps on a 16MHz 80196.
  41:bertos/drv/ser.c ****  *
  42:bertos/drv/ser.c ****  * MODULE CONFIGURATION
  43:bertos/drv/ser.c ****  *
  44:bertos/drv/ser.c ****  *  \li \c CONFIG_SER_HWHANDSHAKE - set to 1 to enable RTS/CTS handshake.
  45:bertos/drv/ser.c ****  *         Support is incomplete/untested.
  46:bertos/drv/ser.c ****  *  \li \c CONFIG_SER_TXTIMEOUT - Enable software serial transmission timeouts
  47:bertos/drv/ser.c ****  *
  48:bertos/drv/ser.c ****  *
  49:bertos/drv/ser.c ****  * \version $Id: ser.c 3308 2010-03-29 21:06:33Z lottaviano $
  50:bertos/drv/ser.c ****  * \author Bernie Innocenti <bernie@codewiz.org>
  51:bertos/drv/ser.c ****  */
  52:bertos/drv/ser.c **** 
  53:bertos/drv/ser.c **** #include "ser.h"
  54:bertos/drv/ser.c **** #include "wdt.h"
  55:bertos/drv/ser.c **** #include "timer.h"
  56:bertos/drv/ser.c **** #include "ser_p.h"
  57:bertos/drv/ser.c **** 
  58:bertos/drv/ser.c **** #include "cfg/cfg_ser.h"
  59:bertos/drv/ser.c **** #include "cfg/cfg_proc.h"
  60:bertos/drv/ser.c **** #include <cfg/debug.h>
  61:bertos/drv/ser.c **** 
  62:bertos/drv/ser.c **** #include <mware/formatwr.h>
  63:bertos/drv/ser.c **** 
  64:bertos/drv/ser.c **** #include <cpu/power.h> /* cpu_relax() */
  65:bertos/drv/ser.c **** 
  66:bertos/drv/ser.c **** #include <string.h> /* memset() */
  67:bertos/drv/ser.c **** 
  68:bertos/drv/ser.c **** /*
  69:bertos/drv/ser.c ****  * Sanity check for config parameters required by this module.
  70:bertos/drv/ser.c ****  */
  71:bertos/drv/ser.c **** #if !defined(CONFIG_KERN) || ((CONFIG_KERN != 0) && CONFIG_KERN != 1)
  72:bertos/drv/ser.c **** 	#error CONFIG_KERN must be set to either 0 or 1 in cfg_kern.h
  73:bertos/drv/ser.c **** #endif
  74:bertos/drv/ser.c **** #if !defined(CONFIG_SER_RXTIMEOUT)
  75:bertos/drv/ser.c **** 	#error CONFIG_SER_TXTIMEOUT missing in cfg_ser.h
  76:bertos/drv/ser.c **** #endif
  77:bertos/drv/ser.c **** #if !defined(CONFIG_SER_RXTIMEOUT)
  78:bertos/drv/ser.c **** 	#error CONFIG_SER_RXTIMEOUT missing in cfg_ser.h
  79:bertos/drv/ser.c **** #endif
  80:bertos/drv/ser.c **** #if !defined(CONFIG_SER_DEFBAUDRATE)
  81:bertos/drv/ser.c **** 	#error CONFIG_SER_DEFBAUDRATE missing in cfg_ser.h
  82:bertos/drv/ser.c **** #endif
  83:bertos/drv/ser.c **** 
  84:bertos/drv/ser.c **** 
  85:bertos/drv/ser.c **** struct Serial *ser_handles[SER_CNT];
  86:bertos/drv/ser.c **** 
  87:bertos/drv/ser.c **** /**
  88:bertos/drv/ser.c ****  * Insert \a c in tx FIFO buffer.
  89:bertos/drv/ser.c ****  * \note This function will switch out the calling process
  90:bertos/drv/ser.c ****  * if the tx buffer is full. If the buffer is full
  91:bertos/drv/ser.c ****  * and \a port->txtimeout is 0 return EOF immediatly.
  92:bertos/drv/ser.c ****  *
  93:bertos/drv/ser.c ****  * \return EOF on error or timeout, \a c otherwise.
  94:bertos/drv/ser.c ****  */
  95:bertos/drv/ser.c **** static int ser_putchar(int c, struct Serial *port)
  96:bertos/drv/ser.c **** {
  18               		.loc 1 96 0
  19               		.cfi_startproc
  20               	.LVL0:
  21 0000 CF93      		push r28	 ;  157	*pushqi/1	[length = 1]
  22               	.LCFI0:
  23               		.cfi_def_cfa_offset 3
  24               		.cfi_offset 28, -2
  25               	/* prologue: function */
  26               	/* frame size = 0 */
  27               	/* stack size = 1 */
  28               	.L__stack_usage = 1
  29 0002 C82F      		mov r28,r24	 ;  132	*movqi/1	[length = 1]
  30 0004 FB01      		movw r30,r22	 ;  3	*movhi/1	[length = 1]
  31               	.LVL1:
  32               	.LBB129:
  33               	.LBB130:
  34               	.LBB131:
  35               		.file 2 "bertos/struct/fifobuf.h"
   1:bertos/struct/fifobuf.h **** /**
   2:bertos/struct/fifobuf.h ****  * \file
   3:bertos/struct/fifobuf.h ****  * <!--
   4:bertos/struct/fifobuf.h ****  * This file is part of BeRTOS.
   5:bertos/struct/fifobuf.h ****  *
   6:bertos/struct/fifobuf.h ****  * Bertos is free software; you can redistribute it and/or modify
   7:bertos/struct/fifobuf.h ****  * it under the terms of the GNU General Public License as published by
   8:bertos/struct/fifobuf.h ****  * the Free Software Foundation; either version 2 of the License, or
   9:bertos/struct/fifobuf.h ****  * (at your option) any later version.
  10:bertos/struct/fifobuf.h ****  *
  11:bertos/struct/fifobuf.h ****  * This program is distributed in the hope that it will be useful,
  12:bertos/struct/fifobuf.h ****  * but WITHOUT ANY WARRANTY; without even the implied warranty of
  13:bertos/struct/fifobuf.h ****  * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
  14:bertos/struct/fifobuf.h ****  * GNU General Public License for more details.
  15:bertos/struct/fifobuf.h ****  *
  16:bertos/struct/fifobuf.h ****  * You should have received a copy of the GNU General Public License
  17:bertos/struct/fifobuf.h ****  * along with this program; if not, write to the Free Software
  18:bertos/struct/fifobuf.h ****  * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
  19:bertos/struct/fifobuf.h ****  *
  20:bertos/struct/fifobuf.h ****  * As a special exception, you may use this file as part of a free software
  21:bertos/struct/fifobuf.h ****  * library without restriction.  Specifically, if other files instantiate
  22:bertos/struct/fifobuf.h ****  * templates or use macros or inline functions from this file, or you compile
  23:bertos/struct/fifobuf.h ****  * this file and link it with other files to produce an executable, this
  24:bertos/struct/fifobuf.h ****  * file does not by itself cause the resulting executable to be covered by
  25:bertos/struct/fifobuf.h ****  * the GNU General Public License.  This exception does not however
  26:bertos/struct/fifobuf.h ****  * invalidate any other reasons why the executable file might be covered by
  27:bertos/struct/fifobuf.h ****  * the GNU General Public License.
  28:bertos/struct/fifobuf.h ****  *
  29:bertos/struct/fifobuf.h ****  * Copyright 2003, 2004 Develer S.r.l. (http://www.develer.com/)
  30:bertos/struct/fifobuf.h ****  * Copyright 2001, 2008 Bernie Innocenti <bernie@codewiz.org>
  31:bertos/struct/fifobuf.h ****  * -->
  32:bertos/struct/fifobuf.h ****  *
  33:bertos/struct/fifobuf.h ****  * \brief General pourpose FIFO buffer implemented with a ring buffer
  34:bertos/struct/fifobuf.h ****  *
  35:bertos/struct/fifobuf.h ****  * \li \c begin points to the first buffer element;
  36:bertos/struct/fifobuf.h ****  * \li \c end points to the last buffer element (unlike the STL convention);
  37:bertos/struct/fifobuf.h ****  * \li \c head points to the element to be extracted next;
  38:bertos/struct/fifobuf.h ****  * \li \c tail points to the location following the last insertion;
  39:bertos/struct/fifobuf.h ****  * \li when any of the pointers advances beyond \c end, it is reset
  40:bertos/struct/fifobuf.h ****  *     back to \c begin.
  41:bertos/struct/fifobuf.h ****  *
  42:bertos/struct/fifobuf.h ****  * \code
  43:bertos/struct/fifobuf.h ****  *
  44:bertos/struct/fifobuf.h ****  *  +-----------------------------------+
  45:bertos/struct/fifobuf.h ****  *  |  empty  |   valid data   |  empty |
  46:bertos/struct/fifobuf.h ****  *  +-----------------------------------+
  47:bertos/struct/fifobuf.h ****  *  ^         ^                ^        ^
  48:bertos/struct/fifobuf.h ****  *  begin    head             tail     end
  49:bertos/struct/fifobuf.h ****  *
  50:bertos/struct/fifobuf.h ****  * \endcode
  51:bertos/struct/fifobuf.h ****  *
  52:bertos/struct/fifobuf.h ****  * The buffer is EMPTY when \c head and \c tail point to the same location:
  53:bertos/struct/fifobuf.h ****  *		\code head == tail \endcode
  54:bertos/struct/fifobuf.h ****  *
  55:bertos/struct/fifobuf.h ****  * The buffer is FULL when \c tail points to the location immediately
  56:bertos/struct/fifobuf.h ****  * after \c head:
  57:bertos/struct/fifobuf.h ****  *		\code tail == head - 1 \endcode
  58:bertos/struct/fifobuf.h ****  *
  59:bertos/struct/fifobuf.h ****  * The buffer is also FULL when \c tail points to the last buffer
  60:bertos/struct/fifobuf.h ****  * location and head points to the first one:
  61:bertos/struct/fifobuf.h ****  *		\code head == begin && tail == end \endcode
  62:bertos/struct/fifobuf.h ****  *
  63:bertos/struct/fifobuf.h ****  * \version $Id: fifobuf.h 2506 2009-04-15 08:29:07Z duplo $
  64:bertos/struct/fifobuf.h ****  * \author Bernie Innocenti <bernie@codewiz.org>
  65:bertos/struct/fifobuf.h ****  */
  66:bertos/struct/fifobuf.h **** 
  67:bertos/struct/fifobuf.h **** #ifndef STRUCT_FIFO_H
  68:bertos/struct/fifobuf.h **** #define STRUCT_FIFO_H
  69:bertos/struct/fifobuf.h **** 
  70:bertos/struct/fifobuf.h **** #include <cpu/types.h>
  71:bertos/struct/fifobuf.h **** #include <cpu/irq.h>
  72:bertos/struct/fifobuf.h **** #include <cfg/debug.h>
  73:bertos/struct/fifobuf.h **** 
  74:bertos/struct/fifobuf.h **** typedef struct FIFOBuffer
  75:bertos/struct/fifobuf.h **** {
  76:bertos/struct/fifobuf.h **** 	unsigned char * volatile head;
  77:bertos/struct/fifobuf.h **** 	unsigned char * volatile tail;
  78:bertos/struct/fifobuf.h **** 	unsigned char *begin;
  79:bertos/struct/fifobuf.h **** 	unsigned char *end;
  80:bertos/struct/fifobuf.h **** } FIFOBuffer;
  81:bertos/struct/fifobuf.h **** 
  82:bertos/struct/fifobuf.h **** 
  83:bertos/struct/fifobuf.h **** #define ASSERT_VALID_FIFO(fifo) \
  84:bertos/struct/fifobuf.h **** 	ATOMIC( \
  85:bertos/struct/fifobuf.h **** 		ASSERT((fifo)->head >= (fifo)->begin); \
  86:bertos/struct/fifobuf.h **** 		ASSERT((fifo)->head <= (fifo)->end); \
  87:bertos/struct/fifobuf.h **** 		ASSERT((fifo)->tail >= (fifo)->begin); \
  88:bertos/struct/fifobuf.h **** 		ASSERT((fifo)->tail <= (fifo)->end); \
  89:bertos/struct/fifobuf.h **** 	)
  90:bertos/struct/fifobuf.h **** 
  91:bertos/struct/fifobuf.h **** 
  92:bertos/struct/fifobuf.h **** /**
  93:bertos/struct/fifobuf.h ****  * Check whether the fifo is empty
  94:bertos/struct/fifobuf.h ****  *
  95:bertos/struct/fifobuf.h ****  * \note Calling fifo_isempty() is safe while a concurrent
  96:bertos/struct/fifobuf.h ****  *       execution context is calling fifo_push() or fifo_pop()
  97:bertos/struct/fifobuf.h ****  *       only if the CPU can atomically update a pointer
  98:bertos/struct/fifobuf.h ****  *       (which the AVR and other 8-bit processors can't do).
  99:bertos/struct/fifobuf.h ****  *
 100:bertos/struct/fifobuf.h ****  * \sa fifo_isempty_locked
 101:bertos/struct/fifobuf.h ****  */
 102:bertos/struct/fifobuf.h **** INLINE bool fifo_isempty(const FIFOBuffer *fb)
 103:bertos/struct/fifobuf.h **** {
 104:bertos/struct/fifobuf.h **** 	//ASSERT_VALID_FIFO(fb);
 105:bertos/struct/fifobuf.h **** 	return fb->head == fb->tail;
 106:bertos/struct/fifobuf.h **** }
 107:bertos/struct/fifobuf.h **** 
 108:bertos/struct/fifobuf.h **** 
 109:bertos/struct/fifobuf.h **** /**
 110:bertos/struct/fifobuf.h ****  * Check whether the fifo is full
 111:bertos/struct/fifobuf.h ****  *
 112:bertos/struct/fifobuf.h ****  * \note Calling fifo_isfull() is safe while a concurrent
 113:bertos/struct/fifobuf.h ****  *       execution context is calling fifo_pop() and the
 114:bertos/struct/fifobuf.h ****  *       CPU can update a pointer atomically.
 115:bertos/struct/fifobuf.h ****  *       It is NOT safe when the other context calls
 116:bertos/struct/fifobuf.h ****  *       fifo_push().
 117:bertos/struct/fifobuf.h ****  *       This limitation is not usually problematic in a
 118:bertos/struct/fifobuf.h ****  *       consumer/producer scenario because the
 119:bertos/struct/fifobuf.h ****  *       fifo_isfull() and fifo_push() are usually called
 120:bertos/struct/fifobuf.h ****  *       in the producer context.
 121:bertos/struct/fifobuf.h ****  */
 122:bertos/struct/fifobuf.h **** INLINE bool fifo_isfull(const FIFOBuffer *fb)
 123:bertos/struct/fifobuf.h **** {
 124:bertos/struct/fifobuf.h **** 	//ASSERT_VALID_FIFO(fb);
 125:bertos/struct/fifobuf.h **** 	return
 126:bertos/struct/fifobuf.h **** 		((fb->head == fb->begin) && (fb->tail == fb->end))
 127:bertos/struct/fifobuf.h **** 		|| (fb->tail == fb->head - 1);
 128:bertos/struct/fifobuf.h **** }
 129:bertos/struct/fifobuf.h **** 
 130:bertos/struct/fifobuf.h **** 
 131:bertos/struct/fifobuf.h **** /**
 132:bertos/struct/fifobuf.h ****  * Push a character on the fifo buffer.
 133:bertos/struct/fifobuf.h ****  *
 134:bertos/struct/fifobuf.h ****  * \note Calling \c fifo_push() on a full buffer is undefined.
 135:bertos/struct/fifobuf.h ****  *       The caller must make sure the buffer has at least
 136:bertos/struct/fifobuf.h ****  *       one free slot before calling this function.
 137:bertos/struct/fifobuf.h ****  *
 138:bertos/struct/fifobuf.h ****  * \note It is safe to call fifo_pop() and fifo_push() from
 139:bertos/struct/fifobuf.h ****  *       concurrent contexts, unless the CPU can't update
 140:bertos/struct/fifobuf.h ****  *       a pointer atomically (which the AVR and other 8-bit
 141:bertos/struct/fifobuf.h ****  *       processors can't do).
 142:bertos/struct/fifobuf.h ****  *
 143:bertos/struct/fifobuf.h ****  * \sa fifo_push_locked
 144:bertos/struct/fifobuf.h ****  */
 145:bertos/struct/fifobuf.h **** INLINE void fifo_push(FIFOBuffer *fb, unsigned char c)
 146:bertos/struct/fifobuf.h **** {
 147:bertos/struct/fifobuf.h **** #ifdef __MWERKS__
 148:bertos/struct/fifobuf.h **** #pragma interrupt called
 149:bertos/struct/fifobuf.h **** #endif
 150:bertos/struct/fifobuf.h **** 	//ASSERT_VALID_FIFO(fb);
 151:bertos/struct/fifobuf.h **** 
 152:bertos/struct/fifobuf.h **** 	/* Write at tail position */
 153:bertos/struct/fifobuf.h **** 	*(fb->tail) = c;
 154:bertos/struct/fifobuf.h **** 
 155:bertos/struct/fifobuf.h **** 	if (UNLIKELY(fb->tail == fb->end))
 156:bertos/struct/fifobuf.h **** 		/* wrap tail around */
 157:bertos/struct/fifobuf.h **** 		fb->tail = fb->begin;
 158:bertos/struct/fifobuf.h **** 	else
 159:bertos/struct/fifobuf.h **** 		/* Move tail forward */
 160:bertos/struct/fifobuf.h **** 		fb->tail++;
 161:bertos/struct/fifobuf.h **** }
 162:bertos/struct/fifobuf.h **** 
 163:bertos/struct/fifobuf.h **** 
 164:bertos/struct/fifobuf.h **** /**
 165:bertos/struct/fifobuf.h ****  * Pop a character from the fifo buffer.
 166:bertos/struct/fifobuf.h ****  *
 167:bertos/struct/fifobuf.h ****  * \note Calling \c fifo_pop() on an empty buffer is undefined.
 168:bertos/struct/fifobuf.h ****  *       The caller must make sure the buffer contains at least
 169:bertos/struct/fifobuf.h ****  *       one character before calling this function.
 170:bertos/struct/fifobuf.h ****  *
 171:bertos/struct/fifobuf.h ****  * \note It is safe to call fifo_pop() and fifo_push() from
 172:bertos/struct/fifobuf.h ****  *       concurrent contexts.
 173:bertos/struct/fifobuf.h ****  */
 174:bertos/struct/fifobuf.h **** INLINE unsigned char fifo_pop(FIFOBuffer *fb)
 175:bertos/struct/fifobuf.h **** {
 176:bertos/struct/fifobuf.h **** #ifdef __MWERKS__
 177:bertos/struct/fifobuf.h **** #pragma interrupt called
 178:bertos/struct/fifobuf.h **** #endif
 179:bertos/struct/fifobuf.h **** 	//ASSERT_VALID_FIFO(fb);
 180:bertos/struct/fifobuf.h **** 
 181:bertos/struct/fifobuf.h **** 	if (UNLIKELY(fb->head == fb->end))
 182:bertos/struct/fifobuf.h **** 	{
 183:bertos/struct/fifobuf.h **** 		/* wrap head around */
 184:bertos/struct/fifobuf.h **** 		fb->head = fb->begin;
 185:bertos/struct/fifobuf.h **** 		return *(fb->end);
 186:bertos/struct/fifobuf.h **** 	}
 187:bertos/struct/fifobuf.h **** 	else
 188:bertos/struct/fifobuf.h **** 		/* move head forward */
 189:bertos/struct/fifobuf.h **** 		return *(fb->head++);
 190:bertos/struct/fifobuf.h **** }
 191:bertos/struct/fifobuf.h **** 
 192:bertos/struct/fifobuf.h **** 
 193:bertos/struct/fifobuf.h **** /**
 194:bertos/struct/fifobuf.h ****  * Make the fifo empty, discarding all its current contents.
 195:bertos/struct/fifobuf.h ****  */
 196:bertos/struct/fifobuf.h **** INLINE void fifo_flush(FIFOBuffer *fb)
 197:bertos/struct/fifobuf.h **** {
 198:bertos/struct/fifobuf.h **** 	//ASSERT_VALID_FIFO(fb);
 199:bertos/struct/fifobuf.h **** 	fb->head = fb->tail;
 200:bertos/struct/fifobuf.h **** }
 201:bertos/struct/fifobuf.h **** 
 202:bertos/struct/fifobuf.h **** 
 203:bertos/struct/fifobuf.h **** #if CPU_REG_BITS >= CPU_BITS_PER_PTR
 204:bertos/struct/fifobuf.h **** 
 205:bertos/struct/fifobuf.h **** 	/*
 206:bertos/struct/fifobuf.h **** 	 * 16/32bit CPUs that can update a pointer with a single write
 207:bertos/struct/fifobuf.h **** 	 * operation, no need to disable interrupts.
 208:bertos/struct/fifobuf.h **** 	 */
 209:bertos/struct/fifobuf.h **** 	#define fifo_isempty_locked(fb) fifo_isempty((fb))
 210:bertos/struct/fifobuf.h **** 	#define fifo_push_locked(fb, c) fifo_push((fb), (c))
 211:bertos/struct/fifobuf.h **** 	#define fifo_pop_locked(fb)     fifo_pop((fb))
 212:bertos/struct/fifobuf.h **** 	#define fifo_flush_locked(fb)   fifo_flush((fb))
 213:bertos/struct/fifobuf.h **** 
 214:bertos/struct/fifobuf.h **** #else /* CPU_REG_BITS < CPU_BITS_PER_PTR */
 215:bertos/struct/fifobuf.h **** 
 216:bertos/struct/fifobuf.h **** 	/**
 217:bertos/struct/fifobuf.h **** 	 * Similar to fifo_isempty(), but with stronger guarantees for
 218:bertos/struct/fifobuf.h **** 	 * concurrent access between user and interrupt code.
 219:bertos/struct/fifobuf.h **** 	 *
 220:bertos/struct/fifobuf.h **** 	 * \note This is actually only needed for 8-bit processors.
 221:bertos/struct/fifobuf.h **** 	 *
 222:bertos/struct/fifobuf.h **** 	 * \sa fifo_isempty()
 223:bertos/struct/fifobuf.h **** 	 */
 224:bertos/struct/fifobuf.h **** 	INLINE bool fifo_isempty_locked(const FIFOBuffer *fb)
 225:bertos/struct/fifobuf.h **** 	{
 226:bertos/struct/fifobuf.h **** 		bool result;
 227:bertos/struct/fifobuf.h **** 		ATOMIC(result = fifo_isempty(fb));
 228:bertos/struct/fifobuf.h **** 		return result;
 229:bertos/struct/fifobuf.h **** 	}
 230:bertos/struct/fifobuf.h **** 
 231:bertos/struct/fifobuf.h **** 
 232:bertos/struct/fifobuf.h **** 	/**
 233:bertos/struct/fifobuf.h **** 	 * Similar to fifo_push(), but with stronger guarantees for
 234:bertos/struct/fifobuf.h **** 	 * concurrent access between user and interrupt code.
 235:bertos/struct/fifobuf.h **** 	 *
 236:bertos/struct/fifobuf.h **** 	 * \note This is actually only needed for 8-bit processors.
 237:bertos/struct/fifobuf.h **** 	 *
 238:bertos/struct/fifobuf.h **** 	 * \sa fifo_push()
 239:bertos/struct/fifobuf.h **** 	 */
 240:bertos/struct/fifobuf.h **** 	INLINE void fifo_push_locked(FIFOBuffer *fb, unsigned char c)
 241:bertos/struct/fifobuf.h **** 	{
 242:bertos/struct/fifobuf.h **** 		ATOMIC(fifo_push(fb, c));
 243:bertos/struct/fifobuf.h **** 	}
 244:bertos/struct/fifobuf.h **** 
 245:bertos/struct/fifobuf.h **** 	/* Probably not really needed, but hard to prove. */
 246:bertos/struct/fifobuf.h **** 	INLINE unsigned char fifo_pop_locked(FIFOBuffer *fb)
 247:bertos/struct/fifobuf.h **** 	{
 248:bertos/struct/fifobuf.h **** 		unsigned char c;
 249:bertos/struct/fifobuf.h **** 		ATOMIC(c = fifo_pop(fb));
 250:bertos/struct/fifobuf.h **** 		return c;
 251:bertos/struct/fifobuf.h **** 	}
 252:bertos/struct/fifobuf.h **** 
 253:bertos/struct/fifobuf.h **** 	/**
 254:bertos/struct/fifobuf.h **** 	 * Similar to fifo_flush(), but with stronger guarantees for
 255:bertos/struct/fifobuf.h **** 	 * concurrent access between user and interrupt code.
 256:bertos/struct/fifobuf.h **** 	 *
 257:bertos/struct/fifobuf.h **** 	 * \note This is actually only needed for 8-bit processors.
 258:bertos/struct/fifobuf.h **** 	 *
 259:bertos/struct/fifobuf.h **** 	 * \sa fifo_flush()
 260:bertos/struct/fifobuf.h **** 	 */
 261:bertos/struct/fifobuf.h **** 	INLINE void fifo_flush_locked(FIFOBuffer *fb)
 262:bertos/struct/fifobuf.h **** 	{
 263:bertos/struct/fifobuf.h **** 		ATOMIC(fifo_flush(fb));
 264:bertos/struct/fifobuf.h **** 	}
 265:bertos/struct/fifobuf.h **** 
 266:bertos/struct/fifobuf.h **** #endif /* CPU_REG_BITS < BITS_PER_PTR */
 267:bertos/struct/fifobuf.h **** 
 268:bertos/struct/fifobuf.h **** 
 269:bertos/struct/fifobuf.h **** /**
 270:bertos/struct/fifobuf.h ****  * Thread safe version of fifo_isfull()
 271:bertos/struct/fifobuf.h ****  */
 272:bertos/struct/fifobuf.h **** INLINE bool fifo_isfull_locked(const FIFOBuffer *_fb)
 273:bertos/struct/fifobuf.h **** {
 274:bertos/struct/fifobuf.h **** 	bool result;
 275:bertos/struct/fifobuf.h **** 	ATOMIC(result = fifo_isfull(_fb));
  36               		.loc 2 275 0
  37               	/* #APP */
  38               	 ;  275 "bertos/struct/fifobuf.h" 1
  39 0006 6FB7      		in r22,__SREG__
  40 0008 F894      		cli
  41               	 ;  0 "" 2
  42               	.LVL2:
  43               	/* #NOAPP */
  44               	.LBB132:
  45               	.LBB133:
 126:bertos/struct/fifobuf.h **** 		((fb->head == fb->begin) && (fb->tail == fb->end))
  46               		.loc 2 126 0
  47 000a 878D      		ldd r24,Z+31	 ;  15	*movhi/2	[length = 2]
  48 000c 90A1      		ldd r25,Z+32
  49               	.LVL3:
  50 000e A3A1      		ldd r26,Z+35	 ;  16	*movhi/2	[length = 2]
  51 0010 B4A1      		ldd r27,Z+36
  52 0012 00C0      		rjmp .L20	 ;  191	jump	[length = 1]
  53               	.LVL4:
  54               	.L12:
 127:bertos/struct/fifobuf.h **** 		|| (fb->tail == fb->head - 1);
  55               		.loc 2 127 0
  56 0014 21E0      		ldi r18,lo8(1)	 ;  5	*movhi/4	[length = 2]
  57 0016 30E0      		ldi r19,hi8(1)
  58               	.L3:
  59               	.LBE133:
  60               	.LBE132:
  61               		.loc 2 275 0
  62               	/* #APP */
  63               	 ;  275 "bertos/struct/fifobuf.h" 1
  64 0018 6FBF      		out __SREG__,r22
  65               	 ;  0 "" 2
  66               	/* #NOAPP */
  67               	.LBE131:
  68               	.LBE130:
  69               	.LBE129:
  97:bertos/drv/ser.c **** 	if (fifo_isfull_locked(&port->txfifo))
  70               		.loc 1 97 0
  71 001a 2115      		cp r18,__zero_reg__	 ;  38	*cmphi/2	[length = 2]
  72 001c 3105      		cpc r19,__zero_reg__
  73 001e 01F0      		breq .L5	 ;  39	branch	[length = 1]
  74               	.LVL5:
  75               	.LBB134:
  76               	.LBB135:
  77               	.LBB136:
  78               		.loc 2 275 0 discriminator 1
  79               	/* #APP */
  80               	 ;  275 "bertos/struct/fifobuf.h" 1
  81 0020 6FB7      		in r22,__SREG__
  82 0022 F894      		cli
  83               	 ;  0 "" 2
  84               	.LVL6:
  85               	/* #NOAPP */
  86               	.LBB137:
  87               	.LBB138:
 126:bertos/struct/fifobuf.h **** 		((fb->head == fb->begin) && (fb->tail == fb->end))
  88               		.loc 2 126 0 discriminator 1
  89 0024 878D      		ldd r24,Z+31	 ;  47	*movhi/2	[length = 2]
  90 0026 90A1      		ldd r25,Z+32
  91               	.LVL7:
  92               	.L20:
 127:bertos/struct/fifobuf.h **** 		|| (fb->tail == fb->head - 1);
  93               		.loc 2 127 0 discriminator 1
  94 0028 8A17      		cp r24,r26	 ;  48	*cmphi/3	[length = 2]
  95 002a 9B07      		cpc r25,r27
  96 002c 01F4      		brne .L6	 ;  49	branch	[length = 1]
 126:bertos/struct/fifobuf.h **** 		((fb->head == fb->begin) && (fb->tail == fb->end))
  97               		.loc 2 126 0
  98 002e 21A1      		ldd r18,Z+33	 ;  51	*movhi/2	[length = 2]
  99 0030 32A1      		ldd r19,Z+34
 100 0032 85A1      		ldd r24,Z+37	 ;  52	*movhi/2	[length = 2]
 101 0034 96A1      		ldd r25,Z+38
 102 0036 2817      		cp r18,r24	 ;  53	*cmphi/3	[length = 2]
 103 0038 3907      		cpc r19,r25
 104 003a 01F0      		breq .L12	 ;  54	branch	[length = 1]
 105               	.L6:
 127:bertos/struct/fifobuf.h **** 		|| (fb->tail == fb->head - 1);
 106               		.loc 2 127 0
 107 003c 41A1      		ldd r20,Z+33	 ;  57	*movhi/2	[length = 2]
 108 003e 52A1      		ldd r21,Z+34
 109 0040 878D      		ldd r24,Z+31	 ;  58	*movhi/2	[length = 2]
 110 0042 90A1      		ldd r25,Z+32
 111 0044 0197      		sbiw r24,1	 ;  59	*addhi3/3	[length = 1]
 112 0046 21E0      		ldi r18,lo8(1)	 ;  147	*movhi/4	[length = 2]
 113 0048 30E0      		ldi r19,hi8(1)
 114 004a 4817      		cp r20,r24	 ;  61	*cmphi/3	[length = 2]
 115 004c 5907      		cpc r21,r25
 116 004e 01F0      		breq .L3	 ;  62	branch	[length = 1]
 117 0050 20E0      		ldi r18,lo8(0)	 ;  148	*movhi/4	[length = 2]
 118 0052 30E0      		ldi r19,hi8(0)
 119 0054 00C0      		rjmp .L3	 ;  193	jump	[length = 1]
 120               	.L5:
 121               	.LVL8:
 122               	.LBE138:
 123               	.LBE137:
 124               	.LBE136:
 125               	.LBE135:
 126               	.LBE134:
 127               	.LBB139:
 128               	.LBB140:
 242:bertos/struct/fifobuf.h **** 		ATOMIC(fifo_push(fb, c));
 129               		.loc 2 242 0
 130               	/* #APP */
 131               	 ;  242 "bertos/struct/fifobuf.h" 1
 132 0056 4FB7      		in r20,__SREG__
 133 0058 F894      		cli
 134               	 ;  0 "" 2
 135               	.LVL9:
 136               	/* #NOAPP */
 137               	.LBB141:
 138               	.LBB142:
 153:bertos/struct/fifobuf.h **** 	*(fb->tail) = c;
 139               		.loc 2 153 0
 140 005a A1A1      		ldd r26,Z+33	 ;  83	*movhi/2	[length = 2]
 141 005c B2A1      		ldd r27,Z+34
 142 005e CC93      		st X,r28	 ;  84	*movqi/3	[length = 1]
 155:bertos/struct/fifobuf.h **** 	if (UNLIKELY(fb->tail == fb->end))
 143               		.loc 2 155 0
 144 0060 21A1      		ldd r18,Z+33	 ;  85	*movhi/2	[length = 2]
 145 0062 32A1      		ldd r19,Z+34
 146 0064 85A1      		ldd r24,Z+37	 ;  86	*movhi/2	[length = 2]
 147 0066 96A1      		ldd r25,Z+38
 148 0068 2817      		cp r18,r24	 ;  87	*cmphi/3	[length = 2]
 149 006a 3907      		cpc r19,r25
 150 006c 01F4      		brne .L10	 ;  88	branch	[length = 1]
 157:bertos/struct/fifobuf.h **** 		fb->tail = fb->begin;
 151               		.loc 2 157 0
 152 006e 83A1      		ldd r24,Z+35	 ;  90	*movhi/2	[length = 2]
 153 0070 94A1      		ldd r25,Z+36
 154 0072 00C0      		rjmp .L16	 ;  195	jump	[length = 1]
 155               	.L10:
 160:bertos/struct/fifobuf.h **** 		fb->tail++;
 156               		.loc 2 160 0
 157 0074 81A1      		ldd r24,Z+33	 ;  96	*movhi/2	[length = 2]
 158 0076 92A1      		ldd r25,Z+34
 159 0078 0196      		adiw r24,1	 ;  97	*addhi3/2	[length = 1]
 160               	.L16:
 161 007a 92A3      		std Z+34,r25	 ;  98	*movhi/3	[length = 2]
 162 007c 81A3      		std Z+33,r24
 163               	.LBE142:
 164               	.LBE141:
 242:bertos/struct/fifobuf.h **** 		ATOMIC(fifo_push(fb, c));
 165               		.loc 2 242 0
 166               	/* #APP */
 167               	 ;  242 "bertos/struct/fifobuf.h" 1
 168 007e 4FBF      		out __SREG__,r20
 169               	 ;  0 "" 2
 170               	/* #NOAPP */
 171               	.LBE140:
 172               	.LBE139:
  98:bertos/drv/ser.c **** 	{
  99:bertos/drv/ser.c **** #if CONFIG_SER_TXTIMEOUT != -1
 100:bertos/drv/ser.c **** 		/* If timeout == 0 we don't want to wait */
 101:bertos/drv/ser.c **** 		if (port->txtimeout == 0)
 102:bertos/drv/ser.c **** 			return EOF;
 103:bertos/drv/ser.c **** 
 104:bertos/drv/ser.c **** 		ticks_t start_time = timer_clock();
 105:bertos/drv/ser.c **** #endif
 106:bertos/drv/ser.c **** 
 107:bertos/drv/ser.c **** 		/* Wait while buffer is full... */
 108:bertos/drv/ser.c **** 		do
 109:bertos/drv/ser.c **** 		{
 110:bertos/drv/ser.c **** 			cpu_relax();
 111:bertos/drv/ser.c **** 
 112:bertos/drv/ser.c **** #if CONFIG_SER_TXTIMEOUT != -1
 113:bertos/drv/ser.c **** 			if (timer_clock() - start_time >= port->txtimeout)
 114:bertos/drv/ser.c **** 			{
 115:bertos/drv/ser.c **** 				ATOMIC(port->status |= SERRF_TXTIMEOUT);
 116:bertos/drv/ser.c **** 				return EOF;
 117:bertos/drv/ser.c **** 			}
 118:bertos/drv/ser.c **** #endif /* CONFIG_SER_TXTIMEOUT */
 119:bertos/drv/ser.c **** 		}
 120:bertos/drv/ser.c **** 		while (fifo_isfull_locked(&port->txfifo));
 121:bertos/drv/ser.c **** 	}
 122:bertos/drv/ser.c **** 
 123:bertos/drv/ser.c **** 	fifo_push_locked(&port->txfifo, (unsigned char)c);
 124:bertos/drv/ser.c **** 
 125:bertos/drv/ser.c **** 	/* (re)trigger tx interrupt */
 126:bertos/drv/ser.c **** 	port->hw->table->txStart(port->hw);
 173               		.loc 1 126 0
 174 0080 80A9      		ldd r24,Z+48	 ;  102	*movhi/2	[length = 2]
 175 0082 91A9      		ldd r25,Z+49
 176 0084 DC01      		movw r26,r24	 ;  156	*movhi/1	[length = 1]
 177 0086 ED91      		ld r30,X+	 ;  104	*movhi/2	[length = 2]
 178 0088 FC91      		ld r31,X
 179               	.LVL10:
 180 008a 0084      		ldd __tmp_reg__,Z+8	 ;  105	*movhi/2	[length = 3]
 181 008c F185      		ldd r31,Z+9
 182 008e E02D      		mov r30,__tmp_reg__
 183 0090 0995      		icall	 ;  107	call_insn/1	[length = 1]
 184               	.LVL11:
 127:bertos/drv/ser.c **** 
 128:bertos/drv/ser.c **** 	/* Avoid returning signed extended char */
 129:bertos/drv/ser.c **** 	return (int)((unsigned char)c);
 130:bertos/drv/ser.c **** }
 185               		.loc 1 130 0
 186 0092 8C2F      		mov r24,r28	 ;  138	*movqi/1	[length = 1]
 187 0094 90E0      		ldi r25,lo8(0)	 ;  139	*movqi/2	[length = 1]
 188               	/* epilogue start */
 189 0096 CF91      		pop r28	 ;  160	popqi	[length = 1]
 190               	.LVL12:
 191 0098 0895      		ret	 ;  161	return_from_epilogue	[length = 1]
 192               		.cfi_endproc
 193               	.LFE49:
 195               		.section	.text.ser_getchar,"ax",@progbits
 197               	ser_getchar:
 198               	.LFB50:
 131:bertos/drv/ser.c **** 
 132:bertos/drv/ser.c **** 
 133:bertos/drv/ser.c **** /**
 134:bertos/drv/ser.c ****  * Fetch a character from the rx FIFO buffer.
 135:bertos/drv/ser.c ****  * \note This function will switch out the calling process
 136:bertos/drv/ser.c ****  * if the rx buffer is empty. If the buffer is empty
 137:bertos/drv/ser.c ****  * and \a port->rxtimeout is 0 return EOF immediatly.
 138:bertos/drv/ser.c ****  *
 139:bertos/drv/ser.c ****  * \return EOF on error or timeout, \a c otherwise.
 140:bertos/drv/ser.c ****  */
 141:bertos/drv/ser.c **** static int ser_getchar(struct Serial *port)
 142:bertos/drv/ser.c **** {
 199               		.loc 1 142 0
 200               		.cfi_startproc
 201               	.LVL13:
 202               	/* prologue: function */
 203               	/* frame size = 0 */
 204               	/* stack size = 0 */
 205               	.L__stack_usage = 0
 206 0000 FC01      		movw r30,r24	 ;  2	*movhi/1	[length = 1]
 207               	.LVL14:
 208               	.LBB143:
 209               	.LBB144:
 210               	.LBB145:
 227:bertos/struct/fifobuf.h **** 		ATOMIC(result = fifo_isempty(fb));
 211               		.loc 2 227 0
 212               	/* #APP */
 213               	 ;  227 "bertos/struct/fifobuf.h" 1
 214 0002 4FB7      		in r20,__SREG__
 215 0004 F894      		cli
 216               	 ;  0 "" 2
 217               	.LVL15:
 218               	/* #NOAPP */
 219               	.LBB146:
 220               	.LBB147:
 105:bertos/struct/fifobuf.h **** 	return fb->head == fb->tail;
 221               		.loc 2 105 0
 222 0006 27A1      		ldd r18,Z+39	 ;  13	*movhi/2	[length = 2]
 223 0008 30A5      		ldd r19,Z+40
 224 000a 81A5      		ldd r24,Z+41	 ;  14	*movhi/2	[length = 2]
 225 000c 92A5      		ldd r25,Z+42
 226               	.LVL16:
 227               	.LBE147:
 228               	.LBE146:
 227:bertos/struct/fifobuf.h **** 		ATOMIC(result = fifo_isempty(fb));
 229               		.loc 2 227 0
 230               	/* #APP */
 231               	 ;  227 "bertos/struct/fifobuf.h" 1
 232 000e 4FBF      		out __SREG__,r20
 233               	 ;  0 "" 2
 234               	/* #NOAPP */
 235               	.LBE145:
 236               	.LBE144:
 237               	.LBE143:
 143:bertos/drv/ser.c **** 	if (fifo_isempty_locked(&port->rxfifo))
 238               		.loc 1 143 0
 239 0010 2817      		cp r18,r24	 ;  17	*cmphi/3	[length = 2]
 240 0012 3907      		cpc r19,r25
 241 0014 01F4      		brne .L22	 ;  18	branch	[length = 1]
 242               	.LVL17:
 243               	.L28:
 244               	.LBB148:
 245               	.LBB149:
 246               	.LBB150:
 227:bertos/struct/fifobuf.h **** 		ATOMIC(result = fifo_isempty(fb));
 247               		.loc 2 227 0 discriminator 1
 248               	/* #APP */
 249               	 ;  227 "bertos/struct/fifobuf.h" 1
 250 0016 4FB7      		in r20,__SREG__
 251 0018 F894      		cli
 252               	 ;  0 "" 2
 253               	.LVL18:
 254               	/* #NOAPP */
 255               	.LBB151:
 256               	.LBB152:
 105:bertos/struct/fifobuf.h **** 	return fb->head == fb->tail;
 257               		.loc 2 105 0 discriminator 1
 258 001a 27A1      		ldd r18,Z+39	 ;  26	*movhi/2	[length = 2]
 259 001c 30A5      		ldd r19,Z+40
 260 001e 81A5      		ldd r24,Z+41	 ;  27	*movhi/2	[length = 2]
 261 0020 92A5      		ldd r25,Z+42
 262               	.LBE152:
 263               	.LBE151:
 227:bertos/struct/fifobuf.h **** 		ATOMIC(result = fifo_isempty(fb));
 264               		.loc 2 227 0 discriminator 1
 265               	/* #APP */
 266               	 ;  227 "bertos/struct/fifobuf.h" 1
 267 0022 4FBF      		out __SREG__,r20
 268               	 ;  0 "" 2
 269               	/* #NOAPP */
 270               	.LBE150:
 271               	.LBE149:
 272               	.LBE148:
 144:bertos/drv/ser.c **** 	{
 145:bertos/drv/ser.c **** #if CONFIG_SER_RXTIMEOUT != -1
 146:bertos/drv/ser.c **** 		/* If timeout == 0 we don't want to wait for chars */
 147:bertos/drv/ser.c **** 		if (port->rxtimeout == 0)
 148:bertos/drv/ser.c **** 			return EOF;
 149:bertos/drv/ser.c **** 
 150:bertos/drv/ser.c **** 		ticks_t start_time = timer_clock();
 151:bertos/drv/ser.c **** #endif
 152:bertos/drv/ser.c **** 
 153:bertos/drv/ser.c **** 		/* Wait while buffer is empty */
 154:bertos/drv/ser.c **** 		do
 155:bertos/drv/ser.c **** 		{
 156:bertos/drv/ser.c **** 			cpu_relax();
 157:bertos/drv/ser.c **** 
 158:bertos/drv/ser.c **** #if CONFIG_SER_RXTIMEOUT != -1
 159:bertos/drv/ser.c **** 			if (timer_clock() - start_time >= port->rxtimeout)
 160:bertos/drv/ser.c **** 			{
 161:bertos/drv/ser.c **** 				ATOMIC(port->status |= SERRF_RXTIMEOUT);
 162:bertos/drv/ser.c **** 				return EOF;
 163:bertos/drv/ser.c **** 			}
 164:bertos/drv/ser.c **** #endif /* CONFIG_SER_RXTIMEOUT */
 165:bertos/drv/ser.c **** 		}
 166:bertos/drv/ser.c **** 		while (fifo_isempty_locked(&port->rxfifo) && (ser_getstatus(port) & SERRF_RX) == 0);
 273               		.loc 1 166 0 discriminator 1
 274 0024 2817      		cp r18,r24	 ;  30	*cmphi/3	[length = 2]
 275 0026 3907      		cpc r19,r25
 276 0028 01F4      		brne .L22	 ;  31	branch	[length = 1]
 277 002a 87A5      		ldd r24,Z+47	 ;  33	*movqi/4	[length = 1]
 278 002c 897B      		andi r24,lo8(-71)	 ;  36	andqi3/2	[length = 1]
 279 002e 01F0      		breq .L28	 ;  38	branch	[length = 1]
 280               	.LVL19:
 281               	.L22:
 167:bertos/drv/ser.c **** 	}
 168:bertos/drv/ser.c **** 
 169:bertos/drv/ser.c **** 	/*
 170:bertos/drv/ser.c **** 	 * Get a byte from the FIFO (avoiding sign-extension),
 171:bertos/drv/ser.c **** 	 * re-enable RTS, then return result.
 172:bertos/drv/ser.c **** 	 */
 173:bertos/drv/ser.c **** 	if (ser_getstatus(port) & SERRF_RX)
 282               		.loc 1 173 0
 283 0030 87A5      		ldd r24,Z+47	 ;  41	*movqi/4	[length = 1]
 284 0032 897B      		andi r24,lo8(-71)	 ;  43	andqi3/2	[length = 1]
 285 0034 01F4      		brne .L27	 ;  45	branch	[length = 1]
 286               	.LVL20:
 287               	.LBB153:
 288               	.LBB154:
 289               	.LBB155:
 249:bertos/struct/fifobuf.h **** 		ATOMIC(c = fifo_pop(fb));
 290               		.loc 2 249 0
 291               	/* #APP */
 292               	 ;  249 "bertos/struct/fifobuf.h" 1
 293 0036 2FB7      		in r18,__SREG__
 294 0038 F894      		cli
 295               	 ;  0 "" 2
 296               	.LVL21:
 297               	/* #NOAPP */
 298               	.LBB156:
 299               	.LBB157:
 181:bertos/struct/fifobuf.h **** 	if (UNLIKELY(fb->head == fb->end))
 300               		.loc 2 181 0
 301 003a A7A1      		ldd r26,Z+39	 ;  53	*movhi/2	[length = 2]
 302 003c B0A5      		ldd r27,Z+40
 303 003e 85A5      		ldd r24,Z+45	 ;  54	*movhi/2	[length = 2]
 304 0040 96A5      		ldd r25,Z+46
 305 0042 A817      		cp r26,r24	 ;  55	*cmphi/3	[length = 2]
 306 0044 B907      		cpc r27,r25
 307 0046 01F4      		brne .L25	 ;  56	branch	[length = 1]
 184:bertos/struct/fifobuf.h **** 		fb->head = fb->begin;
 308               		.loc 2 184 0
 309 0048 83A5      		ldd r24,Z+43	 ;  58	*movhi/2	[length = 2]
 310 004a 94A5      		ldd r25,Z+44
 311 004c 90A7      		std Z+40,r25	 ;  59	*movhi/3	[length = 2]
 312 004e 87A3      		std Z+39,r24
 185:bertos/struct/fifobuf.h **** 		return *(fb->end);
 313               		.loc 2 185 0
 314 0050 8C91      		ld r24,X	 ;  60	*movqi/4	[length = 1]
 315 0052 00C0      		rjmp .L26	 ;  110	jump	[length = 1]
 316               	.L25:
 189:bertos/struct/fifobuf.h **** 		return *(fb->head++);
 317               		.loc 2 189 0
 318 0054 A7A1      		ldd r26,Z+39	 ;  65	*movhi/2	[length = 2]
 319 0056 B0A5      		ldd r27,Z+40
 320 0058 8D91      		ld r24,X+	 ;  66	*movqi/4	[length = 1]
 321 005a B0A7      		std Z+40,r27	 ;  68	*movhi/3	[length = 2]
 322 005c A7A3      		std Z+39,r26
 323               	.L26:
 324               	.LBE157:
 325               	.LBE156:
 249:bertos/struct/fifobuf.h **** 		ATOMIC(c = fifo_pop(fb));
 326               		.loc 2 249 0
 327               	/* #APP */
 328               	 ;  249 "bertos/struct/fifobuf.h" 1
 329 005e 2FBF      		out __SREG__,r18
 330               	 ;  0 "" 2
 331               	/* #NOAPP */
 332               	.LBE155:
 333               	.LBE154:
 334               	.LBE153:
 174:bertos/drv/ser.c **** 		return EOF;
 175:bertos/drv/ser.c **** 	return (int)(unsigned char)fifo_pop_locked(&port->rxfifo);
 335               		.loc 1 175 0
 336 0060 90E0      		ldi r25,lo8(0)	 ;  105	*movqi/2	[length = 1]
 337 0062 0895      		ret	 ;  107	return	[length = 1]
 338               	.LVL22:
 339               	.L27:
 174:bertos/drv/ser.c **** 		return EOF;
 340               		.loc 1 174 0
 341 0064 8FEF      		ldi r24,lo8(-1)	 ;  4	*movhi/4	[length = 2]
 342 0066 9FEF      		ldi r25,hi8(-1)
 176:bertos/drv/ser.c **** }
 343               		.loc 1 176 0
 344 0068 0895      		ret	 ;  109	return	[length = 1]
 345               		.cfi_endproc
 346               	.LFE50:
 348               		.section	.text.ser_read,"ax",@progbits
 350               	ser_read:
 351               	.LFB52:
 177:bertos/drv/ser.c **** 
 178:bertos/drv/ser.c **** /**
 179:bertos/drv/ser.c ****  * Fetch a character from the rx FIFO buffer.
 180:bertos/drv/ser.c ****  * If the buffer is empty, ser_getchar_nowait() returns
 181:bertos/drv/ser.c ****  * EOF immediatly.
 182:bertos/drv/ser.c ****  * \note Deprecated, use ser_getchar with rx_timeout set to 0.
 183:bertos/drv/ser.c ****  */
 184:bertos/drv/ser.c **** int ser_getchar_nowait(struct Serial *fd)
 185:bertos/drv/ser.c **** {
 186:bertos/drv/ser.c **** 	if (fifo_isempty_locked(&fd->rxfifo))
 187:bertos/drv/ser.c **** 		return EOF;
 188:bertos/drv/ser.c **** 
 189:bertos/drv/ser.c **** 	/* NOTE: the double cast prevents unwanted sign extension */
 190:bertos/drv/ser.c **** 	return (int)(unsigned char)fifo_pop_locked(&fd->rxfifo);
 191:bertos/drv/ser.c **** }
 192:bertos/drv/ser.c **** 
 193:bertos/drv/ser.c **** 
 194:bertos/drv/ser.c **** 
 195:bertos/drv/ser.c **** /**
 196:bertos/drv/ser.c ****  * Read at most \a size bytes from \a port and put them in \a buf
 197:bertos/drv/ser.c ****  *
 198:bertos/drv/ser.c ****  * \return number of bytes actually read.
 199:bertos/drv/ser.c ****  */
 200:bertos/drv/ser.c **** static size_t ser_read(struct KFile *fd, void *_buf, size_t size)
 201:bertos/drv/ser.c **** {
 352               		.loc 1 201 0
 353               		.cfi_startproc
 354               	.LVL23:
 355 0000 CF92      		push r12	 ;  97	*pushqi/1	[length = 1]
 356               	.LCFI1:
 357               		.cfi_def_cfa_offset 3
 358               		.cfi_offset 12, -2
 359 0002 DF92      		push r13	 ;  98	*pushqi/1	[length = 1]
 360               	.LCFI2:
 361               		.cfi_def_cfa_offset 4
 362               		.cfi_offset 13, -3
 363 0004 EF92      		push r14	 ;  99	*pushqi/1	[length = 1]
 364               	.LCFI3:
 365               		.cfi_def_cfa_offset 5
 366               		.cfi_offset 14, -4
 367 0006 FF92      		push r15	 ;  100	*pushqi/1	[length = 1]
 368               	.LCFI4:
 369               		.cfi_def_cfa_offset 6
 370               		.cfi_offset 15, -5
 371 0008 0F93      		push r16	 ;  101	*pushqi/1	[length = 1]
 372               	.LCFI5:
 373               		.cfi_def_cfa_offset 7
 374               		.cfi_offset 16, -6
 375 000a 1F93      		push r17	 ;  102	*pushqi/1	[length = 1]
 376               	.LCFI6:
 377               		.cfi_def_cfa_offset 8
 378               		.cfi_offset 17, -7
 379 000c CF93      		push r28	 ;  103	*pushqi/1	[length = 1]
 380               	.LCFI7:
 381               		.cfi_def_cfa_offset 9
 382               		.cfi_offset 28, -8
 383 000e DF93      		push r29	 ;  104	*pushqi/1	[length = 1]
 384               	.LCFI8:
 385               		.cfi_def_cfa_offset 10
 386               		.cfi_offset 29, -9
 387               	/* prologue: function */
 388               	/* frame size = 0 */
 389               	/* stack size = 8 */
 390               	.L__stack_usage = 8
 391 0010 7C01      		movw r14,r24	 ;  23	*movhi/1	[length = 1]
 392 0012 D62F      		mov r29,r22	 ;  80	*movqi/1	[length = 1]
 393 0014 C72F      		mov r28,r23	 ;  81	*movqi/1	[length = 1]
 394 0016 6A01      		movw r12,r20	 ;  25	*movhi/1	[length = 1]
 395               	.LVL24:
 396               	.LBB158:
 397               	.LBB159:
 398               		.file 3 "bertos/drv/ser.h"
   1:bertos/drv/ser.h **** /**
   2:bertos/drv/ser.h ****  * \file
   3:bertos/drv/ser.h ****  * <!--
   4:bertos/drv/ser.h ****  * This file is part of BeRTOS.
   5:bertos/drv/ser.h ****  *
   6:bertos/drv/ser.h ****  * Bertos is free software; you can redistribute it and/or modify
   7:bertos/drv/ser.h ****  * it under the terms of the GNU General Public License as published by
   8:bertos/drv/ser.h ****  * the Free Software Foundation; either version 2 of the License, or
   9:bertos/drv/ser.h ****  * (at your option) any later version.
  10:bertos/drv/ser.h ****  *
  11:bertos/drv/ser.h ****  * This program is distributed in the hope that it will be useful,
  12:bertos/drv/ser.h ****  * but WITHOUT ANY WARRANTY; without even the implied warranty of
  13:bertos/drv/ser.h ****  * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
  14:bertos/drv/ser.h ****  * GNU General Public License for more details.
  15:bertos/drv/ser.h ****  *
  16:bertos/drv/ser.h ****  * You should have received a copy of the GNU General Public License
  17:bertos/drv/ser.h ****  * along with this program; if not, write to the Free Software
  18:bertos/drv/ser.h ****  * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
  19:bertos/drv/ser.h ****  *
  20:bertos/drv/ser.h ****  * As a special exception, you may use this file as part of a free software
  21:bertos/drv/ser.h ****  * library without restriction.  Specifically, if other files instantiate
  22:bertos/drv/ser.h ****  * templates or use macros or inline functions from this file, or you compile
  23:bertos/drv/ser.h ****  * this file and link it with other files to produce an executable, this
  24:bertos/drv/ser.h ****  * file does not by itself cause the resulting executable to be covered by
  25:bertos/drv/ser.h ****  * the GNU General Public License.  This exception does not however
  26:bertos/drv/ser.h ****  * invalidate any other reasons why the executable file might be covered by
  27:bertos/drv/ser.h ****  * the GNU General Public License.
  28:bertos/drv/ser.h ****  *
  29:bertos/drv/ser.h ****  * Copyright 2003,2004 Develer S.r.l. (http://www.develer.com/)
  30:bertos/drv/ser.h ****  * Copyright 2000 Bernie Innocenti <bernie@codewiz.org>
  31:bertos/drv/ser.h ****  *
  32:bertos/drv/ser.h ****  * -->
  33:bertos/drv/ser.h ****  *
  34:bertos/drv/ser.h ****  * \brief High level serial I/O API.
  35:bertos/drv/ser.h ****  *
  36:bertos/drv/ser.h ****  * \version $Id: ser.h 3341 2010-03-31 10:46:41Z duplo $
  37:bertos/drv/ser.h ****  * \author Bernie Innocenti <bernie@codewiz.org>
  38:bertos/drv/ser.h ****  *
  39:bertos/drv/ser.h ****  * $WIZ$ module_name = "ser"
  40:bertos/drv/ser.h ****  * $WIZ$ module_depends = "kfile", "timer"
  41:bertos/drv/ser.h ****  * $WIZ$ module_configuration = "bertos/cfg/cfg_ser.h"
  42:bertos/drv/ser.h ****  * $WIZ$ module_hw = "bertos/hw/hw_ser.h"
  43:bertos/drv/ser.h ****  * $WIZ$ module_supports =  "not atmega103 and not atmega32 and not atmega8"
  44:bertos/drv/ser.h ****  */
  45:bertos/drv/ser.h **** 
  46:bertos/drv/ser.h **** #ifndef DRV_SER_H
  47:bertos/drv/ser.h **** #define DRV_SER_H
  48:bertos/drv/ser.h **** 
  49:bertos/drv/ser.h **** #include <kern/kfile.h>
  50:bertos/drv/ser.h **** #include <struct/fifobuf.h>
  51:bertos/drv/ser.h **** #include <cfg/compiler.h>
  52:bertos/drv/ser.h **** 
  53:bertos/drv/ser.h **** #if OS_HOSTED
  54:bertos/drv/ser.h **** 	#include <cfg/macros.h> /* BV() */
  55:bertos/drv/ser.h **** 
  56:bertos/drv/ser.h **** 	typedef uint16_t serstatus_t;
  57:bertos/drv/ser.h **** 
  58:bertos/drv/ser.h **** 	/* Software errors */
  59:bertos/drv/ser.h **** 	#define SERRF_RXFIFOOVERRUN  BV(0)  /**< Rx FIFO buffer overrun */
  60:bertos/drv/ser.h **** 	#define SERRF_RXTIMEOUT      BV(1)  /**< Receive timeout */
  61:bertos/drv/ser.h **** 	#define SERRF_TXTIMEOUT      BV(2)  /**< Transmit timeout */
  62:bertos/drv/ser.h **** 
  63:bertos/drv/ser.h **** 	/* Hardware errors */
  64:bertos/drv/ser.h **** 	#define SERRF_RXSROVERRUN    0      /**< Rx shift register overrun, unsupported in emulated serial
  65:bertos/drv/ser.h **** 	#define SERRF_FRAMEERROR     0      /**< Stop bit missing, unsupported in emulated serial port. */
  66:bertos/drv/ser.h **** 	#define SERRF_PARITYERROR    0      /**< Parity error, unsupported in emulated serial port. */
  67:bertos/drv/ser.h **** 	#define SERRF_NOISEERROR     0      /**< Noise error, unsupported in emulated serial port. */
  68:bertos/drv/ser.h **** 
  69:bertos/drv/ser.h **** 	enum
  70:bertos/drv/ser.h **** 	{
  71:bertos/drv/ser.h **** 		SER_UART0,
  72:bertos/drv/ser.h **** 		SER_UART1,
  73:bertos/drv/ser.h **** 
  74:bertos/drv/ser.h **** 		SER_CNT  /**< Number of serial ports */
  75:bertos/drv/ser.h **** 	};
  76:bertos/drv/ser.h **** 
  77:bertos/drv/ser.h **** #else
  78:bertos/drv/ser.h **** 	#include CPU_HEADER(ser)
  79:bertos/drv/ser.h **** #endif
  80:bertos/drv/ser.h **** 
  81:bertos/drv/ser.h **** #include "cfg/cfg_ser.h"
  82:bertos/drv/ser.h **** 
  83:bertos/drv/ser.h **** 
  84:bertos/drv/ser.h **** 
  85:bertos/drv/ser.h **** /**
  86:bertos/drv/ser.h ****  * \name Masks to group TX/RX errors.
  87:bertos/drv/ser.h ****  * \{
  88:bertos/drv/ser.h ****  */
  89:bertos/drv/ser.h **** #define SERRF_RX \
  90:bertos/drv/ser.h **** 	( SERRF_RXFIFOOVERRUN \
  91:bertos/drv/ser.h **** 	| SERRF_RXTIMEOUT \
  92:bertos/drv/ser.h **** 	| SERRF_RXSROVERRUN \
  93:bertos/drv/ser.h **** 	| SERRF_PARITYERROR \
  94:bertos/drv/ser.h **** 	| SERRF_FRAMEERROR \
  95:bertos/drv/ser.h **** 	| SERRF_NOISEERROR)       /**< All possible rx errors */
  96:bertos/drv/ser.h **** #define SERRF_TX  (SERRF_TXTIMEOUT)  /**< All possible tx errors */
  97:bertos/drv/ser.h **** /*\}*/
  98:bertos/drv/ser.h **** 
  99:bertos/drv/ser.h **** /**
 100:bertos/drv/ser.h ****  * \name LSB or MSB first data order for SPI driver.
 101:bertos/drv/ser.h ****  *
 102:bertos/drv/ser.h ****  * $WIZ$ ser_order_bit = "SER_MSB_FIRST", "SER_LSB_FIRST"
 103:bertos/drv/ser.h ****  */
 104:bertos/drv/ser.h **** #define SER_MSB_FIRST 0
 105:bertos/drv/ser.h **** #define SER_LSB_FIRST 1
 106:bertos/drv/ser.h **** 
 107:bertos/drv/ser.h **** /**
 108:bertos/drv/ser.h ****  * \name Parity settings for ser_setparity().
 109:bertos/drv/ser.h ****  *
 110:bertos/drv/ser.h ****  * \note Values are AVR-specific for performance reasons.
 111:bertos/drv/ser.h ****  *       Other processors should either decode them or
 112:bertos/drv/ser.h ****  *       redefine these macros.
 113:bertos/drv/ser.h ****  * \{
 114:bertos/drv/ser.h ****  */
 115:bertos/drv/ser.h **** #define SER_PARITY_NONE  0
 116:bertos/drv/ser.h **** #define SER_PARITY_EVEN  2
 117:bertos/drv/ser.h **** #define SER_PARITY_ODD   3
 118:bertos/drv/ser.h **** /*\}*/
 119:bertos/drv/ser.h **** 
 120:bertos/drv/ser.h **** 
 121:bertos/drv/ser.h **** /**
 122:bertos/drv/ser.h ****  * \def CONFIG_SER_STROBE
 123:bertos/drv/ser.h ****  *
 124:bertos/drv/ser.h ****  * This is a debug facility that can be used to
 125:bertos/drv/ser.h ****  * monitor SER interrupt activity on an external pin.
 126:bertos/drv/ser.h ****  *
 127:bertos/drv/ser.h ****  * To use strobes, redefine the macros SER_STROBE_ON,
 128:bertos/drv/ser.h ****  * SER_STROBE_OFF and SER_STROBE_INIT and set
 129:bertos/drv/ser.h ****  * CONFIG_SER_STROBE to 1.
 130:bertos/drv/ser.h ****  */
 131:bertos/drv/ser.h **** #if !defined(CONFIG_SER_STROBE) || !CONFIG_SER_STROBE
 132:bertos/drv/ser.h **** 	#define SER_STROBE_ON    do {/*nop*/} while(0)
 133:bertos/drv/ser.h **** 	#define SER_STROBE_OFF   do {/*nop*/} while(0)
 134:bertos/drv/ser.h **** 	#define SER_STROBE_INIT  do {/*nop*/} while(0)
 135:bertos/drv/ser.h **** #endif
 136:bertos/drv/ser.h **** 
 137:bertos/drv/ser.h **** struct SerialHardware;
 138:bertos/drv/ser.h **** 
 139:bertos/drv/ser.h **** /** Human-readable serial error descriptions */
 140:bertos/drv/ser.h **** extern const char * const serial_errors[8];
 141:bertos/drv/ser.h **** 
 142:bertos/drv/ser.h **** /** Serial handle structure */
 143:bertos/drv/ser.h **** typedef struct Serial
 144:bertos/drv/ser.h **** {
 145:bertos/drv/ser.h **** 	/** Serial have a KFile struct implementation **/
 146:bertos/drv/ser.h **** 	KFile fd;
 147:bertos/drv/ser.h **** 
 148:bertos/drv/ser.h **** 	/** Physical port number */
 149:bertos/drv/ser.h **** 	unsigned int unit;
 150:bertos/drv/ser.h **** 
 151:bertos/drv/ser.h **** #ifdef _DEBUG
 152:bertos/drv/ser.h **** 	bool is_open;
 153:bertos/drv/ser.h **** #endif
 154:bertos/drv/ser.h **** 
 155:bertos/drv/ser.h **** 	/**
 156:bertos/drv/ser.h **** 	 * \name Transmit and receive FIFOs.
 157:bertos/drv/ser.h **** 	 *
 158:bertos/drv/ser.h **** 	 * Declared volatile because handled asinchronously by interrupts.
 159:bertos/drv/ser.h **** 	 *
 160:bertos/drv/ser.h **** 	 * \{
 161:bertos/drv/ser.h **** 	 */
 162:bertos/drv/ser.h **** 	FIFOBuffer txfifo;
 163:bertos/drv/ser.h **** 	FIFOBuffer rxfifo;
 164:bertos/drv/ser.h **** 	/* \} */
 165:bertos/drv/ser.h **** 
 166:bertos/drv/ser.h **** #if CONFIG_SER_RXTIMEOUT != -1
 167:bertos/drv/ser.h **** 	ticks_t rxtimeout;
 168:bertos/drv/ser.h **** #endif
 169:bertos/drv/ser.h **** #if CONFIG_SER_TXTIMEOUT != -1
 170:bertos/drv/ser.h **** 	ticks_t txtimeout;
 171:bertos/drv/ser.h **** #endif
 172:bertos/drv/ser.h **** 
 173:bertos/drv/ser.h **** 	/** Holds the flags defined above.  Will be 0 when no errors have occurred. */
 174:bertos/drv/ser.h **** 	volatile serstatus_t status;
 175:bertos/drv/ser.h **** 
 176:bertos/drv/ser.h **** 	/** Low-level interface to hardware. */
 177:bertos/drv/ser.h **** 	struct SerialHardware* hw;
 178:bertos/drv/ser.h **** } Serial;
 179:bertos/drv/ser.h **** 
 180:bertos/drv/ser.h **** 
 181:bertos/drv/ser.h **** /**
 182:bertos/drv/ser.h ****  * ID for serial.
 183:bertos/drv/ser.h ****  */
 184:bertos/drv/ser.h **** #define KFT_SERIAL MAKE_ID('S', 'E', 'R', 'L')
 185:bertos/drv/ser.h **** 
 186:bertos/drv/ser.h **** 
 187:bertos/drv/ser.h **** INLINE Serial * SERIAL_CAST(KFile *fd)
 188:bertos/drv/ser.h **** {
 189:bertos/drv/ser.h **** 	ASSERT(fd->_type == KFT_SERIAL);
 399               		.loc 3 189 0
 400 0018 FC01      		movw r30,r24	 ;  92	*movhi/1	[length = 1]
 401 001a 8089      		ldd r24,Z+16	 ;  31	*movsi/3	[length = 4]
 402 001c 9189      		ldd r25,Z+17
 403 001e A289      		ldd r26,Z+18
 404 0020 B389      		ldd r27,Z+19
 405               	.LVL25:
 406 0022 8C34      		cpi r24,lo8(1397051980)	 ;  32	*cmpsi/4	[length = 7]
 407 0024 F2E5      		ldi r31,hi8(1397051980)
 408 0026 9F07      		cpc r25,r31
 409 0028 F5E4      		ldi r31,hlo8(1397051980)
 410 002a AF07      		cpc r26,r31
 411 002c F3E5      		ldi r31,hhi8(1397051980)
 412 002e BF07      		cpc r27,r31
 413 0030 01F0      		breq .L31	 ;  33	branch	[length = 1]
 414               	.LVL26:
 415 0032 80E0      		ldi r24,lo8(__c.1642)	 ;  38	*movhi/4	[length = 2]
 416 0034 90E0      		ldi r25,hi8(__c.1642)
 417 0036 60E0      		ldi r22,lo8(__c.1644)	 ;  39	*movhi/4	[length = 2]
 418 0038 70E0      		ldi r23,hi8(__c.1644)
 419               	.LVL27:
 420 003a 4DEB      		ldi r20,lo8(189)	 ;  40	*movhi/4	[length = 2]
 421 003c 50E0      		ldi r21,hi8(189)
 422 003e 0E94 0000 		call __bassert_P	 ;  41	call_value_insn/3	[length = 2]
 423               	.LVL28:
 424               	.L31:
 425               		.loc 3 189 0 is_stmt 0 discriminator 1
 426 0042 0D2F      		mov r16,r29	 ;  83	*movqi/1	[length = 1]
 427 0044 1C2F      		mov r17,r28	 ;  84	*movqi/1	[length = 1]
 428               	.LBE159:
 429               	.LBE158:
 430               		.loc 1 201 0 is_stmt 1 discriminator 1
 431 0046 C0E0      		ldi r28,lo8(0)	 ;  27	*movhi/4	[length = 2]
 432 0048 D0E0      		ldi r29,hi8(0)
 433 004a 00C0      		rjmp .L32	 ;  118	jump	[length = 1]
 434               	.LVL29:
 435               	.L34:
 202:bertos/drv/ser.c **** 	Serial *fds = SERIAL_CAST(fd);
 203:bertos/drv/ser.c **** 
 204:bertos/drv/ser.c **** 	size_t i = 0;
 205:bertos/drv/ser.c **** 	char *buf = (char *)_buf;
 206:bertos/drv/ser.c **** 	int c;
 207:bertos/drv/ser.c **** 
 208:bertos/drv/ser.c **** 	while (i < size)
 209:bertos/drv/ser.c **** 	{
 210:bertos/drv/ser.c **** 		if ((c = ser_getchar(fds)) == EOF)
 436               		.loc 1 210 0
 437 004c C701      		movw r24,r14	 ;  49	*movhi/1	[length = 1]
 438 004e 0E94 0000 		call ser_getchar	 ;  50	call_value_insn/3	[length = 2]
 439               	.LVL30:
 440 0052 2FEF      		ldi r18,hi8(-1)	 ;  53	*cmphi/5	[length = 3]
 441 0054 8F3F      		cpi r24,lo8(-1)
 442 0056 9207      		cpc r25,r18
 443 0058 01F0      		breq .L33	 ;  54	branch	[length = 1]
 211:bertos/drv/ser.c **** 			break;
 212:bertos/drv/ser.c **** 		buf[i++] = c;
 444               		.loc 1 212 0
 445 005a F801      		movw r30,r16	 ;  93	*movhi/1	[length = 1]
 446 005c 8193      		st Z+,r24	 ;  56	*movqi/3	[length = 1]
 447 005e 8F01      		movw r16,r30	 ;  94	*movhi/1	[length = 1]
 448 0060 2196      		adiw r28,1	 ;  58	*addhi3/2	[length = 1]
 449               	.LVL31:
 450               	.L32:
 208:bertos/drv/ser.c **** 	while (i < size)
 451               		.loc 1 208 0 discriminator 1
 452 0062 CC15      		cp r28,r12	 ;  64	*cmphi/3	[length = 2]
 453 0064 DD05      		cpc r29,r13
 454 0066 01F4      		brne .L34	 ;  65	branch	[length = 1]
 455               	.L33:
 213:bertos/drv/ser.c **** 	}
 214:bertos/drv/ser.c **** 
 215:bertos/drv/ser.c **** 	return i;
 216:bertos/drv/ser.c **** }
 456               		.loc 1 216 0
 457 0068 CE01      		movw r24,r28	 ;  117	*movhi/1	[length = 1]
 458               	/* epilogue start */
 459 006a DF91      		pop r29	 ;  107	popqi	[length = 1]
 460 006c CF91      		pop r28	 ;  108	popqi	[length = 1]
 461               	.LVL32:
 462 006e 1F91      		pop r17	 ;  109	popqi	[length = 1]
 463 0070 0F91      		pop r16	 ;  110	popqi	[length = 1]
 464 0072 FF90      		pop r15	 ;  111	popqi	[length = 1]
 465 0074 EF90      		pop r14	 ;  112	popqi	[length = 1]
 466               	.LVL33:
 467 0076 DF90      		pop r13	 ;  113	popqi	[length = 1]
 468 0078 CF90      		pop r12	 ;  114	popqi	[length = 1]
 469               	.LVL34:
 470 007a 0895      		ret	 ;  115	return_from_epilogue	[length = 1]
 471               		.cfi_endproc
 472               	.LFE52:
 474               		.section	.text.ser_write,"ax",@progbits
 476               	ser_write:
 477               	.LFB53:
 217:bertos/drv/ser.c **** 
 218:bertos/drv/ser.c **** /**
 219:bertos/drv/ser.c ****  * \brief Write a buffer to serial.
 220:bertos/drv/ser.c ****  *
 221:bertos/drv/ser.c ****  * \return 0 if OK, EOF in case of error.
 222:bertos/drv/ser.c ****  *
 223:bertos/drv/ser.c ****  * \todo Optimize with fifo_pushblock()
 224:bertos/drv/ser.c ****  */
 225:bertos/drv/ser.c **** static size_t ser_write(struct KFile *fd, const void *_buf, size_t size)
 226:bertos/drv/ser.c **** {
 478               		.loc 1 226 0
 479               		.cfi_startproc
 480               	.LVL35:
 481 0000 CF92      		push r12	 ;  81	*pushqi/1	[length = 1]
 482               	.LCFI9:
 483               		.cfi_def_cfa_offset 3
 484               		.cfi_offset 12, -2
 485 0002 DF92      		push r13	 ;  82	*pushqi/1	[length = 1]
 486               	.LCFI10:
 487               		.cfi_def_cfa_offset 4
 488               		.cfi_offset 13, -3
 489 0004 EF92      		push r14	 ;  83	*pushqi/1	[length = 1]
 490               	.LCFI11:
 491               		.cfi_def_cfa_offset 5
 492               		.cfi_offset 14, -4
 493 0006 FF92      		push r15	 ;  84	*pushqi/1	[length = 1]
 494               	.LCFI12:
 495               		.cfi_def_cfa_offset 6
 496               		.cfi_offset 15, -5
 497 0008 0F93      		push r16	 ;  85	*pushqi/1	[length = 1]
 498               	.LCFI13:
 499               		.cfi_def_cfa_offset 7
 500               		.cfi_offset 16, -6
 501 000a 1F93      		push r17	 ;  86	*pushqi/1	[length = 1]
 502               	.LCFI14:
 503               		.cfi_def_cfa_offset 8
 504               		.cfi_offset 17, -7
 505 000c CF93      		push r28	 ;  87	*pushqi/1	[length = 1]
 506               	.LCFI15:
 507               		.cfi_def_cfa_offset 9
 508               		.cfi_offset 28, -8
 509 000e DF93      		push r29	 ;  88	*pushqi/1	[length = 1]
 510               	.LCFI16:
 511               		.cfi_def_cfa_offset 10
 512               		.cfi_offset 29, -9
 513               	/* prologue: function */
 514               	/* frame size = 0 */
 515               	/* stack size = 8 */
 516               	.L__stack_usage = 8
 517 0010 7C01      		movw r14,r24	 ;  2	*movhi/1	[length = 1]
 518 0012 EB01      		movw r28,r22	 ;  103	*movhi/1	[length = 1]
 519 0014 6A01      		movw r12,r20	 ;  4	*movhi/1	[length = 1]
 520               	.LVL36:
 521               	.LBB160:
 522               	.LBB161:
 523               		.loc 3 189 0
 524 0016 FC01      		movw r30,r24	 ;  76	*movhi/1	[length = 1]
 525 0018 8089      		ldd r24,Z+16	 ;  10	*movsi/3	[length = 4]
 526 001a 9189      		ldd r25,Z+17
 527 001c A289      		ldd r26,Z+18
 528 001e B389      		ldd r27,Z+19
 529               	.LVL37:
 530 0020 8C34      		cpi r24,lo8(1397051980)	 ;  11	*cmpsi/4	[length = 7]
 531 0022 F2E5      		ldi r31,hi8(1397051980)
 532 0024 9F07      		cpc r25,r31
 533 0026 F5E4      		ldi r31,hlo8(1397051980)
 534 0028 AF07      		cpc r26,r31
 535 002a F3E5      		ldi r31,hhi8(1397051980)
 536 002c BF07      		cpc r27,r31
 537 002e 01F0      		breq .L36	 ;  12	branch	[length = 1]
 538               	.LVL38:
 539 0030 80E0      		ldi r24,lo8(__c.1642)	 ;  17	*movhi/4	[length = 2]
 540 0032 90E0      		ldi r25,hi8(__c.1642)
 541 0034 60E0      		ldi r22,lo8(__c.1644)	 ;  18	*movhi/4	[length = 2]
 542 0036 70E0      		ldi r23,hi8(__c.1644)
 543               	.LVL39:
 544 0038 4DEB      		ldi r20,lo8(189)	 ;  19	*movhi/4	[length = 2]
 545 003a 50E0      		ldi r21,hi8(189)
 546 003c 0E94 0000 		call __bassert_P	 ;  20	call_value_insn/3	[length = 2]
 547               	.LVL40:
 548               	.L36:
 549               		.loc 3 189 0 is_stmt 0 discriminator 1
 550 0040 8E01      		movw r16,r28	 ;  102	*movhi/1	[length = 1]
 551               	.LBE161:
 552               	.LBE160:
 553               		.loc 1 226 0 is_stmt 1 discriminator 1
 554 0042 C0E0      		ldi r28,lo8(0)	 ;  6	*movhi/4	[length = 2]
 555 0044 D0E0      		ldi r29,hi8(0)
 556               	.LVL41:
 557 0046 00C0      		rjmp .L37	 ;  104	jump	[length = 1]
 558               	.LVL42:
 559               	.L39:
 227:bertos/drv/ser.c **** 	Serial *fds = SERIAL_CAST(fd);
 228:bertos/drv/ser.c **** 	const char *buf = (const char *)_buf;
 229:bertos/drv/ser.c **** 	size_t i = 0;
 230:bertos/drv/ser.c **** 
 231:bertos/drv/ser.c **** 	while (size--)
 232:bertos/drv/ser.c **** 	{
 233:bertos/drv/ser.c **** 		if (ser_putchar(*buf++, fds) == EOF)
 560               		.loc 1 233 0
 561 0048 F801      		movw r30,r16	 ;  77	*movhi/1	[length = 1]
 562 004a 8191      		ld r24,Z+	 ;  27	*movqi/4	[length = 1]
 563 004c 8F01      		movw r16,r30	 ;  78	*movhi/1	[length = 1]
 564 004e 9927      		clr r25	 ;  32	extendqihi2/1	[length = 3]
 565 0050 87FD      		sbrc r24,7
 566 0052 9095      		com r25
 567 0054 B701      		movw r22,r14	 ;  33	*movhi/1	[length = 1]
 568 0056 0E94 0000 		call ser_putchar	 ;  34	call_value_insn/3	[length = 2]
 569 005a FFEF      		ldi r31,hi8(-1)	 ;  36	*cmphi/5	[length = 3]
 570 005c 8F3F      		cpi r24,lo8(-1)
 571 005e 9F07      		cpc r25,r31
 572 0060 01F0      		breq .L38	 ;  37	branch	[length = 1]
 234:bertos/drv/ser.c **** 			break;
 235:bertos/drv/ser.c **** 		i++;
 573               		.loc 1 235 0
 574 0062 2196      		adiw r28,1	 ;  39	*addhi3/2	[length = 1]
 575               	.LVL43:
 576               	.L37:
 231:bertos/drv/ser.c **** 	while (size--)
 577               		.loc 1 231 0 discriminator 1
 578 0064 CC15      		cp r28,r12	 ;  48	*cmphi/3	[length = 2]
 579 0066 DD05      		cpc r29,r13
 580 0068 01F4      		brne .L39	 ;  49	branch	[length = 1]
 581               	.L38:
 236:bertos/drv/ser.c **** 	}
 237:bertos/drv/ser.c **** 	return i;
 238:bertos/drv/ser.c **** }
 582               		.loc 1 238 0
 583 006a CE01      		movw r24,r28	 ;  101	*movhi/1	[length = 1]
 584               	/* epilogue start */
 585 006c DF91      		pop r29	 ;  91	popqi	[length = 1]
 586 006e CF91      		pop r28	 ;  92	popqi	[length = 1]
 587               	.LVL44:
 588 0070 1F91      		pop r17	 ;  93	popqi	[length = 1]
 589 0072 0F91      		pop r16	 ;  94	popqi	[length = 1]
 590 0074 FF90      		pop r15	 ;  95	popqi	[length = 1]
 591 0076 EF90      		pop r14	 ;  96	popqi	[length = 1]
 592               	.LVL45:
 593 0078 DF90      		pop r13	 ;  97	popqi	[length = 1]
 594 007a CF90      		pop r12	 ;  98	popqi	[length = 1]
 595 007c 0895      		ret	 ;  99	return_from_epilogue	[length = 1]
 596               		.cfi_endproc
 597               	.LFE53:
 599               		.section	.text.ser_error,"ax",@progbits
 601               	ser_error:
 602               	.LFB56:
 239:bertos/drv/ser.c **** 
 240:bertos/drv/ser.c **** 
 241:bertos/drv/ser.c **** #if CONFIG_SER_RXTIMEOUT != -1 || CONFIG_SER_TXTIMEOUT != -1
 242:bertos/drv/ser.c **** void ser_settimeouts(struct Serial *fd, mtime_t rxtimeout, mtime_t txtimeout)
 243:bertos/drv/ser.c **** {
 244:bertos/drv/ser.c **** 	#if CONFIG_SER_RXTIMEOUT != -1
 245:bertos/drv/ser.c **** 		fd->rxtimeout = ms_to_ticks(rxtimeout);
 246:bertos/drv/ser.c **** 	#else
 247:bertos/drv/ser.c **** 		(void)rxtimeout;
 248:bertos/drv/ser.c **** 	#endif
 249:bertos/drv/ser.c **** 
 250:bertos/drv/ser.c **** 	#if CONFIG_SER_TXTIMEOUT != -1
 251:bertos/drv/ser.c **** 		fd->txtimeout = ms_to_ticks(txtimeout);
 252:bertos/drv/ser.c **** 	#else
 253:bertos/drv/ser.c **** 		(void)txtimeout;
 254:bertos/drv/ser.c **** 	#endif
 255:bertos/drv/ser.c **** }
 256:bertos/drv/ser.c **** #endif /* CONFIG_SER_RXTIMEOUT || CONFIG_SER_TXTIMEOUT */
 257:bertos/drv/ser.c **** 
 258:bertos/drv/ser.c **** 
 259:bertos/drv/ser.c **** /**
 260:bertos/drv/ser.c ****  * Set the baudrate for the serial port
 261:bertos/drv/ser.c ****  */
 262:bertos/drv/ser.c **** void ser_setbaudrate(struct Serial *fd, unsigned long rate)
 263:bertos/drv/ser.c **** {
 264:bertos/drv/ser.c **** 	fd->hw->table->setBaudrate(fd->hw, rate);
 265:bertos/drv/ser.c **** }
 266:bertos/drv/ser.c **** 
 267:bertos/drv/ser.c **** 
 268:bertos/drv/ser.c **** /**
 269:bertos/drv/ser.c ****  * Set the parity for the \a fd serial port
 270:bertos/drv/ser.c ****  */
 271:bertos/drv/ser.c **** void ser_setparity(struct Serial *fd, int parity)
 272:bertos/drv/ser.c **** {
 273:bertos/drv/ser.c **** 	fd->hw->table->setParity(fd->hw, parity);
 274:bertos/drv/ser.c **** }
 275:bertos/drv/ser.c **** 
 276:bertos/drv/ser.c **** static int ser_error(struct KFile *fd)
 277:bertos/drv/ser.c **** {
 603               		.loc 1 277 0
 604               		.cfi_startproc
 605               	.LVL46:
 606 0000 CF93      		push r28	 ;  41	*pushqi/1	[length = 1]
 607               	.LCFI17:
 608               		.cfi_def_cfa_offset 3
 609               		.cfi_offset 28, -2
 610 0002 DF93      		push r29	 ;  42	*pushqi/1	[length = 1]
 611               	.LCFI18:
 612               		.cfi_def_cfa_offset 4
 613               		.cfi_offset 29, -3
 614               	/* prologue: function */
 615               	/* frame size = 0 */
 616               	/* stack size = 2 */
 617               	.L__stack_usage = 2
 618 0004 EC01      		movw r28,r24	 ;  2	*movhi/1	[length = 1]
 619               	.LVL47:
 620               	.LBB162:
 621               	.LBB163:
 622               		.loc 3 189 0
 623 0006 8889      		ldd r24,Y+16	 ;  7	*movsi/3	[length = 4]
 624 0008 9989      		ldd r25,Y+17
 625 000a AA89      		ldd r26,Y+18
 626 000c BB89      		ldd r27,Y+19
 627               	.LVL48:
 628 000e 8C34      		cpi r24,lo8(1397051980)	 ;  8	*cmpsi/4	[length = 7]
 629 0010 22E5      		ldi r18,hi8(1397051980)
 630 0012 9207      		cpc r25,r18
 631 0014 25E4      		ldi r18,hlo8(1397051980)
 632 0016 A207      		cpc r26,r18
 633 0018 23E5      		ldi r18,hhi8(1397051980)
 634 001a B207      		cpc r27,r18
 635 001c 01F0      		breq .L41	 ;  9	branch	[length = 1]
 636 001e 80E0      		ldi r24,lo8(__c.1642)	 ;  14	*movhi/4	[length = 2]
 637 0020 90E0      		ldi r25,hi8(__c.1642)
 638 0022 60E0      		ldi r22,lo8(__c.1644)	 ;  15	*movhi/4	[length = 2]
 639 0024 70E0      		ldi r23,hi8(__c.1644)
 640 0026 4DEB      		ldi r20,lo8(189)	 ;  16	*movhi/4	[length = 2]
 641 0028 50E0      		ldi r21,hi8(189)
 642 002a 0E94 0000 		call __bassert_P	 ;  17	call_value_insn/3	[length = 2]
 643               	.L41:
 644               	.LBE163:
 645               	.LBE162:
 278:bertos/drv/ser.c **** 	Serial *fds = SERIAL_CAST(fd);
 279:bertos/drv/ser.c **** 	return ser_getstatus(fds);
 646               		.loc 1 279 0
 647 002e 8FA5      		ldd r24,Y+47	 ;  21	*movqi/4	[length = 1]
 280:bertos/drv/ser.c **** }
 648               		.loc 1 280 0
 649 0030 90E0      		ldi r25,lo8(0)	 ;  39	*movqi/2	[length = 1]
 650               	/* epilogue start */
 651 0032 DF91      		pop r29	 ;  45	popqi	[length = 1]
 652 0034 CF91      		pop r28	 ;  46	popqi	[length = 1]
 653               	.LVL49:
 654 0036 0895      		ret	 ;  47	return_from_epilogue	[length = 1]
 655               		.cfi_endproc
 656               	.LFE56:
 658               		.section	.text.ser_clearerr,"ax",@progbits
 660               	ser_clearerr:
 661               	.LFB57:
 281:bertos/drv/ser.c **** 
 282:bertos/drv/ser.c **** static void ser_clearerr(struct KFile *fd)
 283:bertos/drv/ser.c **** {
 662               		.loc 1 283 0
 663               		.cfi_startproc
 664               	.LVL50:
 665 0000 CF93      		push r28	 ;  26	*pushqi/1	[length = 1]
 666               	.LCFI19:
 667               		.cfi_def_cfa_offset 3
 668               		.cfi_offset 28, -2
 669 0002 DF93      		push r29	 ;  27	*pushqi/1	[length = 1]
 670               	.LCFI20:
 671               		.cfi_def_cfa_offset 4
 672               		.cfi_offset 29, -3
 673               	/* prologue: function */
 674               	/* frame size = 0 */
 675               	/* stack size = 2 */
 676               	.L__stack_usage = 2
 677 0004 EC01      		movw r28,r24	 ;  2	*movhi/1	[length = 1]
 678               	.LVL51:
 679               	.LBB164:
 680               	.LBB165:
 681               		.loc 3 189 0
 682 0006 8889      		ldd r24,Y+16	 ;  7	*movsi/3	[length = 4]
 683 0008 9989      		ldd r25,Y+17
 684 000a AA89      		ldd r26,Y+18
 685 000c BB89      		ldd r27,Y+19
 686               	.LVL52:
 687 000e 8C34      		cpi r24,lo8(1397051980)	 ;  8	*cmpsi/4	[length = 7]
 688 0010 22E5      		ldi r18,hi8(1397051980)
 689 0012 9207      		cpc r25,r18
 690 0014 25E4      		ldi r18,hlo8(1397051980)
 691 0016 A207      		cpc r26,r18
 692 0018 23E5      		ldi r18,hhi8(1397051980)
 693 001a B207      		cpc r27,r18
 694 001c 01F0      		breq .L43	 ;  9	branch	[length = 1]
 695 001e 80E0      		ldi r24,lo8(__c.1642)	 ;  14	*movhi/4	[length = 2]
 696 0020 90E0      		ldi r25,hi8(__c.1642)
 697 0022 60E0      		ldi r22,lo8(__c.1644)	 ;  15	*movhi/4	[length = 2]
 698 0024 70E0      		ldi r23,hi8(__c.1644)
 699 0026 4DEB      		ldi r20,lo8(189)	 ;  16	*movhi/4	[length = 2]
 700 0028 50E0      		ldi r21,hi8(189)
 701 002a 0E94 0000 		call __bassert_P	 ;  17	call_value_insn/3	[length = 2]
 702               	.LVL53:
 703               	.L43:
 704               	.LBE165:
 705               	.LBE164:
 284:bertos/drv/ser.c **** 	Serial *fds = SERIAL_CAST(fd);
 285:bertos/drv/ser.c **** 	ser_setstatus(fds, 0);
 706               		.loc 1 285 0
 707 002e 1FA6      		std Y+47,__zero_reg__	 ;  21	*movqi/3	[length = 1]
 708               	/* epilogue start */
 286:bertos/drv/ser.c **** }
 709               		.loc 1 286 0
 710 0030 DF91      		pop r29	 ;  30	popqi	[length = 1]
 711 0032 CF91      		pop r28	 ;  31	popqi	[length = 1]
 712               	.LVL54:
 713 0034 0895      		ret	 ;  32	return_from_epilogue	[length = 1]
 714               		.cfi_endproc
 715               	.LFE57:
 717               		.section	.text.ser_flush,"ax",@progbits
 719               	ser_flush:
 720               	.LFB61:
 287:bertos/drv/ser.c **** 
 288:bertos/drv/ser.c **** 
 289:bertos/drv/ser.c **** 
 290:bertos/drv/ser.c **** /**
 291:bertos/drv/ser.c ****  * Flush both the RX and TX buffers.
 292:bertos/drv/ser.c ****  */
 293:bertos/drv/ser.c **** void ser_purge(struct Serial *fd)
 294:bertos/drv/ser.c **** {
 295:bertos/drv/ser.c **** 	ser_purgeRx(fd);
 296:bertos/drv/ser.c **** 	ser_purgeTx(fd);
 297:bertos/drv/ser.c **** }
 298:bertos/drv/ser.c **** 
 299:bertos/drv/ser.c **** /**
 300:bertos/drv/ser.c ****  * Flush RX buffer.
 301:bertos/drv/ser.c ****  */
 302:bertos/drv/ser.c **** void ser_purgeRx(struct Serial *fd)
 303:bertos/drv/ser.c **** {
 304:bertos/drv/ser.c **** 	fifo_flush_locked(&fd->rxfifo);
 305:bertos/drv/ser.c **** }
 306:bertos/drv/ser.c **** 
 307:bertos/drv/ser.c **** /**
 308:bertos/drv/ser.c ****  * Flush TX buffer.
 309:bertos/drv/ser.c ****  */
 310:bertos/drv/ser.c **** void ser_purgeTx(struct Serial *fd)
 311:bertos/drv/ser.c **** {
 312:bertos/drv/ser.c **** 	fifo_flush_locked(&fd->txfifo);
 313:bertos/drv/ser.c **** }
 314:bertos/drv/ser.c **** 
 315:bertos/drv/ser.c **** 
 316:bertos/drv/ser.c **** /**
 317:bertos/drv/ser.c ****  * Wait until all pending output is completely
 318:bertos/drv/ser.c ****  * transmitted to the other end.
 319:bertos/drv/ser.c ****  *
 320:bertos/drv/ser.c ****  * \note The current implementation only checks the
 321:bertos/drv/ser.c ****  *       software transmission queue. Any hardware
 322:bertos/drv/ser.c ****  *       FIFOs are ignored.
 323:bertos/drv/ser.c ****  */
 324:bertos/drv/ser.c **** static int ser_flush(struct KFile *fd)
 325:bertos/drv/ser.c **** {
 721               		.loc 1 325 0
 722               		.cfi_startproc
 723               	.LVL55:
 724 0000 CF93      		push r28	 ;  63	*pushqi/1	[length = 1]
 725               	.LCFI21:
 726               		.cfi_def_cfa_offset 3
 727               		.cfi_offset 28, -2
 728 0002 DF93      		push r29	 ;  64	*pushqi/1	[length = 1]
 729               	.LCFI22:
 730               		.cfi_def_cfa_offset 4
 731               		.cfi_offset 29, -3
 732               	/* prologue: function */
 733               	/* frame size = 0 */
 734               	/* stack size = 2 */
 735               	.L__stack_usage = 2
 736 0004 EC01      		movw r28,r24	 ;  2	*movhi/1	[length = 1]
 737               	.LVL56:
 738               	.LBB166:
 739               	.LBB167:
 740               		.loc 3 189 0
 741 0006 8889      		ldd r24,Y+16	 ;  7	*movsi/3	[length = 4]
 742 0008 9989      		ldd r25,Y+17
 743 000a AA89      		ldd r26,Y+18
 744 000c BB89      		ldd r27,Y+19
 745               	.LVL57:
 746 000e 8C34      		cpi r24,lo8(1397051980)	 ;  8	*cmpsi/4	[length = 7]
 747 0010 22E5      		ldi r18,hi8(1397051980)
 748 0012 9207      		cpc r25,r18
 749 0014 25E4      		ldi r18,hlo8(1397051980)
 750 0016 A207      		cpc r26,r18
 751 0018 23E5      		ldi r18,hhi8(1397051980)
 752 001a B207      		cpc r27,r18
 753 001c 01F0      		breq .L51	 ;  9	branch	[length = 1]
 754 001e 80E0      		ldi r24,lo8(__c.1642)	 ;  14	*movhi/4	[length = 2]
 755 0020 90E0      		ldi r25,hi8(__c.1642)
 756 0022 60E0      		ldi r22,lo8(__c.1644)	 ;  15	*movhi/4	[length = 2]
 757 0024 70E0      		ldi r23,hi8(__c.1644)
 758 0026 4DEB      		ldi r20,lo8(189)	 ;  16	*movhi/4	[length = 2]
 759 0028 50E0      		ldi r21,hi8(189)
 760 002a 0E94 0000 		call __bassert_P	 ;  17	call_value_insn/3	[length = 2]
 761               	.LVL58:
 762               	.L51:
 763               	.LBE167:
 764               	.LBE166:
 765               	.LBB168:
 766               	.LBB169:
 105:bertos/struct/fifobuf.h **** 	return fb->head == fb->tail;
 767               		.loc 2 105 0 discriminator 1
 768 002e 2F8D      		ldd r18,Y+31	 ;  24	*movhi/2	[length = 2]
 769 0030 38A1      		ldd r19,Y+32
 770 0032 89A1      		ldd r24,Y+33	 ;  25	*movhi/2	[length = 2]
 771 0034 9AA1      		ldd r25,Y+34
 772               	.LBE169:
 773               	.LBE168:
 326:bertos/drv/ser.c **** 	Serial *fds = SERIAL_CAST(fd);
 327:bertos/drv/ser.c **** 
 328:bertos/drv/ser.c **** 	/*
 329:bertos/drv/ser.c **** 	 * Wait until the FIFO becomes empty, and then until the byte currently in
 330:bertos/drv/ser.c **** 	 * the hardware register gets shifted out.
 331:bertos/drv/ser.c **** 	 */
 332:bertos/drv/ser.c **** 	while (!fifo_isempty(&fds->txfifo)
 774               		.loc 1 332 0 discriminator 1
 775 0036 2817      		cp r18,r24	 ;  27	*cmphi/3	[length = 2]
 776 0038 3907      		cpc r19,r25
 777 003a 01F4      		brne .L51	 ;  28	branch	[length = 1]
 333:bertos/drv/ser.c **** 	       || fds->hw->table->txSending(fds->hw))
 778               		.loc 1 333 0
 779 003c 88A9      		ldd r24,Y+48	 ;  30	*movhi/2	[length = 2]
 780 003e 99A9      		ldd r25,Y+49
 781 0040 DC01      		movw r26,r24	 ;  62	*movhi/1	[length = 1]
 782 0042 ED91      		ld r30,X+	 ;  32	*movhi/2	[length = 2]
 783 0044 FC91      		ld r31,X
 784 0046 0284      		ldd __tmp_reg__,Z+10	 ;  33	*movhi/2	[length = 3]
 785 0048 F385      		ldd r31,Z+11
 786 004a E02D      		mov r30,__tmp_reg__
 787 004c 0995      		icall	 ;  35	call_value_insn/1	[length = 1]
 788 004e 8823      		tst r24	 ;  38	*cmpqi/1	[length = 1]
 789 0050 01F4      		brne .L51	 ;  39	branch	[length = 1]
 334:bertos/drv/ser.c **** 		cpu_relax();
 335:bertos/drv/ser.c **** 	return 0;
 336:bertos/drv/ser.c **** }
 790               		.loc 1 336 0
 791 0052 80E0      		ldi r24,lo8(0)	 ;  45	*movhi/4	[length = 2]
 792 0054 90E0      		ldi r25,hi8(0)
 793               	/* epilogue start */
 794 0056 DF91      		pop r29	 ;  67	popqi	[length = 1]
 795 0058 CF91      		pop r28	 ;  68	popqi	[length = 1]
 796               	.LVL59:
 797 005a 0895      		ret	 ;  69	return_from_epilogue	[length = 1]
 798               		.cfi_endproc
 799               	.LFE61:
 801               		.section	.text.ser_open,"ax",@progbits
 803               	ser_open:
 804               	.LFB62:
 337:bertos/drv/ser.c **** 
 338:bertos/drv/ser.c **** 
 339:bertos/drv/ser.c **** /**
 340:bertos/drv/ser.c ****  * Initialize a serial port.
 341:bertos/drv/ser.c ****  *
 342:bertos/drv/ser.c ****  * \param fd KFile Serial struct interface.
 343:bertos/drv/ser.c ****  * \param unit  Serial unit to open. Possible values are architecture dependant.
 344:bertos/drv/ser.c ****  */
 345:bertos/drv/ser.c **** static struct Serial *ser_open(struct Serial *fd, unsigned int unit)
 346:bertos/drv/ser.c **** {
 805               		.loc 1 346 0
 806               		.cfi_startproc
 807               	.LVL60:
 808 0000 EF92      		push r14	 ;  164	*pushqi/1	[length = 1]
 809               	.LCFI23:
 810               		.cfi_def_cfa_offset 3
 811               		.cfi_offset 14, -2
 812 0002 FF92      		push r15	 ;  165	*pushqi/1	[length = 1]
 813               	.LCFI24:
 814               		.cfi_def_cfa_offset 4
 815               		.cfi_offset 15, -3
 816 0004 0F93      		push r16	 ;  166	*pushqi/1	[length = 1]
 817               	.LCFI25:
 818               		.cfi_def_cfa_offset 5
 819               		.cfi_offset 16, -4
 820 0006 1F93      		push r17	 ;  167	*pushqi/1	[length = 1]
 821               	.LCFI26:
 822               		.cfi_def_cfa_offset 6
 823               		.cfi_offset 17, -5
 824 0008 CF93      		push r28	 ;  168	*pushqi/1	[length = 1]
 825               	.LCFI27:
 826               		.cfi_def_cfa_offset 7
 827               		.cfi_offset 28, -6
 828 000a DF93      		push r29	 ;  169	*pushqi/1	[length = 1]
 829               	.LCFI28:
 830               		.cfi_def_cfa_offset 8
 831               		.cfi_offset 29, -7
 832               	/* prologue: function */
 833               	/* frame size = 0 */
 834               	/* stack size = 6 */
 835               	.L__stack_usage = 6
 836 000c 8C01      		movw r16,r24	 ;  2	*movhi/1	[length = 1]
 837 000e EB01      		movw r28,r22	 ;  3	*movhi/1	[length = 1]
 347:bertos/drv/ser.c **** 	ASSERT(unit < countof(ser_handles));
 838               		.loc 1 347 0
 839 0010 6230      		cpi r22,2	 ;  7	*cmphi/4	[length = 2]
 840 0012 7105      		cpc r23,__zero_reg__
 841 0014 00F0      		brlo .L53	 ;  8	branch	[length = 1]
 842               	.LVL61:
 843               		.loc 1 347 0 is_stmt 0 discriminator 1
 844 0016 80E0      		ldi r24,lo8(__c.2050)	 ;  13	*movhi/4	[length = 2]
 845 0018 90E0      		ldi r25,hi8(__c.2050)
 846 001a 60E0      		ldi r22,lo8(__c.2052)	 ;  14	*movhi/4	[length = 2]
 847 001c 70E0      		ldi r23,hi8(__c.2052)
 848               	.LVL62:
 849 001e 4BE5      		ldi r20,lo8(347)	 ;  15	*movhi/4	[length = 2]
 850 0020 51E0      		ldi r21,hi8(347)
 851 0022 0E94 0000 		call __bassert_P	 ;  16	call_value_insn/3	[length = 2]
 852               	.L53:
 348:bertos/drv/ser.c **** 
 349:bertos/drv/ser.c **** 	ser_handles[unit] = fd;
 853               		.loc 1 349 0 is_stmt 1
 854 0026 FE01      		movw r30,r28	 ;  152	*movhi/1	[length = 1]
 855 0028 EE0F      		lsl r30	 ;  181	*ashlhi3_const/2	[length = 2]
 856 002a FF1F      		rol r31
 857 002c E050      		subi r30,lo8(-(ser_handles))	 ;  21	*addhi3/4	[length = 2]
 858 002e F040      		sbci r31,hi8(-(ser_handles))
 859 0030 1183      		std Z+1,r17	 ;  22	*movhi/3	[length = 2]
 860 0032 0083      		st Z,r16
 350:bertos/drv/ser.c **** 	ASSERT(!fd->is_open);
 861               		.loc 1 350 0
 862 0034 D801      		movw r26,r16	 ;  153	*movhi/1	[length = 1]
 863 0036 5E96      		adiw r26,30	 ;  23	*movqi/4	[length = 3]
 864 0038 8C91      		ld r24,X
 865 003a 5E97      		sbiw r26,30
 866 003c 8823      		tst r24	 ;  24	*cmpqi/1	[length = 1]
 867 003e 01F0      		breq .L54	 ;  25	branch	[length = 1]
 868               		.loc 1 350 0 is_stmt 0 discriminator 1
 869 0040 80E0      		ldi r24,lo8(__c.2054)	 ;  30	*movhi/4	[length = 2]
 870 0042 90E0      		ldi r25,hi8(__c.2054)
 871 0044 60E0      		ldi r22,lo8(__c.2056)	 ;  31	*movhi/4	[length = 2]
 872 0046 70E0      		ldi r23,hi8(__c.2056)
 873 0048 4EE5      		ldi r20,lo8(350)	 ;  32	*movhi/4	[length = 2]
 874 004a 51E0      		ldi r21,hi8(350)
 875 004c 0E94 0000 		call __bassert_P	 ;  33	call_value_insn/3	[length = 2]
 876               	.L54:
 351:bertos/drv/ser.c **** 	DB(fd->is_open = true);
 877               		.loc 1 351 0 is_stmt 1
 878 0050 81E0      		ldi r24,lo8(1)	 ;  36	*movqi/2	[length = 1]
 879 0052 F801      		movw r30,r16	 ;  154	*movhi/1	[length = 1]
 880 0054 868F      		std Z+30,r24	 ;  37	*movqi/3	[length = 1]
 352:bertos/drv/ser.c **** 
 353:bertos/drv/ser.c **** 	fd->unit = unit;
 881               		.loc 1 353 0
 882 0056 D58F      		std Z+29,r29	 ;  38	*movhi/3	[length = 2]
 883 0058 C48F      		std Z+28,r28
 354:bertos/drv/ser.c **** 
 355:bertos/drv/ser.c **** 	fd->hw = ser_hw_getdesc(unit);
 884               		.loc 1 355 0
 885 005a CE01      		movw r24,r28	 ;  40	*movhi/1	[length = 1]
 886 005c 0E94 0000 		call ser_hw_getdesc	 ;  41	call_value_insn/3	[length = 2]
 887 0060 D801      		movw r26,r16	 ;  155	*movhi/1	[length = 1]
 888 0062 D196      		adiw r26,48+1	 ;  43	*movhi/3	[length = 4]
 889 0064 9C93      		st X,r25
 890 0066 8E93      		st -X,r24
 891 0068 D097      		sbiw r26,48
 356:bertos/drv/ser.c **** 
 357:bertos/drv/ser.c **** 	/* Initialize circular buffers */
 358:bertos/drv/ser.c **** 	ASSERT(fd->hw->txbuffer);
 892               		.loc 1 358 0
 893 006a FC01      		movw r30,r24	 ;  156	*movhi/1	[length = 1]
 894 006c 8281      		ldd r24,Z+2	 ;  44	*movhi/2	[length = 2]
 895 006e 9381      		ldd r25,Z+3
 896 0070 0097      		sbiw r24,0	 ;  45	*cmphi/1	[length = 1]
 897 0072 01F4      		brne .L55	 ;  46	branch	[length = 1]
 898               		.loc 1 358 0 is_stmt 0 discriminator 1
 899 0074 80E0      		ldi r24,lo8(__c.2058)	 ;  51	*movhi/4	[length = 2]
 900 0076 90E0      		ldi r25,hi8(__c.2058)
 901 0078 60E0      		ldi r22,lo8(__c.2060)	 ;  52	*movhi/4	[length = 2]
 902 007a 70E0      		ldi r23,hi8(__c.2060)
 903 007c 46E6      		ldi r20,lo8(358)	 ;  53	*movhi/4	[length = 2]
 904 007e 51E0      		ldi r21,hi8(358)
 905 0080 0E94 0000 		call __bassert_P	 ;  54	call_value_insn/3	[length = 2]
 906               	.L55:
 359:bertos/drv/ser.c **** 	ASSERT(fd->hw->rxbuffer);
 907               		.loc 1 359 0 is_stmt 1
 908 0084 D801      		movw r26,r16	 ;  157	*movhi/1	[length = 1]
 909 0086 D096      		adiw r26,48	 ;  57	*movhi/2	[length = 4]
 910 0088 ED91      		ld r30,X+
 911 008a FC91      		ld r31,X
 912 008c D197      		sbiw r26,48+1
 913 008e 8481      		ldd r24,Z+4	 ;  58	*movhi/2	[length = 2]
 914 0090 9581      		ldd r25,Z+5
 915 0092 0097      		sbiw r24,0	 ;  59	*cmphi/1	[length = 1]
 916 0094 01F4      		brne .L56	 ;  60	branch	[length = 1]
 917               		.loc 1 359 0 is_stmt 0 discriminator 1
 918 0096 80E0      		ldi r24,lo8(__c.2062)	 ;  65	*movhi/4	[length = 2]
 919 0098 90E0      		ldi r25,hi8(__c.2062)
 920 009a 60E0      		ldi r22,lo8(__c.2064)	 ;  66	*movhi/4	[length = 2]
 921 009c 70E0      		ldi r23,hi8(__c.2064)
 922 009e 47E6      		ldi r20,lo8(359)	 ;  67	*movhi/4	[length = 2]
 923 00a0 51E0      		ldi r21,hi8(359)
 924 00a2 0E94 0000 		call __bassert_P	 ;  68	call_value_insn/3	[length = 2]
 925               	.L56:
 360:bertos/drv/ser.c **** 	fifo_init(&fd->txfifo, fd->hw->txbuffer, fd->hw->txbuffer_size);
 926               		.loc 1 360 0 is_stmt 1
 927 00a6 D801      		movw r26,r16	 ;  158	*movhi/1	[length = 1]
 928 00a8 D096      		adiw r26,48	 ;  72	*movhi/2	[length = 4]
 929 00aa ED91      		ld r30,X+
 930 00ac FC91      		ld r31,X
 931 00ae D197      		sbiw r26,48+1
 932 00b0 E280      		ldd r14,Z+2	 ;  73	*movhi/2	[length = 2]
 933 00b2 F380      		ldd r15,Z+3
 934 00b4 C681      		ldd r28,Z+6	 ;  74	*movhi/2	[length = 2]
 935 00b6 D781      		ldd r29,Z+7
 936               	.LVL63:
 937               	.LBB170:
 938               	.LBB171:
 276:bertos/struct/fifobuf.h **** 	return result;
 277:bertos/struct/fifobuf.h **** }
 278:bertos/struct/fifobuf.h **** 
 279:bertos/struct/fifobuf.h **** 
 280:bertos/struct/fifobuf.h **** /**
 281:bertos/struct/fifobuf.h ****  * FIFO Initialization.
 282:bertos/struct/fifobuf.h ****  */
 283:bertos/struct/fifobuf.h **** INLINE void fifo_init(FIFOBuffer *fb, unsigned char *buf, size_t size)
 284:bertos/struct/fifobuf.h **** {
 285:bertos/struct/fifobuf.h **** 	/* FIFO buffers have a known bug with 1-byte buffers. */
 286:bertos/struct/fifobuf.h **** 	ASSERT(size > 1);
 939               		.loc 2 286 0
 940 00b8 C230      		cpi r28,2	 ;  78	*cmphi/4	[length = 2]
 941 00ba D105      		cpc r29,__zero_reg__
 942 00bc 00F4      		brsh .L57	 ;  79	branch	[length = 1]
 943 00be 80E0      		ldi r24,lo8(__c.1616)	 ;  84	*movhi/4	[length = 2]
 944 00c0 90E0      		ldi r25,hi8(__c.1616)
 945 00c2 60E0      		ldi r22,lo8(__c.1618)	 ;  85	*movhi/4	[length = 2]
 946 00c4 70E0      		ldi r23,hi8(__c.1618)
 947 00c6 4EE1      		ldi r20,lo8(286)	 ;  86	*movhi/4	[length = 2]
 948 00c8 51E0      		ldi r21,hi8(286)
 949 00ca 0E94 0000 		call __bassert_P	 ;  87	call_value_insn/3	[length = 2]
 950               	.LVL64:
 951               	.L57:
 287:bertos/struct/fifobuf.h **** 
 288:bertos/struct/fifobuf.h **** 	fb->head = fb->tail = fb->begin = buf;
 952               		.loc 2 288 0
 953 00ce F801      		movw r30,r16	 ;  159	*movhi/1	[length = 1]
 954 00d0 F4A2      		std Z+36,r15	 ;  90	*movhi/3	[length = 2]
 955 00d2 E3A2      		std Z+35,r14
 956 00d4 F2A2      		std Z+34,r15	 ;  91	*movhi/3	[length = 2]
 957 00d6 E1A2      		std Z+33,r14
 958 00d8 F0A2      		std Z+32,r15	 ;  92	*movhi/3	[length = 2]
 959 00da E78E      		std Z+31,r14
 289:bertos/struct/fifobuf.h **** 	fb->end = buf + size - 1;
 960               		.loc 2 289 0
 961 00dc 2197      		sbiw r28,1	 ;  93	*addhi3/3	[length = 1]
 962               	.LVL65:
 963 00de CE0D      		add r28,r14	 ;  94	*addhi3/1	[length = 2]
 964 00e0 DF1D      		adc r29,r15
 965               	.LVL66:
 966 00e2 D6A3      		std Z+38,r29	 ;  95	*movhi/3	[length = 2]
 967 00e4 C5A3      		std Z+37,r28
 968               	.LBE171:
 969               	.LBE170:
 361:bertos/drv/ser.c **** 	fifo_init(&fd->rxfifo, fd->hw->rxbuffer, fd->hw->rxbuffer_size);
 970               		.loc 1 361 0
 971 00e6 00A8      		ldd __tmp_reg__,Z+48	 ;  97	*movhi/2	[length = 3]
 972 00e8 F1A9      		ldd r31,Z+49
 973 00ea E02D      		mov r30,__tmp_reg__
 974 00ec E480      		ldd r14,Z+4	 ;  98	*movhi/2	[length = 2]
 975 00ee F580      		ldd r15,Z+5
 976               	.LVL67:
 977 00f0 C085      		ldd r28,Z+8	 ;  99	*movhi/2	[length = 2]
 978 00f2 D185      		ldd r29,Z+9
 979               	.LVL68:
 980               	.LBB172:
 981               	.LBB173:
 286:bertos/struct/fifobuf.h **** 	ASSERT(size > 1);
 982               		.loc 2 286 0
 983 00f4 C230      		cpi r28,2	 ;  103	*cmphi/4	[length = 2]
 984 00f6 D105      		cpc r29,__zero_reg__
 985 00f8 00F4      		brsh .L58	 ;  104	branch	[length = 1]
 986 00fa 80E0      		ldi r24,lo8(__c.1616)	 ;  109	*movhi/4	[length = 2]
 987 00fc 90E0      		ldi r25,hi8(__c.1616)
 988 00fe 60E0      		ldi r22,lo8(__c.1618)	 ;  110	*movhi/4	[length = 2]
 989 0100 70E0      		ldi r23,hi8(__c.1618)
 990 0102 4EE1      		ldi r20,lo8(286)	 ;  111	*movhi/4	[length = 2]
 991 0104 51E0      		ldi r21,hi8(286)
 992 0106 0E94 0000 		call __bassert_P	 ;  112	call_value_insn/3	[length = 2]
 993               	.LVL69:
 994               	.L58:
 288:bertos/struct/fifobuf.h **** 	fb->head = fb->tail = fb->begin = buf;
 995               		.loc 2 288 0
 996 010a D801      		movw r26,r16	 ;  161	*movhi/1	[length = 1]
 997 010c 9C96      		adiw r26,43+1	 ;  115	*movhi/3	[length = 4]
 998 010e FC92      		st X,r15
 999 0110 EE92      		st -X,r14
 1000 0112 9B97      		sbiw r26,43
 1001 0114 9A96      		adiw r26,41+1	 ;  116	*movhi/3	[length = 4]
 1002 0116 FC92      		st X,r15
 1003 0118 EE92      		st -X,r14
 1004 011a 9997      		sbiw r26,41
 1005 011c 9896      		adiw r26,39+1	 ;  117	*movhi/3	[length = 4]
 1006 011e FC92      		st X,r15
 1007 0120 EE92      		st -X,r14
 1008 0122 9797      		sbiw r26,39
 1009               		.loc 2 289 0
 1010 0124 2197      		sbiw r28,1	 ;  118	*addhi3/3	[length = 1]
 1011               	.LVL70:
 1012 0126 CE0D      		add r28,r14	 ;  119	*addhi3/1	[length = 2]
 1013 0128 DF1D      		adc r29,r15
 1014               	.LVL71:
 1015 012a 9E96      		adiw r26,45+1	 ;  120	*movhi/3	[length = 4]
 1016 012c DC93      		st X,r29
 1017 012e CE93      		st -X,r28
 1018 0130 9D97      		sbiw r26,45
 1019               	.LBE173:
 1020               	.LBE172:
 362:bertos/drv/ser.c **** 
 363:bertos/drv/ser.c **** 	fd->hw->table->init(fd->hw, fd);
 1021               		.loc 1 363 0
 1022 0132 D096      		adiw r26,48	 ;  121	*movhi/2	[length = 4]
 1023 0134 8D91      		ld r24,X+
 1024 0136 9C91      		ld r25,X
 1025 0138 D197      		sbiw r26,48+1
 1026 013a DC01      		movw r26,r24	 ;  162	*movhi/1	[length = 1]
 1027 013c ED91      		ld r30,X+	 ;  123	*movhi/2	[length = 2]
 1028 013e FC91      		ld r31,X
 1029 0140 0190      		ld __tmp_reg__,Z+	 ;  124	*movhi/2	[length = 3]
 1030 0142 F081      		ld r31,Z
 1031 0144 E02D      		mov r30,__tmp_reg__
 1032 0146 B801      		movw r22,r16	 ;  126	*movhi/1	[length = 1]
 1033 0148 0995      		icall	 ;  127	call_insn/1	[length = 1]
 364:bertos/drv/ser.c **** 
 365:bertos/drv/ser.c **** 	/* Set default values */
 366:bertos/drv/ser.c **** #if CONFIG_SER_RXTIMEOUT != -1 || CONFIG_SER_TXTIMEOUT != -1
 367:bertos/drv/ser.c **** 	ser_settimeouts(fd, CONFIG_SER_RXTIMEOUT, CONFIG_SER_TXTIMEOUT);
 368:bertos/drv/ser.c **** #endif
 369:bertos/drv/ser.c **** #if CONFIG_SER_DEFBAUDRATE
 370:bertos/drv/ser.c **** 	ser_setbaudrate(fd, CONFIG_SER_DEFBAUDRATE);
 371:bertos/drv/ser.c **** #endif
 372:bertos/drv/ser.c **** 
 373:bertos/drv/ser.c **** 	/* Clear error flags */
 374:bertos/drv/ser.c **** 	ser_setstatus(fd, 0);
 1034               		.loc 1 374 0
 1035 014a F801      		movw r30,r16	 ;  163	*movhi/1	[length = 1]
 1036 014c 17A6      		std Z+47,__zero_reg__	 ;  128	*movqi/3	[length = 1]
 375:bertos/drv/ser.c **** 
 376:bertos/drv/ser.c **** 	return fd;
 377:bertos/drv/ser.c **** }
 1037               		.loc 1 377 0
 1038 014e C801      		movw r24,r16	 ;  180	*movhi/1	[length = 1]
 1039               	/* epilogue start */
 1040 0150 DF91      		pop r29	 ;  172	popqi	[length = 1]
 1041 0152 CF91      		pop r28	 ;  173	popqi	[length = 1]
 1042 0154 1F91      		pop r17	 ;  174	popqi	[length = 1]
 1043 0156 0F91      		pop r16	 ;  175	popqi	[length = 1]
 1044               	.LVL72:
 1045 0158 FF90      		pop r15	 ;  176	popqi	[length = 1]
 1046 015a EF90      		pop r14	 ;  177	popqi	[length = 1]
 1047               	.LVL73:
 1048 015c 0895      		ret	 ;  178	return_from_epilogue	[length = 1]
 1049               		.cfi_endproc
 1050               	.LFE62:
 1052               		.section	.text.ser_getchar_nowait,"ax",@progbits
 1053               	.global	ser_getchar_nowait
 1055               	ser_getchar_nowait:
 1056               	.LFB51:
 185:bertos/drv/ser.c **** {
 1057               		.loc 1 185 0
 1058               		.cfi_startproc
 1059               	.LVL74:
 1060               	/* prologue: function */
 1061               	/* frame size = 0 */
 1062               	/* stack size = 0 */
 1063               	.L__stack_usage = 0
 1064 0000 FC01      		movw r30,r24	 ;  2	*movhi/1	[length = 1]
 1065               	.LVL75:
 1066               	.LBB174:
 1067               	.LBB175:
 1068               	.LBB176:
 227:bertos/struct/fifobuf.h **** 		ATOMIC(result = fifo_isempty(fb));
 1069               		.loc 2 227 0
 1070               	/* #APP */
 1071               	 ;  227 "bertos/struct/fifobuf.h" 1
 1072 0002 4FB7      		in r20,__SREG__
 1073 0004 F894      		cli
 1074               	 ;  0 "" 2
 1075               	.LVL76:
 1076               	/* #NOAPP */
 1077               	.LBB177:
 1078               	.LBB178:
 105:bertos/struct/fifobuf.h **** 	return fb->head == fb->tail;
 1079               		.loc 2 105 0
 1080 0006 27A1      		ldd r18,Z+39	 ;  13	*movhi/2	[length = 2]
 1081 0008 30A5      		ldd r19,Z+40
 1082 000a 81A5      		ldd r24,Z+41	 ;  14	*movhi/2	[length = 2]
 1083 000c 92A5      		ldd r25,Z+42
 1084               	.LVL77:
 1085               	.LBE178:
 1086               	.LBE177:
 227:bertos/struct/fifobuf.h **** 		ATOMIC(result = fifo_isempty(fb));
 1087               		.loc 2 227 0
 1088               	/* #APP */
 1089               	 ;  227 "bertos/struct/fifobuf.h" 1
 1090 000e 4FBF      		out __SREG__,r20
 1091               	 ;  0 "" 2
 1092               	/* #NOAPP */
 1093               	.LBE176:
 1094               	.LBE175:
 1095               	.LBE174:
 186:bertos/drv/ser.c **** 	if (fifo_isempty_locked(&fd->rxfifo))
 1096               		.loc 1 186 0
 1097 0010 2817      		cp r18,r24	 ;  17	*cmphi/3	[length = 2]
 1098 0012 3907      		cpc r19,r25
 1099 0014 01F0      		breq .L63	 ;  18	branch	[length = 1]
 1100               	.LVL78:
 1101               	.LBB179:
 1102               	.LBB180:
 1103               	.LBB181:
 249:bertos/struct/fifobuf.h **** 		ATOMIC(c = fifo_pop(fb));
 1104               		.loc 2 249 0
 1105               	/* #APP */
 1106               	 ;  249 "bertos/struct/fifobuf.h" 1
 1107 0016 2FB7      		in r18,__SREG__
 1108 0018 F894      		cli
 1109               	 ;  0 "" 2
 1110               	.LVL79:
 1111               	/* #NOAPP */
 1112               	.LBB182:
 1113               	.LBB183:
 181:bertos/struct/fifobuf.h **** 	if (UNLIKELY(fb->head == fb->end))
 1114               		.loc 2 181 0
 1115 001a A7A1      		ldd r26,Z+39	 ;  26	*movhi/2	[length = 2]
 1116 001c B0A5      		ldd r27,Z+40
 1117 001e 85A5      		ldd r24,Z+45	 ;  27	*movhi/2	[length = 2]
 1118 0020 96A5      		ldd r25,Z+46
 1119 0022 A817      		cp r26,r24	 ;  28	*cmphi/3	[length = 2]
 1120 0024 B907      		cpc r27,r25
 1121 0026 01F4      		brne .L61	 ;  29	branch	[length = 1]
 184:bertos/struct/fifobuf.h **** 		fb->head = fb->begin;
 1122               		.loc 2 184 0
 1123 0028 83A5      		ldd r24,Z+43	 ;  31	*movhi/2	[length = 2]
 1124 002a 94A5      		ldd r25,Z+44
 1125 002c 90A7      		std Z+40,r25	 ;  32	*movhi/3	[length = 2]
 1126 002e 87A3      		std Z+39,r24
 185:bertos/struct/fifobuf.h **** 		return *(fb->end);
 1127               		.loc 2 185 0
 1128 0030 8C91      		ld r24,X	 ;  33	*movqi/4	[length = 1]
 1129 0032 00C0      		rjmp .L62	 ;  79	jump	[length = 1]
 1130               	.L61:
 189:bertos/struct/fifobuf.h **** 		return *(fb->head++);
 1131               		.loc 2 189 0
 1132 0034 A7A1      		ldd r26,Z+39	 ;  38	*movhi/2	[length = 2]
 1133 0036 B0A5      		ldd r27,Z+40
 1134 0038 8D91      		ld r24,X+	 ;  39	*movqi/4	[length = 1]
 1135 003a B0A7      		std Z+40,r27	 ;  41	*movhi/3	[length = 2]
 1136 003c A7A3      		std Z+39,r26
 1137               	.L62:
 1138               	.LBE183:
 1139               	.LBE182:
 249:bertos/struct/fifobuf.h **** 		ATOMIC(c = fifo_pop(fb));
 1140               		.loc 2 249 0
 1141               	/* #APP */
 1142               	 ;  249 "bertos/struct/fifobuf.h" 1
 1143 003e 2FBF      		out __SREG__,r18
 1144               	 ;  0 "" 2
 1145               	/* #NOAPP */
 1146               	.LBE181:
 1147               	.LBE180:
 1148               	.LBE179:
 190:bertos/drv/ser.c **** 	return (int)(unsigned char)fifo_pop_locked(&fd->rxfifo);
 1149               		.loc 1 190 0
 1150 0040 90E0      		ldi r25,lo8(0)	 ;  74	*movqi/2	[length = 1]
 1151 0042 0895      		ret	 ;  76	return	[length = 1]
 1152               	.LVL80:
 1153               	.L63:
 187:bertos/drv/ser.c **** 		return EOF;
 1154               		.loc 1 187 0
 1155 0044 8FEF      		ldi r24,lo8(-1)	 ;  4	*movhi/4	[length = 2]
 1156 0046 9FEF      		ldi r25,hi8(-1)
 191:bertos/drv/ser.c **** }
 1157               		.loc 1 191 0
 1158 0048 0895      		ret	 ;  78	return	[length = 1]
 1159               		.cfi_endproc
 1160               	.LFE51:
 1162               		.section	.text.ser_setbaudrate,"ax",@progbits
 1163               	.global	ser_setbaudrate
 1165               	ser_setbaudrate:
 1166               	.LFB54:
 263:bertos/drv/ser.c **** {
 1167               		.loc 1 263 0
 1168               		.cfi_startproc
 1169               	.LVL81:
 1170               	/* prologue: function */
 1171               	/* frame size = 0 */
 1172               	/* stack size = 0 */
 1173               	.L__stack_usage = 0
 264:bertos/drv/ser.c **** 	fd->hw->table->setBaudrate(fd->hw, rate);
 1174               		.loc 1 264 0
 1175 0000 DC01      		movw r26,r24	 ;  18	*movhi/1	[length = 1]
 1176 0002 D096      		adiw r26,48	 ;  7	*movhi/2	[length = 4]
 1177 0004 8D91      		ld r24,X+
 1178 0006 9C91      		ld r25,X
 1179 0008 D197      		sbiw r26,48+1
 1180               	.LVL82:
 1181 000a DC01      		movw r26,r24	 ;  19	*movhi/1	[length = 1]
 1182               	.LVL83:
 1183 000c ED91      		ld r30,X+	 ;  9	*movhi/2	[length = 2]
 1184 000e FC91      		ld r31,X
 1185 0010 0480      		ldd __tmp_reg__,Z+4	 ;  10	*movhi/2	[length = 3]
 1186 0012 F581      		ldd r31,Z+5
 1187 0014 E02D      		mov r30,__tmp_reg__
 1188 0016 0995      		icall	 ;  13	call_insn/1	[length = 1]
 1189               	.LVL84:
 1190               	/* epilogue start */
 265:bertos/drv/ser.c **** }
 1191               		.loc 1 265 0
 1192 0018 0895      		ret	 ;  22	return	[length = 1]
 1193               		.cfi_endproc
 1194               	.LFE54:
 1196               		.section	.text.ser_setparity,"ax",@progbits
 1197               	.global	ser_setparity
 1199               	ser_setparity:
 1200               	.LFB55:
 272:bertos/drv/ser.c **** {
 1201               		.loc 1 272 0
 1202               		.cfi_startproc
 1203               	.LVL85:
 1204               	/* prologue: function */
 1205               	/* frame size = 0 */
 1206               	/* stack size = 0 */
 1207               	.L__stack_usage = 0
 273:bertos/drv/ser.c **** 	fd->hw->table->setParity(fd->hw, parity);
 1208               		.loc 1 273 0
 1209 0000 DC01      		movw r26,r24	 ;  18	*movhi/1	[length = 1]
 1210 0002 D096      		adiw r26,48	 ;  7	*movhi/2	[length = 4]
 1211 0004 8D91      		ld r24,X+
 1212 0006 9C91      		ld r25,X
 1213 0008 D197      		sbiw r26,48+1
 1214               	.LVL86:
 1215 000a DC01      		movw r26,r24	 ;  19	*movhi/1	[length = 1]
 1216               	.LVL87:
 1217 000c ED91      		ld r30,X+	 ;  9	*movhi/2	[length = 2]
 1218 000e FC91      		ld r31,X
 1219 0010 0680      		ldd __tmp_reg__,Z+6	 ;  10	*movhi/2	[length = 3]
 1220 0012 F781      		ldd r31,Z+7
 1221 0014 E02D      		mov r30,__tmp_reg__
 1222 0016 0995      		icall	 ;  13	call_insn/1	[length = 1]
 1223               	.LVL88:
 1224               	/* epilogue start */
 274:bertos/drv/ser.c **** }
 1225               		.loc 1 274 0
 1226 0018 0895      		ret	 ;  22	return	[length = 1]
 1227               		.cfi_endproc
 1228               	.LFE55:
 1230               		.section	.text.ser_purgeRx,"ax",@progbits
 1231               	.global	ser_purgeRx
 1233               	ser_purgeRx:
 1234               	.LFB59:
 303:bertos/drv/ser.c **** {
 1235               		.loc 1 303 0
 1236               		.cfi_startproc
 1237               	.LVL89:
 1238               	/* prologue: function */
 1239               	/* frame size = 0 */
 1240               	/* stack size = 0 */
 1241               	.L__stack_usage = 0
 1242 0000 FC01      		movw r30,r24	 ;  2	*movhi/1	[length = 1]
 1243               	.LVL90:
 1244               	.LBB184:
 1245               	.LBB185:
 263:bertos/struct/fifobuf.h **** 		ATOMIC(fifo_flush(fb));
 1246               		.loc 2 263 0
 1247               	/* #APP */
 1248               	 ;  263 "bertos/struct/fifobuf.h" 1
 1249 0002 2FB7      		in r18,__SREG__
 1250 0004 F894      		cli
 1251               	 ;  0 "" 2
 1252               	.LVL91:
 1253               	/* #NOAPP */
 1254               	.LBB186:
 1255               	.LBB187:
 199:bertos/struct/fifobuf.h **** 	fb->head = fb->tail;
 1256               		.loc 2 199 0
 1257 0006 81A5      		ldd r24,Z+41	 ;  12	*movhi/2	[length = 2]
 1258 0008 92A5      		ldd r25,Z+42
 1259               	.LVL92:
 1260 000a 90A7      		std Z+40,r25	 ;  13	*movhi/3	[length = 2]
 1261 000c 87A3      		std Z+39,r24
 1262               	.LBE187:
 1263               	.LBE186:
 263:bertos/struct/fifobuf.h **** 		ATOMIC(fifo_flush(fb));
 1264               		.loc 2 263 0
 1265               	/* #APP */
 1266               	 ;  263 "bertos/struct/fifobuf.h" 1
 1267 000e 2FBF      		out __SREG__,r18
 1268               	 ;  0 "" 2
 1269               	/* epilogue start */
 1270               	/* #NOAPP */
 1271               	.LBE185:
 1272               	.LBE184:
 305:bertos/drv/ser.c **** }
 1273               		.loc 1 305 0
 1274 0010 0895      		ret	 ;  20	return	[length = 1]
 1275               		.cfi_endproc
 1276               	.LFE59:
 1278               		.section	.text.spimaster_write,"ax",@progbits
 1280               	spimaster_write:
 1281               	.LFB67:
 378:bertos/drv/ser.c **** 
 379:bertos/drv/ser.c **** 
 380:bertos/drv/ser.c **** /**
 381:bertos/drv/ser.c ****  * Clean up serial port, disabling the associated hardware.
 382:bertos/drv/ser.c ****  */
 383:bertos/drv/ser.c **** static int ser_close(struct KFile *fd)
 384:bertos/drv/ser.c **** {
 385:bertos/drv/ser.c **** 	Serial *fds = SERIAL_CAST(fd);
 386:bertos/drv/ser.c **** 	Serial *port = fds;
 387:bertos/drv/ser.c **** 
 388:bertos/drv/ser.c **** 	ASSERT(port->is_open);
 389:bertos/drv/ser.c **** 	DB(port->is_open = false);
 390:bertos/drv/ser.c **** 
 391:bertos/drv/ser.c **** 	// Wait until we finish sending everything
 392:bertos/drv/ser.c **** 	ser_flush(fd);
 393:bertos/drv/ser.c **** 
 394:bertos/drv/ser.c **** 	port->hw->table->cleanup(port->hw);
 395:bertos/drv/ser.c **** 	DB(port->hw = NULL);
 396:bertos/drv/ser.c **** 
 397:bertos/drv/ser.c **** 	/*
 398:bertos/drv/ser.c **** 	 * We purge the FIFO buffer only after the low-level cleanup, so that
 399:bertos/drv/ser.c **** 	 * we are sure that there are no more interrupts.
 400:bertos/drv/ser.c **** 	 */
 401:bertos/drv/ser.c **** 	ser_purge(fds);
 402:bertos/drv/ser.c **** 	return 0;
 403:bertos/drv/ser.c **** }
 404:bertos/drv/ser.c **** 
 405:bertos/drv/ser.c **** /**
 406:bertos/drv/ser.c ****  * Reopen serial port.
 407:bertos/drv/ser.c ****  */
 408:bertos/drv/ser.c **** static struct KFile *ser_reopen(struct KFile *fd)
 409:bertos/drv/ser.c **** {
 410:bertos/drv/ser.c **** 	Serial *fds = SERIAL_CAST(fd);
 411:bertos/drv/ser.c **** 
 412:bertos/drv/ser.c **** 	ser_close(fd);
 413:bertos/drv/ser.c **** 	ser_open(fds, fds->unit);
 414:bertos/drv/ser.c **** 	return (KFile *)fds;
 415:bertos/drv/ser.c **** }
 416:bertos/drv/ser.c **** 
 417:bertos/drv/ser.c **** /**
 418:bertos/drv/ser.c ****  * Init serial driver for \a unit.
 419:bertos/drv/ser.c ****  *
 420:bertos/drv/ser.c ****  * Use values SER_UARTn as values for \a unit.
 421:bertos/drv/ser.c ****  */
 422:bertos/drv/ser.c **** void ser_init(struct Serial *fds, unsigned int unit)
 423:bertos/drv/ser.c **** {
 424:bertos/drv/ser.c **** 	memset(fds, 0, sizeof(*fds));
 425:bertos/drv/ser.c **** 
 426:bertos/drv/ser.c **** 	DB(fds->fd._type = KFT_SERIAL);
 427:bertos/drv/ser.c **** 	fds->fd.reopen = ser_reopen;
 428:bertos/drv/ser.c **** 	fds->fd.close = ser_close;
 429:bertos/drv/ser.c **** 	fds->fd.read = ser_read;
 430:bertos/drv/ser.c **** 	fds->fd.write = ser_write;
 431:bertos/drv/ser.c **** 	fds->fd.flush = ser_flush;
 432:bertos/drv/ser.c **** 	fds->fd.error = ser_error;
 433:bertos/drv/ser.c **** 	fds->fd.clearerr = ser_clearerr;
 434:bertos/drv/ser.c **** 	ser_open(fds, unit);
 435:bertos/drv/ser.c **** }
 436:bertos/drv/ser.c **** 
 437:bertos/drv/ser.c **** 
 438:bertos/drv/ser.c **** /**
 439:bertos/drv/ser.c ****  * Read data from SPI bus.
 440:bertos/drv/ser.c ****  * Since we are master, we have to trigger slave by sending
 441:bertos/drv/ser.c ****  * fake chars on the bus.
 442:bertos/drv/ser.c ****  */
 443:bertos/drv/ser.c **** static size_t spimaster_read(struct KFile *fd, void *_buf, size_t size)
 444:bertos/drv/ser.c **** {
 445:bertos/drv/ser.c **** 	Serial *fd_spi = SERIAL_CAST(fd);
 446:bertos/drv/ser.c **** 
 447:bertos/drv/ser.c **** 	ser_flush(&fd_spi->fd);
 448:bertos/drv/ser.c **** 	ser_purgeRx(fd_spi);
 449:bertos/drv/ser.c **** 
 450:bertos/drv/ser.c **** 	size_t total_rd = 0;
 451:bertos/drv/ser.c **** 	uint8_t *buf = (uint8_t *)_buf;
 452:bertos/drv/ser.c **** 	int c;
 453:bertos/drv/ser.c **** 
 454:bertos/drv/ser.c **** 	while (size--)
 455:bertos/drv/ser.c **** 	{
 456:bertos/drv/ser.c **** 		/*
 457:bertos/drv/ser.c **** 		 * Send and receive chars 1 by 1, otherwise the rxfifo
 458:bertos/drv/ser.c **** 		 * will overrun.
 459:bertos/drv/ser.c **** 		 */
 460:bertos/drv/ser.c **** 		ser_putchar(0, fd_spi);
 461:bertos/drv/ser.c **** 
 462:bertos/drv/ser.c **** 		if ((c = ser_getchar(fd_spi)) == EOF)
 463:bertos/drv/ser.c **** 			break;
 464:bertos/drv/ser.c **** 
 465:bertos/drv/ser.c **** 		*buf++ = c;
 466:bertos/drv/ser.c **** 		total_rd++;
 467:bertos/drv/ser.c **** 	}
 468:bertos/drv/ser.c **** 	return total_rd;
 469:bertos/drv/ser.c **** }
 470:bertos/drv/ser.c **** 
 471:bertos/drv/ser.c **** /**
 472:bertos/drv/ser.c ****  * Write data to SPI bus.
 473:bertos/drv/ser.c ****  */
 474:bertos/drv/ser.c **** static size_t spimaster_write(struct KFile *fd, const void *buf, size_t size)
 475:bertos/drv/ser.c **** {
 1282               		.loc 1 475 0
 1283               		.cfi_startproc
 1284               	.LVL93:
 1285 0000 EF92      		push r14	 ;  52	*pushqi/1	[length = 1]
 1286               	.LCFI29:
 1287               		.cfi_def_cfa_offset 3
 1288               		.cfi_offset 14, -2
 1289 0002 FF92      		push r15	 ;  53	*pushqi/1	[length = 1]
 1290               	.LCFI30:
 1291               		.cfi_def_cfa_offset 4
 1292               		.cfi_offset 15, -3
 1293 0004 0F93      		push r16	 ;  54	*pushqi/1	[length = 1]
 1294               	.LCFI31:
 1295               		.cfi_def_cfa_offset 5
 1296               		.cfi_offset 16, -4
 1297 0006 1F93      		push r17	 ;  55	*pushqi/1	[length = 1]
 1298               	.LCFI32:
 1299               		.cfi_def_cfa_offset 6
 1300               		.cfi_offset 17, -5
 1301 0008 CF93      		push r28	 ;  56	*pushqi/1	[length = 1]
 1302               	.LCFI33:
 1303               		.cfi_def_cfa_offset 7
 1304               		.cfi_offset 28, -6
 1305 000a DF93      		push r29	 ;  57	*pushqi/1	[length = 1]
 1306               	.LCFI34:
 1307               		.cfi_def_cfa_offset 8
 1308               		.cfi_offset 29, -7
 1309               	/* prologue: function */
 1310               	/* frame size = 0 */
 1311               	/* stack size = 6 */
 1312               	.L__stack_usage = 6
 1313 000c EC01      		movw r28,r24	 ;  2	*movhi/1	[length = 1]
 1314 000e 8B01      		movw r16,r22	 ;  3	*movhi/1	[length = 1]
 1315 0010 7A01      		movw r14,r20	 ;  4	*movhi/1	[length = 1]
 1316               	.LVL94:
 1317               	.LBB188:
 1318               	.LBB189:
 1319               		.loc 3 189 0
 1320 0012 8889      		ldd r24,Y+16	 ;  9	*movsi/3	[length = 4]
 1321 0014 9989      		ldd r25,Y+17
 1322 0016 AA89      		ldd r26,Y+18
 1323 0018 BB89      		ldd r27,Y+19
 1324               	.LVL95:
 1325 001a 8C34      		cpi r24,lo8(1397051980)	 ;  10	*cmpsi/4	[length = 7]
 1326 001c 22E5      		ldi r18,hi8(1397051980)
 1327 001e 9207      		cpc r25,r18
 1328 0020 25E4      		ldi r18,hlo8(1397051980)
 1329 0022 A207      		cpc r26,r18
 1330 0024 23E5      		ldi r18,hhi8(1397051980)
 1331 0026 B207      		cpc r27,r18
 1332 0028 01F0      		breq .L68	 ;  11	branch	[length = 1]
 1333               	.LVL96:
 1334 002a 80E0      		ldi r24,lo8(__c.1642)	 ;  16	*movhi/4	[length = 2]
 1335 002c 90E0      		ldi r25,hi8(__c.1642)
 1336 002e 60E0      		ldi r22,lo8(__c.1644)	 ;  17	*movhi/4	[length = 2]
 1337 0030 70E0      		ldi r23,hi8(__c.1644)
 1338 0032 4DEB      		ldi r20,lo8(189)	 ;  18	*movhi/4	[length = 2]
 1339 0034 50E0      		ldi r21,hi8(189)
 1340 0036 0E94 0000 		call __bassert_P	 ;  19	call_value_insn/3	[length = 2]
 1341               	.LVL97:
 1342               	.L68:
 1343               	.LBE189:
 1344               	.LBE188:
 476:bertos/drv/ser.c **** 	Serial *fd_spi = SERIAL_CAST(fd);
 477:bertos/drv/ser.c **** 
 478:bertos/drv/ser.c **** 	ser_purgeRx(fd_spi);
 1345               		.loc 1 478 0
 1346 003a CE01      		movw r24,r28	 ;  24	*movhi/1	[length = 1]
 1347 003c 0E94 0000 		call ser_purgeRx	 ;  25	call_insn/3	[length = 2]
 479:bertos/drv/ser.c **** 
 480:bertos/drv/ser.c **** 	return ser_write(&fd_spi->fd, buf, size);
 1348               		.loc 1 480 0
 1349 0040 CE01      		movw r24,r28	 ;  27	*movhi/1	[length = 1]
 1350 0042 B801      		movw r22,r16	 ;  28	*movhi/1	[length = 1]
 1351 0044 A701      		movw r20,r14	 ;  29	*movhi/1	[length = 1]
 1352 0046 0E94 0000 		call ser_write	 ;  30	call_value_insn/3	[length = 2]
 1353               	/* epilogue start */
 481:bertos/drv/ser.c **** }
 1354               		.loc 1 481 0
 1355 004a DF91      		pop r29	 ;  60	popqi	[length = 1]
 1356 004c CF91      		pop r28	 ;  61	popqi	[length = 1]
 1357               	.LVL98:
 1358 004e 1F91      		pop r17	 ;  62	popqi	[length = 1]
 1359 0050 0F91      		pop r16	 ;  63	popqi	[length = 1]
 1360               	.LVL99:
 1361 0052 FF90      		pop r15	 ;  64	popqi	[length = 1]
 1362 0054 EF90      		pop r14	 ;  65	popqi	[length = 1]
 1363               	.LVL100:
 1364 0056 0895      		ret	 ;  66	return_from_epilogue	[length = 1]
 1365               		.cfi_endproc
 1366               	.LFE67:
 1368               		.section	.text.spimaster_read,"ax",@progbits
 1370               	spimaster_read:
 1371               	.LFB66:
 444:bertos/drv/ser.c **** {
 1372               		.loc 1 444 0
 1373               		.cfi_startproc
 1374               	.LVL101:
 1375 0000 CF92      		push r12	 ;  93	*pushqi/1	[length = 1]
 1376               	.LCFI35:
 1377               		.cfi_def_cfa_offset 3
 1378               		.cfi_offset 12, -2
 1379 0002 DF92      		push r13	 ;  94	*pushqi/1	[length = 1]
 1380               	.LCFI36:
 1381               		.cfi_def_cfa_offset 4
 1382               		.cfi_offset 13, -3
 1383 0004 EF92      		push r14	 ;  95	*pushqi/1	[length = 1]
 1384               	.LCFI37:
 1385               		.cfi_def_cfa_offset 5
 1386               		.cfi_offset 14, -4
 1387 0006 FF92      		push r15	 ;  96	*pushqi/1	[length = 1]
 1388               	.LCFI38:
 1389               		.cfi_def_cfa_offset 6
 1390               		.cfi_offset 15, -5
 1391 0008 0F93      		push r16	 ;  97	*pushqi/1	[length = 1]
 1392               	.LCFI39:
 1393               		.cfi_def_cfa_offset 7
 1394               		.cfi_offset 16, -6
 1395 000a 1F93      		push r17	 ;  98	*pushqi/1	[length = 1]
 1396               	.LCFI40:
 1397               		.cfi_def_cfa_offset 8
 1398               		.cfi_offset 17, -7
 1399 000c CF93      		push r28	 ;  99	*pushqi/1	[length = 1]
 1400               	.LCFI41:
 1401               		.cfi_def_cfa_offset 9
 1402               		.cfi_offset 28, -8
 1403 000e DF93      		push r29	 ;  100	*pushqi/1	[length = 1]
 1404               	.LCFI42:
 1405               		.cfi_def_cfa_offset 10
 1406               		.cfi_offset 29, -9
 1407               	/* prologue: function */
 1408               	/* frame size = 0 */
 1409               	/* stack size = 8 */
 1410               	.L__stack_usage = 8
 1411 0010 EC01      		movw r28,r24	 ;  2	*movhi/1	[length = 1]
 1412 0012 162F      		mov r17,r22	 ;  79	*movqi/1	[length = 1]
 1413 0014 072F      		mov r16,r23	 ;  80	*movqi/1	[length = 1]
 1414 0016 6A01      		movw r12,r20	 ;  4	*movhi/1	[length = 1]
 1415               	.LVL102:
 1416               	.LBB190:
 1417               	.LBB191:
 1418               		.loc 3 189 0
 1419 0018 8889      		ldd r24,Y+16	 ;  11	*movsi/3	[length = 4]
 1420 001a 9989      		ldd r25,Y+17
 1421 001c AA89      		ldd r26,Y+18
 1422 001e BB89      		ldd r27,Y+19
 1423               	.LVL103:
 1424 0020 8C34      		cpi r24,lo8(1397051980)	 ;  12	*cmpsi/4	[length = 7]
 1425 0022 22E5      		ldi r18,hi8(1397051980)
 1426 0024 9207      		cpc r25,r18
 1427 0026 25E4      		ldi r18,hlo8(1397051980)
 1428 0028 A207      		cpc r26,r18
 1429 002a 23E5      		ldi r18,hhi8(1397051980)
 1430 002c B207      		cpc r27,r18
 1431 002e 01F0      		breq .L70	 ;  13	branch	[length = 1]
 1432               	.LVL104:
 1433 0030 80E0      		ldi r24,lo8(__c.1642)	 ;  18	*movhi/4	[length = 2]
 1434 0032 90E0      		ldi r25,hi8(__c.1642)
 1435 0034 60E0      		ldi r22,lo8(__c.1644)	 ;  19	*movhi/4	[length = 2]
 1436 0036 70E0      		ldi r23,hi8(__c.1644)
 1437               	.LVL105:
 1438 0038 4DEB      		ldi r20,lo8(189)	 ;  20	*movhi/4	[length = 2]
 1439 003a 50E0      		ldi r21,hi8(189)
 1440 003c 0E94 0000 		call __bassert_P	 ;  21	call_value_insn/3	[length = 2]
 1441               	.L70:
 1442               	.LBE191:
 1443               	.LBE190:
 447:bertos/drv/ser.c **** 	ser_flush(&fd_spi->fd);
 1444               		.loc 1 447 0
 1445 0040 CE01      		movw r24,r28	 ;  26	*movhi/1	[length = 1]
 1446 0042 0E94 0000 		call ser_flush	 ;  27	call_value_insn/3	[length = 2]
 448:bertos/drv/ser.c **** 	ser_purgeRx(fd_spi);
 1447               		.loc 1 448 0
 1448 0046 CE01      		movw r24,r28	 ;  29	*movhi/1	[length = 1]
 1449 0048 0E94 0000 		call ser_purgeRx	 ;  30	call_insn/3	[length = 2]
 1450               	.LVL106:
 451:bertos/drv/ser.c **** 	uint8_t *buf = (uint8_t *)_buf;
 1451               		.loc 1 451 0
 1452 004c E12E      		mov r14,r17	 ;  82	*movqi/1	[length = 1]
 1453 004e F02E      		mov r15,r16	 ;  83	*movqi/1	[length = 1]
 450:bertos/drv/ser.c **** 	size_t total_rd = 0;
 1454               		.loc 1 450 0
 1455 0050 00E0      		ldi r16,lo8(0)	 ;  7	*movhi/4	[length = 2]
 1456 0052 10E0      		ldi r17,hi8(0)
 1457               	.LVL107:
 454:bertos/drv/ser.c **** 	while (size--)
 1458               		.loc 1 454 0
 1459 0054 00C0      		rjmp .L71	 ;  114	jump	[length = 1]
 1460               	.LVL108:
 1461               	.L73:
 460:bertos/drv/ser.c **** 		ser_putchar(0, fd_spi);
 1462               		.loc 1 460 0
 1463 0056 80E0      		ldi r24,lo8(0)	 ;  37	*movhi/4	[length = 2]
 1464 0058 90E0      		ldi r25,hi8(0)
 1465 005a BE01      		movw r22,r28	 ;  38	*movhi/1	[length = 1]
 1466 005c 0E94 0000 		call ser_putchar	 ;  39	call_value_insn/3	[length = 2]
 462:bertos/drv/ser.c **** 		if ((c = ser_getchar(fd_spi)) == EOF)
 1467               		.loc 1 462 0
 1468 0060 CE01      		movw r24,r28	 ;  41	*movhi/1	[length = 1]
 1469 0062 0E94 0000 		call ser_getchar	 ;  42	call_value_insn/3	[length = 2]
 1470               	.LVL109:
 1471 0066 EFEF      		ldi r30,hi8(-1)	 ;  45	*cmphi/5	[length = 3]
 1472 0068 8F3F      		cpi r24,lo8(-1)
 1473 006a 9E07      		cpc r25,r30
 1474 006c 01F0      		breq .L72	 ;  46	branch	[length = 1]
 465:bertos/drv/ser.c **** 		*buf++ = c;
 1475               		.loc 1 465 0
 1476 006e F701      		movw r30,r14	 ;  91	*movhi/1	[length = 1]
 1477 0070 8193      		st Z+,r24	 ;  48	*movqi/3	[length = 1]
 1478 0072 7F01      		movw r14,r30	 ;  92	*movhi/1	[length = 1]
 1479               	.LVL110:
 466:bertos/drv/ser.c **** 		total_rd++;
 1480               		.loc 1 466 0
 1481 0074 0F5F      		subi r16,lo8(-(1))	 ;  51	*addhi3/4	[length = 2]
 1482 0076 1F4F      		sbci r17,hi8(-(1))
 1483               	.LVL111:
 1484               	.L71:
 454:bertos/drv/ser.c **** 	while (size--)
 1485               		.loc 1 454 0 discriminator 1
 1486 0078 0C15      		cp r16,r12	 ;  60	*cmphi/3	[length = 2]
 1487 007a 1D05      		cpc r17,r13
 1488 007c 01F4      		brne .L73	 ;  61	branch	[length = 1]
 1489               	.L72:
 469:bertos/drv/ser.c **** }
 1490               		.loc 1 469 0
 1491 007e C801      		movw r24,r16	 ;  113	*movhi/1	[length = 1]
 1492               	/* epilogue start */
 1493 0080 DF91      		pop r29	 ;  103	popqi	[length = 1]
 1494 0082 CF91      		pop r28	 ;  104	popqi	[length = 1]
 1495               	.LVL112:
 1496 0084 1F91      		pop r17	 ;  105	popqi	[length = 1]
 1497 0086 0F91      		pop r16	 ;  106	popqi	[length = 1]
 1498               	.LVL113:
 1499 0088 FF90      		pop r15	 ;  107	popqi	[length = 1]
 1500 008a EF90      		pop r14	 ;  108	popqi	[length = 1]
 1501               	.LVL114:
 1502 008c DF90      		pop r13	 ;  109	popqi	[length = 1]
 1503 008e CF90      		pop r12	 ;  110	popqi	[length = 1]
 1504 0090 0895      		ret	 ;  111	return_from_epilogue	[length = 1]
 1505               		.cfi_endproc
 1506               	.LFE66:
 1508               		.section	.text.ser_purgeTx,"ax",@progbits
 1509               	.global	ser_purgeTx
 1511               	ser_purgeTx:
 1512               	.LFB60:
 311:bertos/drv/ser.c **** {
 1513               		.loc 1 311 0
 1514               		.cfi_startproc
 1515               	.LVL115:
 1516               	/* prologue: function */
 1517               	/* frame size = 0 */
 1518               	/* stack size = 0 */
 1519               	.L__stack_usage = 0
 1520 0000 FC01      		movw r30,r24	 ;  2	*movhi/1	[length = 1]
 1521               	.LVL116:
 1522               	.LBB192:
 1523               	.LBB193:
 263:bertos/struct/fifobuf.h **** 		ATOMIC(fifo_flush(fb));
 1524               		.loc 2 263 0
 1525               	/* #APP */
 1526               	 ;  263 "bertos/struct/fifobuf.h" 1
 1527 0002 2FB7      		in r18,__SREG__
 1528 0004 F894      		cli
 1529               	 ;  0 "" 2
 1530               	.LVL117:
 1531               	/* #NOAPP */
 1532               	.LBB194:
 1533               	.LBB195:
 199:bertos/struct/fifobuf.h **** 	fb->head = fb->tail;
 1534               		.loc 2 199 0
 1535 0006 81A1      		ldd r24,Z+33	 ;  12	*movhi/2	[length = 2]
 1536 0008 92A1      		ldd r25,Z+34
 1537               	.LVL118:
 1538 000a 90A3      		std Z+32,r25	 ;  13	*movhi/3	[length = 2]
 1539 000c 878F      		std Z+31,r24
 1540               	.LBE195:
 1541               	.LBE194:
 263:bertos/struct/fifobuf.h **** 		ATOMIC(fifo_flush(fb));
 1542               		.loc 2 263 0
 1543               	/* #APP */
 1544               	 ;  263 "bertos/struct/fifobuf.h" 1
 1545 000e 2FBF      		out __SREG__,r18
 1546               	 ;  0 "" 2
 1547               	/* epilogue start */
 1548               	/* #NOAPP */
 1549               	.LBE193:
 1550               	.LBE192:
 313:bertos/drv/ser.c **** }
 1551               		.loc 1 313 0
 1552 0010 0895      		ret	 ;  20	return	[length = 1]
 1553               		.cfi_endproc
 1554               	.LFE60:
 1556               		.section	.text.ser_purge,"ax",@progbits
 1557               	.global	ser_purge
 1559               	ser_purge:
 1560               	.LFB58:
 294:bertos/drv/ser.c **** {
 1561               		.loc 1 294 0
 1562               		.cfi_startproc
 1563               	.LVL119:
 1564 0000 CF93      		push r28	 ;  17	*pushqi/1	[length = 1]
 1565               	.LCFI43:
 1566               		.cfi_def_cfa_offset 3
 1567               		.cfi_offset 28, -2
 1568 0002 DF93      		push r29	 ;  18	*pushqi/1	[length = 1]
 1569               	.LCFI44:
 1570               		.cfi_def_cfa_offset 4
 1571               		.cfi_offset 29, -3
 1572               	/* prologue: function */
 1573               	/* frame size = 0 */
 1574               	/* stack size = 2 */
 1575               	.L__stack_usage = 2
 1576 0004 EC01      		movw r28,r24	 ;  2	*movhi/1	[length = 1]
 295:bertos/drv/ser.c **** 	ser_purgeRx(fd);
 1577               		.loc 1 295 0
 1578 0006 0E94 0000 		call ser_purgeRx	 ;  8	call_insn/3	[length = 2]
 1579               	.LVL120:
 296:bertos/drv/ser.c **** 	ser_purgeTx(fd);
 1580               		.loc 1 296 0
 1581 000a CE01      		movw r24,r28	 ;  10	*movhi/1	[length = 1]
 1582 000c 0E94 0000 		call ser_purgeTx	 ;  11	call_insn/3	[length = 2]
 1583               	/* epilogue start */
 297:bertos/drv/ser.c **** }
 1584               		.loc 1 297 0
 1585 0010 DF91      		pop r29	 ;  21	popqi	[length = 1]
 1586 0012 CF91      		pop r28	 ;  22	popqi	[length = 1]
 1587               	.LVL121:
 1588 0014 0895      		ret	 ;  23	return_from_epilogue	[length = 1]
 1589               		.cfi_endproc
 1590               	.LFE58:
 1592               		.section	.text.ser_close,"ax",@progbits
 1594               	ser_close:
 1595               	.LFB63:
 384:bertos/drv/ser.c **** {
 1596               		.loc 1 384 0
 1597               		.cfi_startproc
 1598               	.LVL122:
 1599 0000 CF93      		push r28	 ;  66	*pushqi/1	[length = 1]
 1600               	.LCFI45:
 1601               		.cfi_def_cfa_offset 3
 1602               		.cfi_offset 28, -2
 1603 0002 DF93      		push r29	 ;  67	*pushqi/1	[length = 1]
 1604               	.LCFI46:
 1605               		.cfi_def_cfa_offset 4
 1606               		.cfi_offset 29, -3
 1607               	/* prologue: function */
 1608               	/* frame size = 0 */
 1609               	/* stack size = 2 */
 1610               	.L__stack_usage = 2
 1611 0004 EC01      		movw r28,r24	 ;  2	*movhi/1	[length = 1]
 1612               	.LVL123:
 1613               	.LBB196:
 1614               	.LBB197:
 1615               		.loc 3 189 0
 1616 0006 8889      		ldd r24,Y+16	 ;  7	*movsi/3	[length = 4]
 1617 0008 9989      		ldd r25,Y+17
 1618 000a AA89      		ldd r26,Y+18
 1619 000c BB89      		ldd r27,Y+19
 1620               	.LVL124:
 1621 000e 8C34      		cpi r24,lo8(1397051980)	 ;  8	*cmpsi/4	[length = 7]
 1622 0010 22E5      		ldi r18,hi8(1397051980)
 1623 0012 9207      		cpc r25,r18
 1624 0014 25E4      		ldi r18,hlo8(1397051980)
 1625 0016 A207      		cpc r26,r18
 1626 0018 23E5      		ldi r18,hhi8(1397051980)
 1627 001a B207      		cpc r27,r18
 1628 001c 01F0      		breq .L77	 ;  9	branch	[length = 1]
 1629 001e 80E0      		ldi r24,lo8(__c.1642)	 ;  14	*movhi/4	[length = 2]
 1630 0020 90E0      		ldi r25,hi8(__c.1642)
 1631 0022 60E0      		ldi r22,lo8(__c.1644)	 ;  15	*movhi/4	[length = 2]
 1632 0024 70E0      		ldi r23,hi8(__c.1644)
 1633 0026 4DEB      		ldi r20,lo8(189)	 ;  16	*movhi/4	[length = 2]
 1634 0028 50E0      		ldi r21,hi8(189)
 1635 002a 0E94 0000 		call __bassert_P	 ;  17	call_value_insn/3	[length = 2]
 1636               	.LVL125:
 1637               	.L77:
 1638               	.LBE197:
 1639               	.LBE196:
 388:bertos/drv/ser.c **** 	ASSERT(port->is_open);
 1640               		.loc 1 388 0
 1641 002e 8E8D      		ldd r24,Y+30	 ;  22	*movqi/4	[length = 1]
 1642 0030 8823      		tst r24	 ;  23	*cmpqi/1	[length = 1]
 1643 0032 01F4      		brne .L78	 ;  24	branch	[length = 1]
 388:bertos/drv/ser.c **** 	ASSERT(port->is_open);
 1644               		.loc 1 388 0 is_stmt 0 discriminator 1
 1645 0034 80E0      		ldi r24,lo8(__c.2071)	 ;  29	*movhi/4	[length = 2]
 1646 0036 90E0      		ldi r25,hi8(__c.2071)
 1647 0038 60E0      		ldi r22,lo8(__c.2073)	 ;  30	*movhi/4	[length = 2]
 1648 003a 70E0      		ldi r23,hi8(__c.2073)
 1649 003c 44E8      		ldi r20,lo8(388)	 ;  31	*movhi/4	[length = 2]
 1650 003e 51E0      		ldi r21,hi8(388)
 1651 0040 0E94 0000 		call __bassert_P	 ;  32	call_value_insn/3	[length = 2]
 1652               	.L78:
 389:bertos/drv/ser.c **** 	DB(port->is_open = false);
 1653               		.loc 1 389 0 is_stmt 1
 1654 0044 1E8E      		std Y+30,__zero_reg__	 ;  35	*movqi/3	[length = 1]
 392:bertos/drv/ser.c **** 	ser_flush(fd);
 1655               		.loc 1 392 0
 1656 0046 CE01      		movw r24,r28	 ;  37	*movhi/1	[length = 1]
 1657 0048 0E94 0000 		call ser_flush	 ;  38	call_value_insn/3	[length = 2]
 394:bertos/drv/ser.c **** 	port->hw->table->cleanup(port->hw);
 1658               		.loc 1 394 0
 1659 004c 88A9      		ldd r24,Y+48	 ;  39	*movhi/2	[length = 2]
 1660 004e 99A9      		ldd r25,Y+49
 1661 0050 DC01      		movw r26,r24	 ;  65	*movhi/1	[length = 1]
 1662 0052 ED91      		ld r30,X+	 ;  41	*movhi/2	[length = 2]
 1663 0054 FC91      		ld r31,X
 1664 0056 0280      		ldd __tmp_reg__,Z+2	 ;  42	*movhi/2	[length = 3]
 1665 0058 F381      		ldd r31,Z+3
 1666 005a E02D      		mov r30,__tmp_reg__
 1667 005c 0995      		icall	 ;  44	call_insn/1	[length = 1]
 395:bertos/drv/ser.c **** 	DB(port->hw = NULL);
 1668               		.loc 1 395 0
 1669 005e 19AA      		std Y+49,__zero_reg__	 ;  45	*movhi/3	[length = 2]
 1670 0060 18AA      		std Y+48,__zero_reg__
 401:bertos/drv/ser.c **** 	ser_purge(fds);
 1671               		.loc 1 401 0
 1672 0062 CE01      		movw r24,r28	 ;  47	*movhi/1	[length = 1]
 1673 0064 0E94 0000 		call ser_purge	 ;  48	call_insn/3	[length = 2]
 403:bertos/drv/ser.c **** }
 1674               		.loc 1 403 0
 1675 0068 80E0      		ldi r24,lo8(0)	 ;  53	*movhi/4	[length = 2]
 1676 006a 90E0      		ldi r25,hi8(0)
 1677               	/* epilogue start */
 1678 006c DF91      		pop r29	 ;  70	popqi	[length = 1]
 1679 006e CF91      		pop r28	 ;  71	popqi	[length = 1]
 1680               	.LVL126:
 1681 0070 0895      		ret	 ;  72	return_from_epilogue	[length = 1]
 1682               		.cfi_endproc
 1683               	.LFE63:
 1685               		.section	.text.ser_reopen,"ax",@progbits
 1687               	ser_reopen:
 1688               	.LFB64:
 409:bertos/drv/ser.c **** {
 1689               		.loc 1 409 0
 1690               		.cfi_startproc
 1691               	.LVL127:
 1692 0000 CF93      		push r28	 ;  49	*pushqi/1	[length = 1]
 1693               	.LCFI47:
 1694               		.cfi_def_cfa_offset 3
 1695               		.cfi_offset 28, -2
 1696 0002 DF93      		push r29	 ;  50	*pushqi/1	[length = 1]
 1697               	.LCFI48:
 1698               		.cfi_def_cfa_offset 4
 1699               		.cfi_offset 29, -3
 1700               	/* prologue: function */
 1701               	/* frame size = 0 */
 1702               	/* stack size = 2 */
 1703               	.L__stack_usage = 2
 1704 0004 EC01      		movw r28,r24	 ;  2	*movhi/1	[length = 1]
 1705               	.LVL128:
 1706               	.LBB198:
 1707               	.LBB199:
 1708               		.loc 3 189 0
 1709 0006 8889      		ldd r24,Y+16	 ;  7	*movsi/3	[length = 4]
 1710 0008 9989      		ldd r25,Y+17
 1711 000a AA89      		ldd r26,Y+18
 1712 000c BB89      		ldd r27,Y+19
 1713               	.LVL129:
 1714 000e 8C34      		cpi r24,lo8(1397051980)	 ;  8	*cmpsi/4	[length = 7]
 1715 0010 22E5      		ldi r18,hi8(1397051980)
 1716 0012 9207      		cpc r25,r18
 1717 0014 25E4      		ldi r18,hlo8(1397051980)
 1718 0016 A207      		cpc r26,r18
 1719 0018 23E5      		ldi r18,hhi8(1397051980)
 1720 001a B207      		cpc r27,r18
 1721 001c 01F0      		breq .L80	 ;  9	branch	[length = 1]
 1722 001e 80E0      		ldi r24,lo8(__c.1642)	 ;  14	*movhi/4	[length = 2]
 1723 0020 90E0      		ldi r25,hi8(__c.1642)
 1724 0022 60E0      		ldi r22,lo8(__c.1644)	 ;  15	*movhi/4	[length = 2]
 1725 0024 70E0      		ldi r23,hi8(__c.1644)
 1726 0026 4DEB      		ldi r20,lo8(189)	 ;  16	*movhi/4	[length = 2]
 1727 0028 50E0      		ldi r21,hi8(189)
 1728 002a 0E94 0000 		call __bassert_P	 ;  17	call_value_insn/3	[length = 2]
 1729               	.LVL130:
 1730               	.L80:
 1731               	.LBE199:
 1732               	.LBE198:
 412:bertos/drv/ser.c **** 	ser_close(fd);
 1733               		.loc 1 412 0
 1734 002e CE01      		movw r24,r28	 ;  22	*movhi/1	[length = 1]
 1735 0030 0E94 0000 		call ser_close	 ;  23	call_value_insn/3	[length = 2]
 413:bertos/drv/ser.c **** 	ser_open(fds, fds->unit);
 1736               		.loc 1 413 0
 1737 0034 6C8D      		ldd r22,Y+28	 ;  25	*movhi/2	[length = 2]
 1738 0036 7D8D      		ldd r23,Y+29
 1739 0038 CE01      		movw r24,r28	 ;  26	*movhi/1	[length = 1]
 1740 003a 0E94 0000 		call ser_open	 ;  28	call_value_insn/3	[length = 2]
 415:bertos/drv/ser.c **** }
 1741               		.loc 1 415 0
 1742 003e CE01      		movw r24,r28	 ;  57	*movhi/1	[length = 1]
 1743               	/* epilogue start */
 1744 0040 DF91      		pop r29	 ;  53	popqi	[length = 1]
 1745 0042 CF91      		pop r28	 ;  54	popqi	[length = 1]
 1746               	.LVL131:
 1747 0044 0895      		ret	 ;  55	return_from_epilogue	[length = 1]
 1748               		.cfi_endproc
 1749               	.LFE64:
 1751               		.section	.text.ser_init,"ax",@progbits
 1752               	.global	ser_init
 1754               	ser_init:
 1755               	.LFB65:
 423:bertos/drv/ser.c **** {
 1756               		.loc 1 423 0
 1757               		.cfi_startproc
 1758               	.LVL132:
 1759               	/* prologue: function */
 1760               	/* frame size = 0 */
 1761               	/* stack size = 0 */
 1762               	.L__stack_usage = 0
 1763 0000 FC01      		movw r30,r24	 ;  2	*movhi/1	[length = 1]
 424:bertos/drv/ser.c **** 	memset(fds, 0, sizeof(*fds));
 1764               		.loc 1 424 0
 1765 0002 82E3      		ldi r24,lo8(50)	 ;  7	*movqi/2	[length = 1]
 1766               	.LVL133:
 1767 0004 DF01      		movw r26,r30	 ;  34	*movhi/1	[length = 1]
 1768 0006 1D92      		st X+,__zero_reg__	 ;  9	*clrmemqi	[length = 3]
 1769 0008 8A95      	        dec r24
 1770 000a 01F4      		brne .-6
 426:bertos/drv/ser.c **** 	DB(fds->fd._type = KFT_SERIAL);
 1771               		.loc 1 426 0
 1772 000c 8CE4      		ldi r24,lo8(1397051980)	 ;  10	*movsi/5	[length = 4]
 1773 000e 92E5      		ldi r25,hi8(1397051980)
 1774 0010 A5E4      		ldi r26,hlo8(1397051980)
 1775 0012 B3E5      		ldi r27,hhi8(1397051980)
 1776 0014 808B      		std Z+16,r24	 ;  11	*movsi/4	[length = 4]
 1777 0016 918B      		std Z+17,r25
 1778 0018 A28B      		std Z+18,r26
 1779 001a B38B      		std Z+19,r27
 427:bertos/drv/ser.c **** 	fds->fd.reopen = ser_reopen;
 1780               		.loc 1 427 0
 1781 001c 80E0      		ldi r24,lo8(gs(ser_reopen))	 ;  12	*movhi/4	[length = 2]
 1782 001e 90E0      		ldi r25,hi8(gs(ser_reopen))
 1783 0020 9583      		std Z+5,r25	 ;  13	*movhi/3	[length = 2]
 1784 0022 8483      		std Z+4,r24
 428:bertos/drv/ser.c **** 	fds->fd.close = ser_close;
 1785               		.loc 1 428 0
 1786 0024 80E0      		ldi r24,lo8(gs(ser_close))	 ;  14	*movhi/4	[length = 2]
 1787 0026 90E0      		ldi r25,hi8(gs(ser_close))
 1788 0028 9783      		std Z+7,r25	 ;  15	*movhi/3	[length = 2]
 1789 002a 8683      		std Z+6,r24
 429:bertos/drv/ser.c **** 	fds->fd.read = ser_read;
 1790               		.loc 1 429 0
 1791 002c 80E0      		ldi r24,lo8(gs(ser_read))	 ;  16	*movhi/4	[length = 2]
 1792 002e 90E0      		ldi r25,hi8(gs(ser_read))
 1793 0030 9183      		std Z+1,r25	 ;  17	*movhi/3	[length = 2]
 1794 0032 8083      		st Z,r24
 430:bertos/drv/ser.c **** 	fds->fd.write = ser_write;
 1795               		.loc 1 430 0
 1796 0034 80E0      		ldi r24,lo8(gs(ser_write))	 ;  18	*movhi/4	[length = 2]
 1797 0036 90E0      		ldi r25,hi8(gs(ser_write))
 1798 0038 9383      		std Z+3,r25	 ;  19	*movhi/3	[length = 2]
 1799 003a 8283      		std Z+2,r24
 431:bertos/drv/ser.c **** 	fds->fd.flush = ser_flush;
 1800               		.loc 1 431 0
 1801 003c 80E0      		ldi r24,lo8(gs(ser_flush))	 ;  20	*movhi/4	[length = 2]
 1802 003e 90E0      		ldi r25,hi8(gs(ser_flush))
 1803 0040 9387      		std Z+11,r25	 ;  21	*movhi/3	[length = 2]
 1804 0042 8287      		std Z+10,r24
 432:bertos/drv/ser.c **** 	fds->fd.error = ser_error;
 1805               		.loc 1 432 0
 1806 0044 80E0      		ldi r24,lo8(gs(ser_error))	 ;  22	*movhi/4	[length = 2]
 1807 0046 90E0      		ldi r25,hi8(gs(ser_error))
 1808 0048 9587      		std Z+13,r25	 ;  23	*movhi/3	[length = 2]
 1809 004a 8487      		std Z+12,r24
 433:bertos/drv/ser.c **** 	fds->fd.clearerr = ser_clearerr;
 1810               		.loc 1 433 0
 1811 004c 80E0      		ldi r24,lo8(gs(ser_clearerr))	 ;  24	*movhi/4	[length = 2]
 1812 004e 90E0      		ldi r25,hi8(gs(ser_clearerr))
 1813 0050 9787      		std Z+15,r25	 ;  25	*movhi/3	[length = 2]
 1814 0052 8687      		std Z+14,r24
 434:bertos/drv/ser.c **** 	ser_open(fds, unit);
 1815               		.loc 1 434 0
 1816 0054 CF01      		movw r24,r30	 ;  27	*movhi/1	[length = 1]
 1817 0056 0E94 0000 		call ser_open	 ;  29	call_value_insn/3	[length = 2]
 1818               	.LVL134:
 1819               	/* epilogue start */
 435:bertos/drv/ser.c **** }
 1820               		.loc 1 435 0
 1821 005a 0895      		ret	 ;  37	return	[length = 1]
 1822               		.cfi_endproc
 1823               	.LFE65:
 1825               		.section	.text.spimaster_init,"ax",@progbits
 1826               	.global	spimaster_init
 1828               	spimaster_init:
 1829               	.LFB68:
 482:bertos/drv/ser.c **** 
 483:bertos/drv/ser.c **** 
 484:bertos/drv/ser.c **** /**
 485:bertos/drv/ser.c ****  * Init SPI serial driver \a unit in master mode.
 486:bertos/drv/ser.c ****  *
 487:bertos/drv/ser.c ****  * Use SER_SPIn for \a unit parameter.
 488:bertos/drv/ser.c ****  *
 489:bertos/drv/ser.c ****  * This interface implements the SPI master protocol over a serial SPI
 490:bertos/drv/ser.c ****  * driver. This is needed because normal serial driver send/receive data
 491:bertos/drv/ser.c ****  * at the same time. SPI slaves like memories and other peripherals
 492:bertos/drv/ser.c ****  * first receive and *then* send response back instead.
 493:bertos/drv/ser.c ****  * To achieve this, when we are master and we are *sending*,
 494:bertos/drv/ser.c ****  * we have to discard all incoming data. Then, when we want to
 495:bertos/drv/ser.c ****  * receive, we must write fake data to SPI to trigger slave devices.
 496:bertos/drv/ser.c ****  */
 497:bertos/drv/ser.c **** void spimaster_init(Serial *fds, unsigned int unit)
 498:bertos/drv/ser.c **** {
 1830               		.loc 1 498 0
 1831               		.cfi_startproc
 1832               	.LVL135:
 1833 0000 CF93      		push r28	 ;  19	*pushqi/1	[length = 1]
 1834               	.LCFI49:
 1835               		.cfi_def_cfa_offset 3
 1836               		.cfi_offset 28, -2
 1837 0002 DF93      		push r29	 ;  20	*pushqi/1	[length = 1]
 1838               	.LCFI50:
 1839               		.cfi_def_cfa_offset 4
 1840               		.cfi_offset 29, -3
 1841               	/* prologue: function */
 1842               	/* frame size = 0 */
 1843               	/* stack size = 2 */
 1844               	.L__stack_usage = 2
 1845 0004 EC01      		movw r28,r24	 ;  2	*movhi/1	[length = 1]
 499:bertos/drv/ser.c **** 	ser_init(fds, unit);
 1846               		.loc 1 499 0
 1847 0006 0E94 0000 		call ser_init	 ;  10	call_insn/3	[length = 2]
 1848               	.LVL136:
 500:bertos/drv/ser.c **** 	fds->fd.read = spimaster_read;
 1849               		.loc 1 500 0
 1850 000a 80E0      		ldi r24,lo8(gs(spimaster_read))	 ;  11	*movhi/4	[length = 2]
 1851 000c 90E0      		ldi r25,hi8(gs(spimaster_read))
 1852 000e 9983      		std Y+1,r25	 ;  12	*movhi/3	[length = 2]
 1853 0010 8883      		st Y,r24
 501:bertos/drv/ser.c **** 	fds->fd.write = spimaster_write;
 1854               		.loc 1 501 0
 1855 0012 80E0      		ldi r24,lo8(gs(spimaster_write))	 ;  13	*movhi/4	[length = 2]
 1856 0014 90E0      		ldi r25,hi8(gs(spimaster_write))
 1857 0016 9B83      		std Y+3,r25	 ;  14	*movhi/3	[length = 2]
 1858 0018 8A83      		std Y+2,r24
 1859               	/* epilogue start */
 502:bertos/drv/ser.c **** }
 1860               		.loc 1 502 0
 1861 001a DF91      		pop r29	 ;  23	popqi	[length = 1]
 1862 001c CF91      		pop r28	 ;  24	popqi	[length = 1]
 1863               	.LVL137:
 1864 001e 0895      		ret	 ;  25	return_from_epilogue	[length = 1]
 1865               		.cfi_endproc
 1866               	.LFE68:
 1868               		.comm ser_handles,4,1
 1869               		.section	.progmem.data,"a",@progbits
 1872               	__c.1642:
 1873 0000 6664 2D3E 		.string	"fd->_type == KFT_SERIAL"
 1873      5F74 7970 
 1873      6520 3D3D 
 1873      204B 4654 
 1873      5F53 4552 
 1876               	__c.1644:
 1877 0018 6265 7274 		.string	"bertos/drv/ser.h"
 1877      6F73 2F64 
 1877      7276 2F73 
 1877      6572 2E68 
 1877      00
 1880               	__c.2071:
 1881 0029 706F 7274 		.string	"port->is_open"
 1881      2D3E 6973 
 1881      5F6F 7065 
 1881      6E00 
 1884               	__c.2073:
 1885 0037 6265 7274 		.string	"bertos/drv/ser.c"
 1885      6F73 2F64 
 1885      7276 2F73 
 1885      6572 2E63 
 1885      00
 1888               	__c.2050:
 1889 0048 756E 6974 		.string	"unit < countof(ser_handles)"
 1889      203C 2063 
 1889      6F75 6E74 
 1889      6F66 2873 
 1889      6572 5F68 
 1892               	__c.2052:
 1893 0064 6265 7274 		.string	"bertos/drv/ser.c"
 1893      6F73 2F64 
 1893      7276 2F73 
 1893      6572 2E63 
 1893      00
 1896               	__c.2054:
 1897 0075 2166 642D 		.string	"!fd->is_open"
 1897      3E69 735F 
 1897      6F70 656E 
 1897      00
 1900               	__c.2056:
 1901 0082 6265 7274 		.string	"bertos/drv/ser.c"
 1901      6F73 2F64 
 1901      7276 2F73 
 1901      6572 2E63 
 1901      00
 1904               	__c.2058:
 1905 0093 6664 2D3E 		.string	"fd->hw->txbuffer"
 1905      6877 2D3E 
 1905      7478 6275 
 1905      6666 6572 
 1905      00
 1908               	__c.2060:
 1909 00a4 6265 7274 		.string	"bertos/drv/ser.c"
 1909      6F73 2F64 
 1909      7276 2F73 
 1909      6572 2E63 
 1909      00
 1912               	__c.2062:
 1913 00b5 6664 2D3E 		.string	"fd->hw->rxbuffer"
 1913      6877 2D3E 
 1913      7278 6275 
 1913      6666 6572 
 1913      00
 1916               	__c.2064:
 1917 00c6 6265 7274 		.string	"bertos/drv/ser.c"
 1917      6F73 2F64 
 1917      7276 2F73 
 1917      6572 2E63 
 1917      00
 1920               	__c.1616:
 1921 00d7 7369 7A65 		.string	"size > 1"
 1921      203E 2031 
 1921      00
 1924               	__c.1618:
 1925 00e0 6265 7274 		.string	"bertos/struct/fifobuf.h"
 1925      6F73 2F73 
 1925      7472 7563 
 1925      742F 6669 
 1925      666F 6275 
 1926               		.text
 1927               	.Letext0:
 1928               		.file 4 "/usr/local/CrossPack-AVR-20121207/lib/gcc/avr/4.6.2/include/stddef.h"
 1929               		.file 5 "/usr/local/CrossPack-AVR-20121207/lib/gcc/avr/4.6.2/../../../../avr/include/stdint.h"
 1930               		.file 6 "bertos/cfg/compiler.h"
 1931               		.file 7 "bertos/cpu/types.h"
 1932               		.file 8 "bertos/cfg/macros.h"
 1933               		.file 9 "bertos/kern/kfile.h"
 1934               		.file 10 "bertos/struct/list.h"
 1935               		.file 11 "bertos/kern/proc.h"
 1936               		.file 12 "bertos/cpu/avr/drv/ser_avr.h"
 1937               		.file 13 "bertos/drv/ser_p.h"
 1938               		.file 14 "bertos/drv/timer.h"
 1939               		.file 15 "bertos/cpu/power.h"
DEFINED SYMBOLS
                            *ABS*:00000000 ser.c
/var/folders/yq/1c5lpctj6dd1dv230ntn69lm0000gn/T//cceC1ZXR.s:2      *ABS*:0000003f __SREG__
/var/folders/yq/1c5lpctj6dd1dv230ntn69lm0000gn/T//cceC1ZXR.s:3      *ABS*:0000003e __SP_H__
/var/folders/yq/1c5lpctj6dd1dv230ntn69lm0000gn/T//cceC1ZXR.s:4      *ABS*:0000003d __SP_L__
/var/folders/yq/1c5lpctj6dd1dv230ntn69lm0000gn/T//cceC1ZXR.s:5      *ABS*:00000034 __CCP__
/var/folders/yq/1c5lpctj6dd1dv230ntn69lm0000gn/T//cceC1ZXR.s:6      *ABS*:00000000 __tmp_reg__
/var/folders/yq/1c5lpctj6dd1dv230ntn69lm0000gn/T//cceC1ZXR.s:7      *ABS*:00000001 __zero_reg__
/var/folders/yq/1c5lpctj6dd1dv230ntn69lm0000gn/T//cceC1ZXR.s:15     .text.ser_putchar:00000000 ser_putchar
/var/folders/yq/1c5lpctj6dd1dv230ntn69lm0000gn/T//cceC1ZXR.s:197    .text.ser_getchar:00000000 ser_getchar
/var/folders/yq/1c5lpctj6dd1dv230ntn69lm0000gn/T//cceC1ZXR.s:350    .text.ser_read:00000000 ser_read
/var/folders/yq/1c5lpctj6dd1dv230ntn69lm0000gn/T//cceC1ZXR.s:1872   .progmem.data:00000000 __c.1642
/var/folders/yq/1c5lpctj6dd1dv230ntn69lm0000gn/T//cceC1ZXR.s:1876   .progmem.data:00000018 __c.1644
/var/folders/yq/1c5lpctj6dd1dv230ntn69lm0000gn/T//cceC1ZXR.s:476    .text.ser_write:00000000 ser_write
/var/folders/yq/1c5lpctj6dd1dv230ntn69lm0000gn/T//cceC1ZXR.s:601    .text.ser_error:00000000 ser_error
/var/folders/yq/1c5lpctj6dd1dv230ntn69lm0000gn/T//cceC1ZXR.s:660    .text.ser_clearerr:00000000 ser_clearerr
/var/folders/yq/1c5lpctj6dd1dv230ntn69lm0000gn/T//cceC1ZXR.s:719    .text.ser_flush:00000000 ser_flush
/var/folders/yq/1c5lpctj6dd1dv230ntn69lm0000gn/T//cceC1ZXR.s:803    .text.ser_open:00000000 ser_open
/var/folders/yq/1c5lpctj6dd1dv230ntn69lm0000gn/T//cceC1ZXR.s:1888   .progmem.data:00000048 __c.2050
/var/folders/yq/1c5lpctj6dd1dv230ntn69lm0000gn/T//cceC1ZXR.s:1892   .progmem.data:00000064 __c.2052
                            *COM*:00000004 ser_handles
/var/folders/yq/1c5lpctj6dd1dv230ntn69lm0000gn/T//cceC1ZXR.s:1896   .progmem.data:00000075 __c.2054
/var/folders/yq/1c5lpctj6dd1dv230ntn69lm0000gn/T//cceC1ZXR.s:1900   .progmem.data:00000082 __c.2056
/var/folders/yq/1c5lpctj6dd1dv230ntn69lm0000gn/T//cceC1ZXR.s:1904   .progmem.data:00000093 __c.2058
/var/folders/yq/1c5lpctj6dd1dv230ntn69lm0000gn/T//cceC1ZXR.s:1908   .progmem.data:000000a4 __c.2060
/var/folders/yq/1c5lpctj6dd1dv230ntn69lm0000gn/T//cceC1ZXR.s:1912   .progmem.data:000000b5 __c.2062
/var/folders/yq/1c5lpctj6dd1dv230ntn69lm0000gn/T//cceC1ZXR.s:1916   .progmem.data:000000c6 __c.2064
/var/folders/yq/1c5lpctj6dd1dv230ntn69lm0000gn/T//cceC1ZXR.s:1920   .progmem.data:000000d7 __c.1616
/var/folders/yq/1c5lpctj6dd1dv230ntn69lm0000gn/T//cceC1ZXR.s:1924   .progmem.data:000000e0 __c.1618
/var/folders/yq/1c5lpctj6dd1dv230ntn69lm0000gn/T//cceC1ZXR.s:1055   .text.ser_getchar_nowait:00000000 ser_getchar_nowait
/var/folders/yq/1c5lpctj6dd1dv230ntn69lm0000gn/T//cceC1ZXR.s:1165   .text.ser_setbaudrate:00000000 ser_setbaudrate
/var/folders/yq/1c5lpctj6dd1dv230ntn69lm0000gn/T//cceC1ZXR.s:1199   .text.ser_setparity:00000000 ser_setparity
/var/folders/yq/1c5lpctj6dd1dv230ntn69lm0000gn/T//cceC1ZXR.s:1233   .text.ser_purgeRx:00000000 ser_purgeRx
/var/folders/yq/1c5lpctj6dd1dv230ntn69lm0000gn/T//cceC1ZXR.s:1280   .text.spimaster_write:00000000 spimaster_write
/var/folders/yq/1c5lpctj6dd1dv230ntn69lm0000gn/T//cceC1ZXR.s:1370   .text.spimaster_read:00000000 spimaster_read
/var/folders/yq/1c5lpctj6dd1dv230ntn69lm0000gn/T//cceC1ZXR.s:1511   .text.ser_purgeTx:00000000 ser_purgeTx
/var/folders/yq/1c5lpctj6dd1dv230ntn69lm0000gn/T//cceC1ZXR.s:1559   .text.ser_purge:00000000 ser_purge
/var/folders/yq/1c5lpctj6dd1dv230ntn69lm0000gn/T//cceC1ZXR.s:1594   .text.ser_close:00000000 ser_close
/var/folders/yq/1c5lpctj6dd1dv230ntn69lm0000gn/T//cceC1ZXR.s:1880   .progmem.data:00000029 __c.2071
/var/folders/yq/1c5lpctj6dd1dv230ntn69lm0000gn/T//cceC1ZXR.s:1884   .progmem.data:00000037 __c.2073
/var/folders/yq/1c5lpctj6dd1dv230ntn69lm0000gn/T//cceC1ZXR.s:1687   .text.ser_reopen:00000000 ser_reopen
/var/folders/yq/1c5lpctj6dd1dv230ntn69lm0000gn/T//cceC1ZXR.s:1754   .text.ser_init:00000000 ser_init
/var/folders/yq/1c5lpctj6dd1dv230ntn69lm0000gn/T//cceC1ZXR.s:1828   .text.spimaster_init:00000000 spimaster_init

UNDEFINED SYMBOLS
__do_copy_data
__do_clear_bss
__bassert_P
ser_hw_getdesc
