   1               		.file	"timer.c"
   2               	__SREG__ = 0x3f
   3               	__SP_H__ = 0x3e
   4               	__SP_L__ = 0x3d
   5               	__CCP__ = 0x34
   6               	__tmp_reg__ = 0
   7               	__zero_reg__ = 1
   8               		.global __do_copy_data
   9               		.global __do_clear_bss
  10               		.text
  11               	.Ltext0:
  12               		.cfi_sections	.debug_frame
  13               		.section	.text.timer_add,"ax",@progbits
  14               	.global	timer_add
  16               	timer_add:
  17               	.LFB29:
  18               		.file 1 "bertos/drv/timer.c"
   1:bertos/drv/timer.c **** /**
   2:bertos/drv/timer.c ****  * \file
   3:bertos/drv/timer.c ****  * <!--
   4:bertos/drv/timer.c ****  * This file is part of BeRTOS.
   5:bertos/drv/timer.c ****  *
   6:bertos/drv/timer.c ****  * Bertos is free software; you can redistribute it and/or modify
   7:bertos/drv/timer.c ****  * it under the terms of the GNU General Public License as published by
   8:bertos/drv/timer.c ****  * the Free Software Foundation; either version 2 of the License, or
   9:bertos/drv/timer.c ****  * (at your option) any later version.
  10:bertos/drv/timer.c ****  *
  11:bertos/drv/timer.c ****  * This program is distributed in the hope that it will be useful,
  12:bertos/drv/timer.c ****  * but WITHOUT ANY WARRANTY; without even the implied warranty of
  13:bertos/drv/timer.c ****  * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
  14:bertos/drv/timer.c ****  * GNU General Public License for more details.
  15:bertos/drv/timer.c ****  *
  16:bertos/drv/timer.c ****  * You should have received a copy of the GNU General Public License
  17:bertos/drv/timer.c ****  * along with this program; if not, write to the Free Software
  18:bertos/drv/timer.c ****  * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
  19:bertos/drv/timer.c ****  *
  20:bertos/drv/timer.c ****  * As a special exception, you may use this file as part of a free software
  21:bertos/drv/timer.c ****  * library without restriction.  Specifically, if other files instantiate
  22:bertos/drv/timer.c ****  * templates or use macros or inline functions from this file, or you compile
  23:bertos/drv/timer.c ****  * this file and link it with other files to produce an executable, this
  24:bertos/drv/timer.c ****  * file does not by itself cause the resulting executable to be covered by
  25:bertos/drv/timer.c ****  * the GNU General Public License.  This exception does not however
  26:bertos/drv/timer.c ****  * invalidate any other reasons why the executable file might be covered by
  27:bertos/drv/timer.c ****  * the GNU General Public License.
  28:bertos/drv/timer.c ****  *
  29:bertos/drv/timer.c ****  * Copyright 2003, 2004, 2005, 2006 Develer S.r.l. (http://www.develer.com/)
  30:bertos/drv/timer.c ****  * Copyright 2000, 2008 Bernie Innocenti <bernie@codewiz.org>
  31:bertos/drv/timer.c ****  * -->
  32:bertos/drv/timer.c ****  *
  33:bertos/drv/timer.c ****  * \brief Hardware independent timer driver (implementation)
  34:bertos/drv/timer.c ****  *
  35:bertos/drv/timer.c ****  * \author Bernie Innocenti <bernie@codewiz.org>
  36:bertos/drv/timer.c ****  * \author Francesco Sacchi <batt@develer.com>
  37:bertos/drv/timer.c ****  */
  38:bertos/drv/timer.c **** 
  39:bertos/drv/timer.c **** #include "timer.h"
  40:bertos/drv/timer.c **** #include "hw/hw_timer.h"
  41:bertos/drv/timer.c **** 
  42:bertos/drv/timer.c **** #include "cfg/cfg_timer.h"
  43:bertos/drv/timer.c **** #include "cfg/cfg_wdt.h"
  44:bertos/drv/timer.c **** #include "cfg/cfg_proc.h"
  45:bertos/drv/timer.c **** #include "cfg/cfg_signal.h"
  46:bertos/drv/timer.c **** #include <cfg/os.h>
  47:bertos/drv/timer.c **** #include <cfg/debug.h>
  48:bertos/drv/timer.c **** #include <cfg/module.h>
  49:bertos/drv/timer.c **** 
  50:bertos/drv/timer.c **** #include <cpu/attr.h>
  51:bertos/drv/timer.c **** #include <cpu/types.h>
  52:bertos/drv/timer.c **** #include <cpu/irq.h>
  53:bertos/drv/timer.c **** #include <cpu/power.h> // cpu_relax()
  54:bertos/drv/timer.c **** 
  55:bertos/drv/timer.c **** #include <kern/proc_p.h> // proc_decQuantun()
  56:bertos/drv/timer.c **** 
  57:bertos/drv/timer.c **** /*
  58:bertos/drv/timer.c ****  * Include platform-specific binding code if we're hosted.
  59:bertos/drv/timer.c ****  * Try the CPU specific one for bare-metal environments.
  60:bertos/drv/timer.c ****  */
  61:bertos/drv/timer.c **** #if OS_HOSTED
  62:bertos/drv/timer.c **** 	//#include OS_CSOURCE(timer)
  63:bertos/drv/timer.c **** 	#include <emul/timer_posix.c>
  64:bertos/drv/timer.c **** #else
  65:bertos/drv/timer.c **** 	#ifndef WIZ_AUTOGEN
  66:bertos/drv/timer.c **** 		#warning Deprecated: now you should include timer_<cpu> directly in the makefile. Remove this lin
  67:bertos/drv/timer.c **** 		#include CPU_CSOURCE(timer)
  68:bertos/drv/timer.c **** 	#endif
  69:bertos/drv/timer.c **** #endif
  70:bertos/drv/timer.c **** 
  71:bertos/drv/timer.c **** /*
  72:bertos/drv/timer.c ****  * Sanity check for config parameters required by this module.
  73:bertos/drv/timer.c ****  */
  74:bertos/drv/timer.c **** #if !defined(CONFIG_KERN) || ((CONFIG_KERN != 0) && CONFIG_KERN != 1)
  75:bertos/drv/timer.c **** 	#error CONFIG_KERN must be set to either 0 or 1 in config.h
  76:bertos/drv/timer.c **** #endif
  77:bertos/drv/timer.c **** #if !defined(CONFIG_WATCHDOG) || ((CONFIG_WATCHDOG != 0) && CONFIG_WATCHDOG != 1)
  78:bertos/drv/timer.c **** 	#error CONFIG_WATCHDOG must be set to either 0 or 1 in config.h
  79:bertos/drv/timer.c **** #endif
  80:bertos/drv/timer.c **** 
  81:bertos/drv/timer.c **** #if CONFIG_WATCHDOG
  82:bertos/drv/timer.c **** 	#include <drv/wdt.h>
  83:bertos/drv/timer.c **** #endif
  84:bertos/drv/timer.c **** 
  85:bertos/drv/timer.c **** #if defined (CONFIG_KERN_SIGNALS) && CONFIG_KERN_SIGNALS
  86:bertos/drv/timer.c **** 	#include <kern/signal.h> /* sig_wait(), sig_check() */
  87:bertos/drv/timer.c **** 	#include <kern/proc.h>   /* proc_current() */
  88:bertos/drv/timer.c **** 	#include <cfg/macros.h>  /* BV() */
  89:bertos/drv/timer.c **** #endif
  90:bertos/drv/timer.c **** 
  91:bertos/drv/timer.c **** 
  92:bertos/drv/timer.c **** /**
  93:bertos/drv/timer.c ****  * \def CONFIG_TIMER_STROBE
  94:bertos/drv/timer.c ****  *
  95:bertos/drv/timer.c ****  * This is a debug facility that can be used to
  96:bertos/drv/timer.c ****  * monitor timer interrupt activity on an external pin.
  97:bertos/drv/timer.c ****  *
  98:bertos/drv/timer.c ****  * To use strobes, redefine the macros TIMER_STROBE_ON,
  99:bertos/drv/timer.c ****  * TIMER_STROBE_OFF and TIMER_STROBE_INIT and set
 100:bertos/drv/timer.c ****  * CONFIG_TIMER_STROBE to 1.
 101:bertos/drv/timer.c ****  */
 102:bertos/drv/timer.c **** #if !defined(CONFIG_TIMER_STROBE) || !CONFIG_TIMER_STROBE
 103:bertos/drv/timer.c **** 	#define TIMER_STROBE_ON    do {/*nop*/} while(0)
 104:bertos/drv/timer.c **** 	#define TIMER_STROBE_OFF   do {/*nop*/} while(0)
 105:bertos/drv/timer.c **** 	#define TIMER_STROBE_INIT  do {/*nop*/} while(0)
 106:bertos/drv/timer.c **** #endif
 107:bertos/drv/timer.c **** 
 108:bertos/drv/timer.c **** 
 109:bertos/drv/timer.c **** /// Master system clock (1 tick accuracy)
 110:bertos/drv/timer.c **** volatile ticks_t _clock;
 111:bertos/drv/timer.c **** 
 112:bertos/drv/timer.c **** 
 113:bertos/drv/timer.c **** #if CONFIG_TIMER_EVENTS
 114:bertos/drv/timer.c **** 
 115:bertos/drv/timer.c **** /**
 116:bertos/drv/timer.c ****  * List of active asynchronous timers.
 117:bertos/drv/timer.c ****  */
 118:bertos/drv/timer.c **** REGISTER static List timers_queue;
 119:bertos/drv/timer.c **** 
 120:bertos/drv/timer.c **** /**
 121:bertos/drv/timer.c ****  * This function really does the job. It adds \a timer to \a queue.
 122:bertos/drv/timer.c ****  * \see timer_add for details.
 123:bertos/drv/timer.c ****  */
 124:bertos/drv/timer.c **** INLINE void timer_addToList(Timer *timer, List *queue)
 125:bertos/drv/timer.c **** {
 126:bertos/drv/timer.c **** 	/* Inserting timers twice causes mayhem. */
 127:bertos/drv/timer.c **** 	ASSERT(timer->magic != TIMER_MAGIC_ACTIVE);
 128:bertos/drv/timer.c **** 	DB(timer->magic = TIMER_MAGIC_ACTIVE;)
 129:bertos/drv/timer.c **** 
 130:bertos/drv/timer.c **** 
 131:bertos/drv/timer.c **** 	/* Calculate expiration time for this timer */
 132:bertos/drv/timer.c **** 	timer->tick = _clock + timer->_delay;
 133:bertos/drv/timer.c **** 
 134:bertos/drv/timer.c **** 	/*
 135:bertos/drv/timer.c **** 	 * Search for the first node whose expiration time is
 136:bertos/drv/timer.c **** 	 * greater than the timer we want to add.
 137:bertos/drv/timer.c **** 	 */
 138:bertos/drv/timer.c **** 	Timer *node = (Timer *)LIST_HEAD(queue);
 139:bertos/drv/timer.c **** 	while (node->link.succ)
 140:bertos/drv/timer.c **** 	{
 141:bertos/drv/timer.c **** 		/*
 142:bertos/drv/timer.c **** 		 * Stop just after the insertion point.
 143:bertos/drv/timer.c **** 		 * (this fancy compare takes care of wrap-arounds).
 144:bertos/drv/timer.c **** 		 */
 145:bertos/drv/timer.c **** 		if (node->tick - timer->tick > 0)
 146:bertos/drv/timer.c **** 			break;
 147:bertos/drv/timer.c **** 
 148:bertos/drv/timer.c **** 		/* Go to next node */
 149:bertos/drv/timer.c **** 		node = (Timer *)node->link.succ;
 150:bertos/drv/timer.c **** 	}
 151:bertos/drv/timer.c **** 
 152:bertos/drv/timer.c **** 	/* Enqueue timer request into the list */
 153:bertos/drv/timer.c **** 	INSERT_BEFORE(&timer->link, &node->link);
 154:bertos/drv/timer.c **** }
 155:bertos/drv/timer.c **** 
 156:bertos/drv/timer.c **** /**
 157:bertos/drv/timer.c ****  * Add the specified timer to the software timer service queue.
 158:bertos/drv/timer.c ****  * When the delay indicated by the timer expires, the timer
 159:bertos/drv/timer.c ****  * device will execute the event associated with it.
 160:bertos/drv/timer.c ****  *
 161:bertos/drv/timer.c ****  * \note Interrupt safe
 162:bertos/drv/timer.c ****  */
 163:bertos/drv/timer.c **** void timer_add(Timer *timer)
 164:bertos/drv/timer.c **** {
  19               		.loc 1 164 0
  20               		.cfi_startproc
  21               	.LVL0:
  22 0000 DF92      		push r13	 ;  99	*pushqi/1	[length = 1]
  23               	.LCFI0:
  24               		.cfi_def_cfa_offset 3
  25               		.cfi_offset 13, -2
  26 0002 EF92      		push r14	 ;  100	*pushqi/1	[length = 1]
  27               	.LCFI1:
  28               		.cfi_def_cfa_offset 4
  29               		.cfi_offset 14, -3
  30 0004 FF92      		push r15	 ;  101	*pushqi/1	[length = 1]
  31               	.LCFI2:
  32               		.cfi_def_cfa_offset 5
  33               		.cfi_offset 15, -4
  34 0006 0F93      		push r16	 ;  102	*pushqi/1	[length = 1]
  35               	.LCFI3:
  36               		.cfi_def_cfa_offset 6
  37               		.cfi_offset 16, -5
  38 0008 1F93      		push r17	 ;  103	*pushqi/1	[length = 1]
  39               	.LCFI4:
  40               		.cfi_def_cfa_offset 7
  41               		.cfi_offset 17, -6
  42 000a CF93      		push r28	 ;  104	*pushqi/1	[length = 1]
  43               	.LCFI5:
  44               		.cfi_def_cfa_offset 8
  45               		.cfi_offset 28, -7
  46 000c DF93      		push r29	 ;  105	*pushqi/1	[length = 1]
  47               	.LCFI6:
  48               		.cfi_def_cfa_offset 9
  49               		.cfi_offset 29, -8
  50               	/* prologue: function */
  51               	/* frame size = 0 */
  52               	/* stack size = 7 */
  53               	.L__stack_usage = 7
  54 000e 7C01      		movw r14,r24	 ;  2	*movhi/1	[length = 1]
  55               	.LBB61:
 165:bertos/drv/timer.c **** 	ATOMIC(timer_addToList(timer, &timers_queue));
  56               		.loc 1 165 0
  57               	/* #APP */
  58               	 ;  165 "bertos/drv/timer.c" 1
  59 0010 DFB6      		in r13,__SREG__
  60 0012 F894      		cli
  61               	 ;  0 "" 2
  62               	.LVL1:
  63               	/* #NOAPP */
  64               	.LBB62:
  65               	.LBB63:
 127:bertos/drv/timer.c **** 	ASSERT(timer->magic != TIMER_MAGIC_ACTIVE);
  66               		.loc 1 127 0
  67 0014 FC01      		movw r30,r24	 ;  95	*movhi/1	[length = 1]
  68 0016 8289      		ldd r24,Z+18	 ;  11	*movhi/2	[length = 2]
  69 0018 9389      		ldd r25,Z+19
  70               	.LVL2:
  71 001a FBEA      		ldi r31,hi8(-21574)	 ;  12	*cmphi/5	[length = 3]
  72 001c 8A3B      		cpi r24,lo8(-21574)
  73 001e 9F07      		cpc r25,r31
  74 0020 01F4      		brne .L2	 ;  13	branch	[length = 1]
  75 0022 80E0      		ldi r24,lo8(__c.1572)	 ;  18	*movhi/4	[length = 2]
  76 0024 90E0      		ldi r25,hi8(__c.1572)
  77 0026 60E0      		ldi r22,lo8(__c.1574)	 ;  19	*movhi/4	[length = 2]
  78 0028 70E0      		ldi r23,hi8(__c.1574)
  79 002a 4FE7      		ldi r20,lo8(127)	 ;  20	*movhi/4	[length = 2]
  80 002c 50E0      		ldi r21,hi8(127)
  81 002e 0E94 0000 		call __bassert_P	 ;  21	call_value_insn/3	[length = 2]
  82               	.LVL3:
  83               	.L2:
 128:bertos/drv/timer.c **** 	DB(timer->magic = TIMER_MAGIC_ACTIVE;)
  84               		.loc 1 128 0
  85 0032 8AEB      		ldi r24,lo8(-21574)	 ;  24	*movhi/4	[length = 2]
  86 0034 9BEA      		ldi r25,hi8(-21574)
  87 0036 F701      		movw r30,r14	 ;  96	*movhi/1	[length = 1]
  88 0038 938B      		std Z+19,r25	 ;  25	*movhi/3	[length = 2]
  89 003a 828B      		std Z+18,r24
 132:bertos/drv/timer.c **** 	timer->tick = _clock + timer->_delay;
  90               		.loc 1 132 0
  91 003c 0091 0000 		lds r16,_clock	 ;  26	*movsi/3	[length = 8]
  92 0040 1091 0000 		lds r17,_clock+1
  93 0044 2091 0000 		lds r18,_clock+2
  94 0048 3091 0000 		lds r19,_clock+3
  95 004c 8481      		ldd r24,Z+4	 ;  27	*movsi/3	[length = 4]
  96 004e 9581      		ldd r25,Z+5
  97 0050 A681      		ldd r26,Z+6
  98 0052 B781      		ldd r27,Z+7
  99 0054 080F      		add r16,r24	 ;  28	addsi3/1	[length = 4]
 100 0056 191F      		adc r17,r25
 101 0058 2A1F      		adc r18,r26
 102 005a 3B1F      		adc r19,r27
 103 005c 0087      		std Z+8,r16	 ;  29	*movsi/4	[length = 4]
 104 005e 1187      		std Z+9,r17
 105 0060 2287      		std Z+10,r18
 106 0062 3387      		std Z+11,r19
 138:bertos/drv/timer.c **** 	Timer *node = (Timer *)LIST_HEAD(queue);
 107               		.loc 1 138 0
 108 0064 C091 0000 		lds r28,timers_queue	 ;  31	*movhi/2	[length = 4]
 109 0068 D091 0000 		lds r29,timers_queue+1
 110               	.LVL4:
 111 006c 00C0      		rjmp .L3	 ;  117	jump	[length = 1]
 112               	.LVL5:
 113               	.L5:
 145:bertos/drv/timer.c **** 		if (node->tick - timer->tick > 0)
 114               		.loc 1 145 0
 115 006e 4885      		ldd r20,Y+8	 ;  36	*movsi/3	[length = 4]
 116 0070 5985      		ldd r21,Y+9
 117 0072 6A85      		ldd r22,Y+10
 118 0074 7B85      		ldd r23,Y+11
 119 0076 401B      		sub r20,r16	 ;  37	subsi3/1	[length = 4]
 120 0078 510B      		sbc r21,r17
 121 007a 620B      		sbc r22,r18
 122 007c 730B      		sbc r23,r19
 123 007e 1416      		cp __zero_reg__,r20	 ;  38	*reversed_tstsi	[length = 4]
 124 0080 1506      		cpc __zero_reg__,r21
 125 0082 1606      		cpc __zero_reg__,r22
 126 0084 1706      		cpc __zero_reg__,r23
 127 0086 04F0      		brlt .L4	 ;  39	branch	[length = 1]
 128 0088 EC01      		movw r28,r24	 ;  4	*movhi/1	[length = 1]
 129               	.LVL6:
 130               	.L3:
 139:bertos/drv/timer.c **** 	while (node->link.succ)
 131               		.loc 1 139 0
 132 008a 8881      		ld r24,Y	 ;  43	*movhi/2	[length = 2]
 133 008c 9981      		ldd r25,Y+1
 134 008e 0097      		sbiw r24,0	 ;  45	*cmphi/1	[length = 1]
 135 0090 01F4      		brne .L5	 ;  46	branch	[length = 1]
 136               	.L4:
 153:bertos/drv/timer.c **** 	INSERT_BEFORE(&timer->link, &node->link);
 137               		.loc 1 153 0
 138 0092 FFEF      		ldi r31,lo8(255)	 ;  50	*cmphi/6	[length = 3]
 139 0094 EF16      		cp r14,r31
 140 0096 F104      		cpc r15,__zero_reg__
 141 0098 01F0      		breq .+2	 ;  51	difficult_branch	[length = 2]
 142 009a 00F4      		brsh .L6
 143 009c C701      		movw r24,r14	 ;  56	*movhi/1	[length = 1]
 144 009e 60E0      		ldi r22,lo8(__c.1580)	 ;  57	*movhi/4	[length = 2]
 145 00a0 70E0      		ldi r23,hi8(__c.1580)
 146 00a2 40E0      		ldi r20,lo8(__c.1582)	 ;  58	*movhi/4	[length = 2]
 147 00a4 50E0      		ldi r21,hi8(__c.1582)
 148 00a6 29E9      		ldi r18,lo8(153)	 ;  59	*movhi/4	[length = 2]
 149 00a8 30E0      		ldi r19,hi8(153)
 150 00aa 0E94 0000 		call __invalid_ptr_P	 ;  60	call_value_insn/3	[length = 2]
 151               	.L6:
 152 00ae CF3F      		cpi r28,255	 ;  64	*cmphi/4	[length = 2]
 153 00b0 D105      		cpc r29,__zero_reg__
 154 00b2 01F0      		breq .+2	 ;  65	difficult_branch	[length = 2]
 155 00b4 00F4      		brsh .L7
 156 00b6 CE01      		movw r24,r28	 ;  70	*movhi/1	[length = 1]
 157 00b8 60E0      		ldi r22,lo8(__c.1584)	 ;  71	*movhi/4	[length = 2]
 158 00ba 70E0      		ldi r23,hi8(__c.1584)
 159 00bc 40E0      		ldi r20,lo8(__c.1586)	 ;  72	*movhi/4	[length = 2]
 160 00be 50E0      		ldi r21,hi8(__c.1586)
 161 00c0 29E9      		ldi r18,lo8(153)	 ;  73	*movhi/4	[length = 2]
 162 00c2 30E0      		ldi r19,hi8(153)
 163 00c4 0E94 0000 		call __invalid_ptr_P	 ;  74	call_value_insn/3	[length = 2]
 164               	.L7:
 165 00c8 F701      		movw r30,r14	 ;  98	*movhi/1	[length = 1]
 166 00ca D183      		std Z+1,r29	 ;  77	*movhi/3	[length = 2]
 167 00cc C083      		st Z,r28
 168 00ce 8A81      		ldd r24,Y+2	 ;  78	*movhi/2	[length = 2]
 169 00d0 9B81      		ldd r25,Y+3
 170 00d2 9383      		std Z+3,r25	 ;  79	*movhi/3	[length = 2]
 171 00d4 8283      		std Z+2,r24
 172 00d6 EA81      		ldd r30,Y+2	 ;  80	*movhi/2	[length = 2]
 173 00d8 FB81      		ldd r31,Y+3
 174 00da F182      		std Z+1,r15	 ;  81	*movhi/3	[length = 2]
 175 00dc E082      		st Z,r14
 176 00de FB82      		std Y+3,r15	 ;  82	*movhi/3	[length = 2]
 177 00e0 EA82      		std Y+2,r14
 178               	.LBE63:
 179               	.LBE62:
 180               		.loc 1 165 0
 181               	/* #APP */
 182               	 ;  165 "bertos/drv/timer.c" 1
 183 00e2 DFBE      		out __SREG__,r13
 184               	 ;  0 "" 2
 185               	/* epilogue start */
 186               	/* #NOAPP */
 187               	.LBE61:
 166:bertos/drv/timer.c **** }
 188               		.loc 1 166 0
 189 00e4 DF91      		pop r29	 ;  108	popqi	[length = 1]
 190 00e6 CF91      		pop r28	 ;  109	popqi	[length = 1]
 191               	.LVL7:
 192 00e8 1F91      		pop r17	 ;  110	popqi	[length = 1]
 193 00ea 0F91      		pop r16	 ;  111	popqi	[length = 1]
 194 00ec FF90      		pop r15	 ;  112	popqi	[length = 1]
 195 00ee EF90      		pop r14	 ;  113	popqi	[length = 1]
 196               	.LVL8:
 197 00f0 DF90      		pop r13	 ;  114	popqi	[length = 1]
 198               	.LVL9:
 199 00f2 0895      		ret	 ;  115	return_from_epilogue	[length = 1]
 200               		.cfi_endproc
 201               	.LFE29:
 203               		.section	.text.timer_abort,"ax",@progbits
 204               	.global	timer_abort
 206               	timer_abort:
 207               	.LFB30:
 167:bertos/drv/timer.c **** 
 168:bertos/drv/timer.c **** /**
 169:bertos/drv/timer.c ****  * Remove a timer from the timers queue before it has expired.
 170:bertos/drv/timer.c ****  *
 171:bertos/drv/timer.c ****  * \note Attempting to remove a timer already expired cause
 172:bertos/drv/timer.c ****  *       undefined behaviour.
 173:bertos/drv/timer.c ****  */
 174:bertos/drv/timer.c **** Timer *timer_abort(Timer *timer)
 175:bertos/drv/timer.c **** {
 208               		.loc 1 175 0
 209               		.cfi_startproc
 210               	.LVL10:
 211 0000 1F93      		push r17	 ;  52	*pushqi/1	[length = 1]
 212               	.LCFI7:
 213               		.cfi_def_cfa_offset 3
 214               		.cfi_offset 17, -2
 215 0002 CF93      		push r28	 ;  53	*pushqi/1	[length = 1]
 216               	.LCFI8:
 217               		.cfi_def_cfa_offset 4
 218               		.cfi_offset 28, -3
 219 0004 DF93      		push r29	 ;  54	*pushqi/1	[length = 1]
 220               	.LCFI9:
 221               		.cfi_def_cfa_offset 5
 222               		.cfi_offset 29, -4
 223               	/* prologue: function */
 224               	/* frame size = 0 */
 225               	/* stack size = 3 */
 226               	.L__stack_usage = 3
 227 0006 EC01      		movw r28,r24	 ;  2	*movhi/1	[length = 1]
 228               	.LBB64:
 176:bertos/drv/timer.c **** 	ATOMIC(REMOVE(&timer->link));
 229               		.loc 1 176 0
 230               	/* #APP */
 231               	 ;  176 "bertos/drv/timer.c" 1
 232 0008 1FB7      		in r17,__SREG__
 233 000a F894      		cli
 234               	 ;  0 "" 2
 235               	.LVL11:
 236               	/* #NOAPP */
 237 000c 8F3F      		cpi r24,255	 ;  10	*cmphi/4	[length = 2]
 238 000e 9105      		cpc r25,__zero_reg__
 239 0010 01F0      		breq .+2	 ;  11	difficult_branch	[length = 2]
 240 0012 00F4      		brsh .L9
 241               		.loc 1 176 0 is_stmt 0 discriminator 1
 242 0014 60E0      		ldi r22,lo8(__c.1596)	 ;  17	*movhi/4	[length = 2]
 243 0016 70E0      		ldi r23,hi8(__c.1596)
 244 0018 40E0      		ldi r20,lo8(__c.1598)	 ;  18	*movhi/4	[length = 2]
 245 001a 50E0      		ldi r21,hi8(__c.1598)
 246 001c 20EB      		ldi r18,lo8(176)	 ;  19	*movhi/4	[length = 2]
 247 001e 30E0      		ldi r19,hi8(176)
 248 0020 0E94 0000 		call __invalid_ptr_P	 ;  20	call_value_insn/3	[length = 2]
 249               	.LVL12:
 250               	.L9:
 251               		.loc 1 176 0 discriminator 3
 252 0024 EA81      		ldd r30,Y+2	 ;  23	*movhi/2	[length = 2]
 253 0026 FB81      		ldd r31,Y+3
 254 0028 8881      		ld r24,Y	 ;  24	*movhi/2	[length = 2]
 255 002a 9981      		ldd r25,Y+1
 256 002c 9183      		std Z+1,r25	 ;  25	*movhi/3	[length = 2]
 257 002e 8083      		st Z,r24
 258 0030 E881      		ld r30,Y	 ;  26	*movhi/2	[length = 2]
 259 0032 F981      		ldd r31,Y+1
 260 0034 8A81      		ldd r24,Y+2	 ;  27	*movhi/2	[length = 2]
 261 0036 9B81      		ldd r25,Y+3
 262 0038 9383      		std Z+3,r25	 ;  28	*movhi/3	[length = 2]
 263 003a 8283      		std Z+2,r24
 264 003c 1B82      		std Y+3,__zero_reg__	 ;  29	*movhi/3	[length = 2]
 265 003e 1A82      		std Y+2,__zero_reg__
 266 0040 1982      		std Y+1,__zero_reg__	 ;  30	*movhi/3	[length = 2]
 267 0042 1882      		st Y,__zero_reg__
 268               	/* #APP */
 269               	 ;  176 "bertos/drv/timer.c" 1
 270 0044 1FBF      		out __SREG__,r17
 271               	 ;  0 "" 2
 272               	/* #NOAPP */
 273               	.LBE64:
 177:bertos/drv/timer.c **** 	DB(timer->magic = TIMER_MAGIC_INACTIVE;)
 274               		.loc 1 177 0 is_stmt 1 discriminator 3
 275 0046 8BEA      		ldi r24,lo8(-17749)	 ;  32	*movhi/4	[length = 2]
 276 0048 9AEB      		ldi r25,hi8(-17749)
 277 004a 9B8B      		std Y+19,r25	 ;  33	*movhi/3	[length = 2]
 278 004c 8A8B      		std Y+18,r24
 178:bertos/drv/timer.c **** 
 179:bertos/drv/timer.c **** 	return timer;
 180:bertos/drv/timer.c **** }
 279               		.loc 1 180 0 discriminator 3
 280 004e CE01      		movw r24,r28	 ;  62	*movhi/1	[length = 1]
 281               	/* epilogue start */
 282 0050 DF91      		pop r29	 ;  57	popqi	[length = 1]
 283 0052 CF91      		pop r28	 ;  58	popqi	[length = 1]
 284 0054 1F91      		pop r17	 ;  59	popqi	[length = 1]
 285               	.LVL13:
 286 0056 0895      		ret	 ;  60	return_from_epilogue	[length = 1]
 287               		.cfi_endproc
 288               	.LFE30:
 290               		.section	.text.synctimer_add,"ax",@progbits
 291               	.global	synctimer_add
 293               	synctimer_add:
 294               	.LFB32:
 181:bertos/drv/timer.c **** 
 182:bertos/drv/timer.c **** 
 183:bertos/drv/timer.c **** INLINE void timer_poll(List *queue)
 184:bertos/drv/timer.c **** {
 185:bertos/drv/timer.c **** 	Timer *timer;
 186:bertos/drv/timer.c **** 
 187:bertos/drv/timer.c **** 	/*
 188:bertos/drv/timer.c **** 	 * Check the first timer request in the list and process
 189:bertos/drv/timer.c **** 	 * it when it has expired. Repeat this check until the
 190:bertos/drv/timer.c **** 	 * first node has not yet expired. Since the list is sorted
 191:bertos/drv/timer.c **** 	 * by expiry time, all the following requests are guaranteed
 192:bertos/drv/timer.c **** 	 * to expire later.
 193:bertos/drv/timer.c **** 	 */
 194:bertos/drv/timer.c **** 	while ((timer = (Timer *)LIST_HEAD(queue))->link.succ)
 195:bertos/drv/timer.c **** 	{
 196:bertos/drv/timer.c **** 		/* This request in list has not yet expired? */
 197:bertos/drv/timer.c **** 		if (timer_clock() - timer->tick < 0)
 198:bertos/drv/timer.c **** 			break;
 199:bertos/drv/timer.c **** 
 200:bertos/drv/timer.c **** 		/* Retreat the expired timer */
 201:bertos/drv/timer.c **** 		REMOVE(&timer->link);
 202:bertos/drv/timer.c **** 		DB(timer->magic = TIMER_MAGIC_INACTIVE;)
 203:bertos/drv/timer.c **** 
 204:bertos/drv/timer.c **** 		/* Execute the associated event */
 205:bertos/drv/timer.c **** 		event_do(&timer->expire);
 206:bertos/drv/timer.c **** 	}
 207:bertos/drv/timer.c **** }
 208:bertos/drv/timer.c **** 
 209:bertos/drv/timer.c **** /**
 210:bertos/drv/timer.c ****  * Add \a timer to \a queue.
 211:bertos/drv/timer.c ****  * \see synctimer_poll() for details.
 212:bertos/drv/timer.c ****  */
 213:bertos/drv/timer.c **** void synctimer_add(Timer *timer, List *queue)
 214:bertos/drv/timer.c **** {
 295               		.loc 1 214 0
 296               		.cfi_startproc
 297               	.LVL14:
 298 0000 EF92      		push r14	 ;  93	*pushqi/1	[length = 1]
 299               	.LCFI10:
 300               		.cfi_def_cfa_offset 3
 301               		.cfi_offset 14, -2
 302 0002 FF92      		push r15	 ;  94	*pushqi/1	[length = 1]
 303               	.LCFI11:
 304               		.cfi_def_cfa_offset 4
 305               		.cfi_offset 15, -3
 306 0004 0F93      		push r16	 ;  95	*pushqi/1	[length = 1]
 307               	.LCFI12:
 308               		.cfi_def_cfa_offset 5
 309               		.cfi_offset 16, -4
 310 0006 1F93      		push r17	 ;  96	*pushqi/1	[length = 1]
 311               	.LCFI13:
 312               		.cfi_def_cfa_offset 6
 313               		.cfi_offset 17, -5
 314 0008 CF93      		push r28	 ;  97	*pushqi/1	[length = 1]
 315               	.LCFI14:
 316               		.cfi_def_cfa_offset 7
 317               		.cfi_offset 28, -6
 318 000a DF93      		push r29	 ;  98	*pushqi/1	[length = 1]
 319               	.LCFI15:
 320               		.cfi_def_cfa_offset 8
 321               		.cfi_offset 29, -7
 322               	/* prologue: function */
 323               	/* frame size = 0 */
 324               	/* stack size = 6 */
 325               	.L__stack_usage = 6
 326 000c 7C01      		movw r14,r24	 ;  2	*movhi/1	[length = 1]
 327 000e EB01      		movw r28,r22	 ;  3	*movhi/1	[length = 1]
 328               	.LVL15:
 329               	.LBB65:
 330               	.LBB66:
 127:bertos/drv/timer.c **** 	ASSERT(timer->magic != TIMER_MAGIC_ACTIVE);
 331               		.loc 1 127 0
 332 0010 FC01      		movw r30,r24	 ;  89	*movhi/1	[length = 1]
 333 0012 8289      		ldd r24,Z+18	 ;  9	*movhi/2	[length = 2]
 334 0014 9389      		ldd r25,Z+19
 335               	.LVL16:
 336 0016 FBEA      		ldi r31,hi8(-21574)	 ;  10	*cmphi/5	[length = 3]
 337 0018 8A3B      		cpi r24,lo8(-21574)
 338 001a 9F07      		cpc r25,r31
 339 001c 01F4      		brne .L11	 ;  11	branch	[length = 1]
 340 001e 80E0      		ldi r24,lo8(__c.1572)	 ;  16	*movhi/4	[length = 2]
 341 0020 90E0      		ldi r25,hi8(__c.1572)
 342 0022 60E0      		ldi r22,lo8(__c.1574)	 ;  17	*movhi/4	[length = 2]
 343 0024 70E0      		ldi r23,hi8(__c.1574)
 344               	.LVL17:
 345 0026 4FE7      		ldi r20,lo8(127)	 ;  18	*movhi/4	[length = 2]
 346 0028 50E0      		ldi r21,hi8(127)
 347 002a 0E94 0000 		call __bassert_P	 ;  19	call_value_insn/3	[length = 2]
 348               	.LVL18:
 349               	.L11:
 128:bertos/drv/timer.c **** 	DB(timer->magic = TIMER_MAGIC_ACTIVE;)
 350               		.loc 1 128 0
 351 002e 8AEB      		ldi r24,lo8(-21574)	 ;  22	*movhi/4	[length = 2]
 352 0030 9BEA      		ldi r25,hi8(-21574)
 353 0032 F701      		movw r30,r14	 ;  90	*movhi/1	[length = 1]
 354 0034 938B      		std Z+19,r25	 ;  23	*movhi/3	[length = 2]
 355 0036 828B      		std Z+18,r24
 132:bertos/drv/timer.c **** 	timer->tick = _clock + timer->_delay;
 356               		.loc 1 132 0
 357 0038 0091 0000 		lds r16,_clock	 ;  24	*movsi/3	[length = 8]
 358 003c 1091 0000 		lds r17,_clock+1
 359 0040 2091 0000 		lds r18,_clock+2
 360 0044 3091 0000 		lds r19,_clock+3
 361 0048 8481      		ldd r24,Z+4	 ;  25	*movsi/3	[length = 4]
 362 004a 9581      		ldd r25,Z+5
 363 004c A681      		ldd r26,Z+6
 364 004e B781      		ldd r27,Z+7
 365 0050 080F      		add r16,r24	 ;  26	addsi3/1	[length = 4]
 366 0052 191F      		adc r17,r25
 367 0054 2A1F      		adc r18,r26
 368 0056 3B1F      		adc r19,r27
 369 0058 0087      		std Z+8,r16	 ;  27	*movsi/4	[length = 4]
 370 005a 1187      		std Z+9,r17
 371 005c 2287      		std Z+10,r18
 372 005e 3387      		std Z+11,r19
 138:bertos/drv/timer.c **** 	Timer *node = (Timer *)LIST_HEAD(queue);
 373               		.loc 1 138 0
 374 0060 0990      		ld __tmp_reg__,Y+	 ;  28	*movhi/2	[length = 3]
 375 0062 D881      		ld r29,Y
 376 0064 C02D      		mov r28,__tmp_reg__
 377               	.LVL19:
 378 0066 00C0      		rjmp .L12	 ;  109	jump	[length = 1]
 379               	.L14:
 145:bertos/drv/timer.c **** 		if (node->tick - timer->tick > 0)
 380               		.loc 1 145 0
 381 0068 4885      		ldd r20,Y+8	 ;  33	*movsi/3	[length = 4]
 382 006a 5985      		ldd r21,Y+9
 383 006c 6A85      		ldd r22,Y+10
 384 006e 7B85      		ldd r23,Y+11
 385 0070 401B      		sub r20,r16	 ;  34	subsi3/1	[length = 4]
 386 0072 510B      		sbc r21,r17
 387 0074 620B      		sbc r22,r18
 388 0076 730B      		sbc r23,r19
 389 0078 1416      		cp __zero_reg__,r20	 ;  35	*reversed_tstsi	[length = 4]
 390 007a 1506      		cpc __zero_reg__,r21
 391 007c 1606      		cpc __zero_reg__,r22
 392 007e 1706      		cpc __zero_reg__,r23
 393 0080 04F0      		brlt .L13	 ;  36	branch	[length = 1]
 394 0082 EC01      		movw r28,r24	 ;  5	*movhi/1	[length = 1]
 395               	.LVL20:
 396               	.L12:
 139:bertos/drv/timer.c **** 	while (node->link.succ)
 397               		.loc 1 139 0
 398 0084 8881      		ld r24,Y	 ;  40	*movhi/2	[length = 2]
 399 0086 9981      		ldd r25,Y+1
 400 0088 0097      		sbiw r24,0	 ;  42	*cmphi/1	[length = 1]
 401 008a 01F4      		brne .L14	 ;  43	branch	[length = 1]
 402               	.L13:
 153:bertos/drv/timer.c **** 	INSERT_BEFORE(&timer->link, &node->link);
 403               		.loc 1 153 0
 404 008c FFEF      		ldi r31,lo8(255)	 ;  47	*cmphi/6	[length = 3]
 405 008e EF16      		cp r14,r31
 406 0090 F104      		cpc r15,__zero_reg__
 407 0092 01F0      		breq .+2	 ;  48	difficult_branch	[length = 2]
 408 0094 00F4      		brsh .L15
 409 0096 C701      		movw r24,r14	 ;  53	*movhi/1	[length = 1]
 410 0098 60E0      		ldi r22,lo8(__c.1580)	 ;  54	*movhi/4	[length = 2]
 411 009a 70E0      		ldi r23,hi8(__c.1580)
 412 009c 40E0      		ldi r20,lo8(__c.1582)	 ;  55	*movhi/4	[length = 2]
 413 009e 50E0      		ldi r21,hi8(__c.1582)
 414 00a0 29E9      		ldi r18,lo8(153)	 ;  56	*movhi/4	[length = 2]
 415 00a2 30E0      		ldi r19,hi8(153)
 416 00a4 0E94 0000 		call __invalid_ptr_P	 ;  57	call_value_insn/3	[length = 2]
 417               	.L15:
 418 00a8 CF3F      		cpi r28,255	 ;  61	*cmphi/4	[length = 2]
 419 00aa D105      		cpc r29,__zero_reg__
 420 00ac 01F0      		breq .+2	 ;  62	difficult_branch	[length = 2]
 421 00ae 00F4      		brsh .L16
 422 00b0 CE01      		movw r24,r28	 ;  67	*movhi/1	[length = 1]
 423 00b2 60E0      		ldi r22,lo8(__c.1584)	 ;  68	*movhi/4	[length = 2]
 424 00b4 70E0      		ldi r23,hi8(__c.1584)
 425 00b6 40E0      		ldi r20,lo8(__c.1586)	 ;  69	*movhi/4	[length = 2]
 426 00b8 50E0      		ldi r21,hi8(__c.1586)
 427 00ba 29E9      		ldi r18,lo8(153)	 ;  70	*movhi/4	[length = 2]
 428 00bc 30E0      		ldi r19,hi8(153)
 429 00be 0E94 0000 		call __invalid_ptr_P	 ;  71	call_value_insn/3	[length = 2]
 430               	.L16:
 431 00c2 F701      		movw r30,r14	 ;  92	*movhi/1	[length = 1]
 432 00c4 D183      		std Z+1,r29	 ;  74	*movhi/3	[length = 2]
 433 00c6 C083      		st Z,r28
 434 00c8 8A81      		ldd r24,Y+2	 ;  75	*movhi/2	[length = 2]
 435 00ca 9B81      		ldd r25,Y+3
 436 00cc 9383      		std Z+3,r25	 ;  76	*movhi/3	[length = 2]
 437 00ce 8283      		std Z+2,r24
 438 00d0 EA81      		ldd r30,Y+2	 ;  77	*movhi/2	[length = 2]
 439 00d2 FB81      		ldd r31,Y+3
 440 00d4 F182      		std Z+1,r15	 ;  78	*movhi/3	[length = 2]
 441 00d6 E082      		st Z,r14
 442 00d8 FB82      		std Y+3,r15	 ;  79	*movhi/3	[length = 2]
 443 00da EA82      		std Y+2,r14
 444               	/* epilogue start */
 445               	.LBE66:
 446               	.LBE65:
 215:bertos/drv/timer.c **** 	timer_addToList(timer, queue);
 216:bertos/drv/timer.c **** }
 447               		.loc 1 216 0
 448 00dc DF91      		pop r29	 ;  101	popqi	[length = 1]
 449 00de CF91      		pop r28	 ;  102	popqi	[length = 1]
 450               	.LVL21:
 451 00e0 1F91      		pop r17	 ;  103	popqi	[length = 1]
 452 00e2 0F91      		pop r16	 ;  104	popqi	[length = 1]
 453 00e4 FF90      		pop r15	 ;  105	popqi	[length = 1]
 454 00e6 EF90      		pop r14	 ;  106	popqi	[length = 1]
 455               	.LVL22:
 456 00e8 0895      		ret	 ;  107	return_from_epilogue	[length = 1]
 457               		.cfi_endproc
 458               	.LFE32:
 460               		.section	.text.synctimer_poll,"ax",@progbits
 461               	.global	synctimer_poll
 463               	synctimer_poll:
 464               	.LFB33:
 217:bertos/drv/timer.c **** 
 218:bertos/drv/timer.c **** /**
 219:bertos/drv/timer.c ****  * Simple synchronous timer based scheduler polling routine.
 220:bertos/drv/timer.c ****  *
 221:bertos/drv/timer.c ****  * Sometimes you would like to have a proper scheduler,
 222:bertos/drv/timer.c ****  * but you can't afford it due to memory constraints.
 223:bertos/drv/timer.c ****  *
 224:bertos/drv/timer.c ****  * This is a simple replacement: you can create events and call
 225:bertos/drv/timer.c ****  * them periodically at specific time intervals.
 226:bertos/drv/timer.c ****  * All you have to do is to set up normal timers, and call synctimer_add()
 227:bertos/drv/timer.c ****  * instead of timer_add() to add the events to your specific queue.
 228:bertos/drv/timer.c ****  * Then, in the main loop or wherever you want, you can call
 229:bertos/drv/timer.c ****  * synctimer_poll() to process expired events. The associated callbacks will be
 230:bertos/drv/timer.c ****  * executed.
 231:bertos/drv/timer.c ****  * As this is done synchronously you don't have to worry about race conditions.
 232:bertos/drv/timer.c ****  * You can kill an event by simply calling synctimer_abort().
 233:bertos/drv/timer.c ****  *
 234:bertos/drv/timer.c ****  */
 235:bertos/drv/timer.c **** void synctimer_poll(List *queue)
 236:bertos/drv/timer.c **** {
 465               		.loc 1 236 0
 466               		.cfi_startproc
 467               	.LVL23:
 468 0000 EF92      		push r14	 ;  72	*pushqi/1	[length = 1]
 469               	.LCFI16:
 470               		.cfi_def_cfa_offset 3
 471               		.cfi_offset 14, -2
 472 0002 FF92      		push r15	 ;  73	*pushqi/1	[length = 1]
 473               	.LCFI17:
 474               		.cfi_def_cfa_offset 4
 475               		.cfi_offset 15, -3
 476 0004 0F93      		push r16	 ;  74	*pushqi/1	[length = 1]
 477               	.LCFI18:
 478               		.cfi_def_cfa_offset 5
 479               		.cfi_offset 16, -4
 480 0006 1F93      		push r17	 ;  75	*pushqi/1	[length = 1]
 481               	.LCFI19:
 482               		.cfi_def_cfa_offset 6
 483               		.cfi_offset 17, -5
 484 0008 CF93      		push r28	 ;  76	*pushqi/1	[length = 1]
 485               	.LCFI20:
 486               		.cfi_def_cfa_offset 7
 487               		.cfi_offset 28, -6
 488 000a DF93      		push r29	 ;  77	*pushqi/1	[length = 1]
 489               	.LCFI21:
 490               		.cfi_def_cfa_offset 8
 491               		.cfi_offset 29, -7
 492               	/* prologue: function */
 493               	/* frame size = 0 */
 494               	/* stack size = 6 */
 495               	.L__stack_usage = 6
 496 000c 8C01      		movw r16,r24	 ;  2	*movhi/1	[length = 1]
 497               	.LBB67:
 498               	.LBB68:
 202:bertos/drv/timer.c **** 		DB(timer->magic = TIMER_MAGIC_INACTIVE;)
 499               		.loc 1 202 0
 500 000e 2BEA      		ldi r18,lo8(-17749)	 ;  89	*reload_inhi	[length = 4]
 501 0010 E22E      		mov r14,r18
 502 0012 2AEB      		ldi r18,hi8(-17749)
 503 0014 F22E      		mov r15,r18
 504 0016 00C0      		rjmp .L18	 ;  90	jump	[length = 1]
 505               	.LVL24:
 506               	.L21:
 507               	.LBB69:
 508               	.LBB70:
 509               	.LBB71:
 510               		.file 2 "bertos/drv/timer.h"
   1:bertos/drv/timer.h **** /**
   2:bertos/drv/timer.h ****  * \file
   3:bertos/drv/timer.h ****  * <!--
   4:bertos/drv/timer.h ****  * This file is part of BeRTOS.
   5:bertos/drv/timer.h ****  *
   6:bertos/drv/timer.h ****  * Bertos is free software; you can redistribute it and/or modify
   7:bertos/drv/timer.h ****  * it under the terms of the GNU General Public License as published by
   8:bertos/drv/timer.h ****  * the Free Software Foundation; either version 2 of the License, or
   9:bertos/drv/timer.h ****  * (at your option) any later version.
  10:bertos/drv/timer.h ****  *
  11:bertos/drv/timer.h ****  * This program is distributed in the hope that it will be useful,
  12:bertos/drv/timer.h ****  * but WITHOUT ANY WARRANTY; without even the implied warranty of
  13:bertos/drv/timer.h ****  * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
  14:bertos/drv/timer.h ****  * GNU General Public License for more details.
  15:bertos/drv/timer.h ****  *
  16:bertos/drv/timer.h ****  * You should have received a copy of the GNU General Public License
  17:bertos/drv/timer.h ****  * along with this program; if not, write to the Free Software
  18:bertos/drv/timer.h ****  * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
  19:bertos/drv/timer.h ****  *
  20:bertos/drv/timer.h ****  * As a special exception, you may use this file as part of a free software
  21:bertos/drv/timer.h ****  * library without restriction.  Specifically, if other files instantiate
  22:bertos/drv/timer.h ****  * templates or use macros or inline functions from this file, or you compile
  23:bertos/drv/timer.h ****  * this file and link it with other files to produce an executable, this
  24:bertos/drv/timer.h ****  * file does not by itself cause the resulting executable to be covered by
  25:bertos/drv/timer.h ****  * the GNU General Public License.  This exception does not however
  26:bertos/drv/timer.h ****  * invalidate any other reasons why the executable file might be covered by
  27:bertos/drv/timer.h ****  * the GNU General Public License.
  28:bertos/drv/timer.h ****  *
  29:bertos/drv/timer.h ****  * Copyright 2003, 2004, 2005 Develer S.r.l. (http://www.develer.com/)
  30:bertos/drv/timer.h ****  * Copyright 2000, 2008 Bernie Innocenti <bernie@codewiz.org>
  31:bertos/drv/timer.h ****  * -->
  32:bertos/drv/timer.h ****  *
  33:bertos/drv/timer.h ****  * \brief Hardware independent timer driver.
  34:bertos/drv/timer.h ****  *
  35:bertos/drv/timer.h ****  * All timer related functions are implemented in this module. You have several options to use time
  36:bertos/drv/timer.h ****  * \li simple delay: just use timer_delay() if you want to wait for a few milliseconds;
  37:bertos/drv/timer.h ****  * \li delay with callback: create a timer structure and use timer_setDelay() and timer_setSoftint(
  38:bertos/drv/timer.h ****  * \li delay with signal: same as above but use timer_setSignal() to set specify which signal to se
  39:bertos/drv/timer.h ****  * \li simple synchronous timer based scheduler: use synctimer_add() to schedule an event in a user
  40:bertos/drv/timer.h ****  *
  41:bertos/drv/timer.h ****  * Whenever a timer expires you need to explicitly arm it again with timer_add(). If you want to ab
  42:bertos/drv/timer.h ****  * You can use conversion macros when using msecs to specify the delay.
  43:bertos/drv/timer.h ****  *
  44:bertos/drv/timer.h ****  * \author Bernie Innocenti <bernie@codewiz.org>
  45:bertos/drv/timer.h ****  *
  46:bertos/drv/timer.h ****  * $WIZ$ module_name = "timer"
  47:bertos/drv/timer.h ****  * $WIZ$ module_configuration = "bertos/cfg/cfg_timer.h"
  48:bertos/drv/timer.h ****  * $WIZ$ module_depends = "event", "sysirq"
  49:bertos/drv/timer.h ****  * $WIZ$ module_supports = "not atmega103 and not atmega8"
  50:bertos/drv/timer.h ****  */
  51:bertos/drv/timer.h **** 
  52:bertos/drv/timer.h **** #ifndef DRV_TIMER_H
  53:bertos/drv/timer.h **** #define DRV_TIMER_H
  54:bertos/drv/timer.h **** 
  55:bertos/drv/timer.h **** #include <cfg/os.h>
  56:bertos/drv/timer.h **** #include <cfg/macros.h>
  57:bertos/drv/timer.h **** 
  58:bertos/drv/timer.h **** #include <cpu/attr.h>
  59:bertos/drv/timer.h **** #include <cpu/irq.h>
  60:bertos/drv/timer.h **** 
  61:bertos/drv/timer.h **** 
  62:bertos/drv/timer.h **** /*
  63:bertos/drv/timer.h ****  * Include platform-specific binding header if we're hosted.
  64:bertos/drv/timer.h ****  * Try the CPU specific one for bare-metal environments.
  65:bertos/drv/timer.h ****  */
  66:bertos/drv/timer.h **** #if OS_HOSTED
  67:bertos/drv/timer.h **** 	//#include OS_HEADER(timer)
  68:bertos/drv/timer.h **** 	#include <emul/timer_posix.h>
  69:bertos/drv/timer.h **** #else
  70:bertos/drv/timer.h **** 	#include CPU_HEADER(timer)
  71:bertos/drv/timer.h **** #endif
  72:bertos/drv/timer.h **** 
  73:bertos/drv/timer.h **** STATIC_ASSERT(sizeof(hptime_t) == SIZEOF_HPTIME_T);
  74:bertos/drv/timer.h **** 
  75:bertos/drv/timer.h **** #include "cfg/cfg_timer.h"
  76:bertos/drv/timer.h **** #include <cfg/debug.h>
  77:bertos/drv/timer.h **** #include <cfg/compiler.h>
  78:bertos/drv/timer.h **** 
  79:bertos/drv/timer.h **** #include <struct/list.h>
  80:bertos/drv/timer.h **** 
  81:bertos/drv/timer.h **** /*
  82:bertos/drv/timer.h ****  * Sanity check for config parameters required by this module.
  83:bertos/drv/timer.h ****  */
  84:bertos/drv/timer.h **** #if !defined(CONFIG_TIMER_EVENTS) || ((CONFIG_TIMER_EVENTS != 0) && CONFIG_TIMER_EVENTS != 1)
  85:bertos/drv/timer.h **** 	#error CONFIG_TIMER_EVENTS must be set to either 0 or 1 in cfg_timer.h
  86:bertos/drv/timer.h **** #endif
  87:bertos/drv/timer.h **** #if !defined(CONFIG_TIMER_UDELAY) || ((CONFIG_TIMER_UDELAY != 0) && CONFIG_TIMER_EVENTS != 1)
  88:bertos/drv/timer.h **** 	#error CONFIG_TIMER_UDELAY must be set to either 0 or 1 in cfg_timer.h
  89:bertos/drv/timer.h **** #endif
  90:bertos/drv/timer.h **** #if defined(CONFIG_TIMER_DISABLE_UDELAY)
  91:bertos/drv/timer.h **** 	#error Obosolete config option CONFIG_TIMER_DISABLE_UDELAY.  Use CONFIG_TIMER_UDELAY
  92:bertos/drv/timer.h **** #endif
  93:bertos/drv/timer.h **** #if defined(CONFIG_TIMER_DISABLE_EVENTS)
  94:bertos/drv/timer.h **** 	#error Obosolete config option CONFIG_TIMER_DISABLE_EVENTS.  Use CONFIG_TIMER_EVENTS
  95:bertos/drv/timer.h **** #endif
  96:bertos/drv/timer.h **** 
  97:bertos/drv/timer.h **** extern volatile ticks_t _clock;
  98:bertos/drv/timer.h **** 
  99:bertos/drv/timer.h **** /**
 100:bertos/drv/timer.h ****  * \brief Return the system tick counter (expressed in ticks)
 101:bertos/drv/timer.h ****  *
 102:bertos/drv/timer.h ****  * The result is guaranteed to increment monotonically,
 103:bertos/drv/timer.h ****  * but client code must be tolerant with respect to overflows.
 104:bertos/drv/timer.h ****  *
 105:bertos/drv/timer.h ****  * The following code is safe:
 106:bertos/drv/timer.h ****  *
 107:bertos/drv/timer.h ****  * \code
 108:bertos/drv/timer.h ****  *   drop_teabag();
 109:bertos/drv/timer.h ****  *   ticks_t tea_start_time = timer_clock();
 110:bertos/drv/timer.h ****  *
 111:bertos/drv/timer.h ****  *   for (;;)
 112:bertos/drv/timer.h ****  *   {
 113:bertos/drv/timer.h ****  *       if (timer_clock() - tea_start_time > TEAPOT_DELAY)
 114:bertos/drv/timer.h ****  *       {
 115:bertos/drv/timer.h ****  *           printf("Your tea, Sir.\n");
 116:bertos/drv/timer.h ****  *           break;
 117:bertos/drv/timer.h ****  *       }
 118:bertos/drv/timer.h ****  *       patience();
 119:bertos/drv/timer.h ****  *   }
 120:bertos/drv/timer.h ****  * \endcode
 121:bertos/drv/timer.h ****  *
 122:bertos/drv/timer.h ****  * \note This function must disable interrupts on 8/16bit CPUs because the
 123:bertos/drv/timer.h ****  * clock variable is larger than the processor word size and can't
 124:bertos/drv/timer.h ****  * be copied atomically.
 125:bertos/drv/timer.h ****  * \sa timer_delay()
 126:bertos/drv/timer.h ****  */
 127:bertos/drv/timer.h **** INLINE ticks_t timer_clock(void)
 128:bertos/drv/timer.h **** {
 129:bertos/drv/timer.h **** 	ticks_t result;
 130:bertos/drv/timer.h **** 
 131:bertos/drv/timer.h **** 	ATOMIC(result = _clock);
 511               		.loc 2 131 0
 512               	/* #APP */
 513               	 ;  131 "bertos/drv/timer.h" 1
 514 0018 8FB7      		in r24,__SREG__
 515 001a F894      		cli
 516               	 ;  0 "" 2
 517               	.LVL25:
 518               	/* #NOAPP */
 519 001c 4091 0000 		lds r20,_clock	 ;  12	*movsi/3	[length = 8]
 520 0020 5091 0000 		lds r21,_clock+1
 521 0024 6091 0000 		lds r22,_clock+2
 522 0028 7091 0000 		lds r23,_clock+3
 523               	.LVL26:
 524               	/* #APP */
 525               	 ;  131 "bertos/drv/timer.h" 1
 526 002c 8FBF      		out __SREG__,r24
 527               	 ;  0 "" 2
 528               	/* #NOAPP */
 529               	.LBE71:
 530               	.LBE70:
 531               	.LBE69:
 197:bertos/drv/timer.c **** 		if (timer_clock() - timer->tick < 0)
 532               		.loc 1 197 0
 533 002e 8885      		ldd r24,Y+8	 ;  15	*movsi/3	[length = 4]
 534 0030 9985      		ldd r25,Y+9
 535 0032 AA85      		ldd r26,Y+10
 536 0034 BB85      		ldd r27,Y+11
 537 0036 481B      		sub r20,r24	 ;  16	subsi3/1	[length = 4]
 538 0038 590B      		sbc r21,r25
 539 003a 6A0B      		sbc r22,r26
 540 003c 7B0B      		sbc r23,r27
 541 003e 77FD      		sbrc r23,7	 ;  88	*sbrx_and_branchsi	[length = 2]
 542 0040 00C0      		rjmp .L17
 201:bertos/drv/timer.c **** 		REMOVE(&timer->link);
 543               		.loc 1 201 0
 544 0042 CF3F      		cpi r28,255	 ;  21	*cmphi/4	[length = 2]
 545 0044 D105      		cpc r29,__zero_reg__
 546 0046 01F0      		breq .+2	 ;  22	difficult_branch	[length = 2]
 547 0048 00F4      		brsh .L20
 548 004a CE01      		movw r24,r28	 ;  27	*movhi/1	[length = 1]
 549 004c 60E0      		ldi r22,lo8(__c.1605)	 ;  64	*movhi/4	[length = 2]
 550 004e 70E0      		ldi r23,hi8(__c.1605)
 551 0050 40E0      		ldi r20,lo8(__c.1607)	 ;  65	*movhi/4	[length = 2]
 552 0052 50E0      		ldi r21,hi8(__c.1607)
 553 0054 29EC      		ldi r18,lo8(201)	 ;  30	*movhi/4	[length = 2]
 554 0056 30E0      		ldi r19,hi8(201)
 555 0058 0E94 0000 		call __invalid_ptr_P	 ;  31	call_value_insn/3	[length = 2]
 556               	.L20:
 557 005c EA81      		ldd r30,Y+2	 ;  34	*movhi/2	[length = 2]
 558 005e FB81      		ldd r31,Y+3
 559 0060 8881      		ld r24,Y	 ;  35	*movhi/2	[length = 2]
 560 0062 9981      		ldd r25,Y+1
 561 0064 9183      		std Z+1,r25	 ;  36	*movhi/3	[length = 2]
 562 0066 8083      		st Z,r24
 563 0068 E881      		ld r30,Y	 ;  37	*movhi/2	[length = 2]
 564 006a F981      		ldd r31,Y+1
 565 006c 8A81      		ldd r24,Y+2	 ;  38	*movhi/2	[length = 2]
 566 006e 9B81      		ldd r25,Y+3
 567 0070 9383      		std Z+3,r25	 ;  39	*movhi/3	[length = 2]
 568 0072 8283      		std Z+2,r24
 569 0074 1B82      		std Y+3,__zero_reg__	 ;  40	*movhi/3	[length = 2]
 570 0076 1A82      		std Y+2,__zero_reg__
 571 0078 1982      		std Y+1,__zero_reg__	 ;  41	*movhi/3	[length = 2]
 572 007a 1882      		st Y,__zero_reg__
 202:bertos/drv/timer.c **** 		DB(timer->magic = TIMER_MAGIC_INACTIVE;)
 573               		.loc 1 202 0
 574 007c FB8A      		std Y+19,r15	 ;  43	*movhi/3	[length = 2]
 575 007e EA8A      		std Y+18,r14
 576               	.LVL27:
 577               	.LBB72:
 578               	.LBB73:
 579               		.file 3 "bertos/mware/event.h"
   1:bertos/mware/event.h **** /**
   2:bertos/mware/event.h ****  * \file
   3:bertos/mware/event.h ****  * <!--
   4:bertos/mware/event.h ****  * This file is part of BeRTOS.
   5:bertos/mware/event.h ****  *
   6:bertos/mware/event.h ****  * Bertos is free software; you can redistribute it and/or modify
   7:bertos/mware/event.h ****  * it under the terms of the GNU General Public License as published by
   8:bertos/mware/event.h ****  * the Free Software Foundation; either version 2 of the License, or
   9:bertos/mware/event.h ****  * (at your option) any later version.
  10:bertos/mware/event.h ****  *
  11:bertos/mware/event.h ****  * This program is distributed in the hope that it will be useful,
  12:bertos/mware/event.h ****  * but WITHOUT ANY WARRANTY; without even the implied warranty of
  13:bertos/mware/event.h ****  * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
  14:bertos/mware/event.h ****  * GNU General Public License for more details.
  15:bertos/mware/event.h ****  *
  16:bertos/mware/event.h ****  * You should have received a copy of the GNU General Public License
  17:bertos/mware/event.h ****  * along with this program; if not, write to the Free Software
  18:bertos/mware/event.h ****  * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
  19:bertos/mware/event.h ****  *
  20:bertos/mware/event.h ****  * As a special exception, you may use this file as part of a free software
  21:bertos/mware/event.h ****  * library without restriction.  Specifically, if other files instantiate
  22:bertos/mware/event.h ****  * templates or use macros or inline functions from this file, or you compile
  23:bertos/mware/event.h ****  * this file and link it with other files to produce an executable, this
  24:bertos/mware/event.h ****  * file does not by itself cause the resulting executable to be covered by
  25:bertos/mware/event.h ****  * the GNU General Public License.  This exception does not however
  26:bertos/mware/event.h ****  * invalidate any other reasons why the executable file might be covered by
  27:bertos/mware/event.h ****  * the GNU General Public License.
  28:bertos/mware/event.h ****  *
  29:bertos/mware/event.h ****  * Copyright 2003, 2004, 2005 Develer S.r.l. (http://www.develer.com/)
  30:bertos/mware/event.h ****  * Copyright 1999, 2001, 2003 Bernie Innocenti <bernie@codewiz.org>
  31:bertos/mware/event.h ****  * -->
  32:bertos/mware/event.h ****  *
  33:bertos/mware/event.h ****  * \brief Events handling
  34:bertos/mware/event.h ****  *
  35:bertos/mware/event.h ****  * This module implements a common system for executing
  36:bertos/mware/event.h ****  * a user defined action calling a hook function.
  37:bertos/mware/event.h ****  *
  38:bertos/mware/event.h ****  * \version $Id: event.h 2506 2009-04-15 08:29:07Z duplo $
  39:bertos/mware/event.h ****  * \author Bernie Innocenti <bernie@codewiz.org>
  40:bertos/mware/event.h ****  */
  41:bertos/mware/event.h **** 
  42:bertos/mware/event.h **** #ifndef KERN_EVENT_H
  43:bertos/mware/event.h **** #define KERN_EVENT_H
  44:bertos/mware/event.h **** 
  45:bertos/mware/event.h **** #include <cfg/compiler.h>
  46:bertos/mware/event.h **** #include "cfg/cfg_proc.h"
  47:bertos/mware/event.h **** #include "cfg/cfg_signal.h"
  48:bertos/mware/event.h **** 
  49:bertos/mware/event.h **** #if CONFIG_KERN
  50:bertos/mware/event.h **** 	#if defined(CONFIG_KERN_SIGNALS) && CONFIG_KERN_SIGNALS
  51:bertos/mware/event.h **** 		#include <kern/signal.h>
  52:bertos/mware/event.h **** 	#endif
  53:bertos/mware/event.h **** 
  54:bertos/mware/event.h **** 	/* Forward decl */
  55:bertos/mware/event.h **** 	struct Process;
  56:bertos/mware/event.h **** #endif
  57:bertos/mware/event.h **** 
  58:bertos/mware/event.h **** 
  59:bertos/mware/event.h **** /// User defined callback type
  60:bertos/mware/event.h **** typedef void (*Hook)(void *);
  61:bertos/mware/event.h **** 
  62:bertos/mware/event.h **** typedef struct Event
  63:bertos/mware/event.h **** {
  64:bertos/mware/event.h **** 	void (*action)(struct Event *);
  65:bertos/mware/event.h **** 	union
  66:bertos/mware/event.h **** 	{
  67:bertos/mware/event.h **** #if defined(CONFIG_KERN_SIGNALS) && CONFIG_KERN_SIGNALS
  68:bertos/mware/event.h **** 		struct
  69:bertos/mware/event.h **** 		{
  70:bertos/mware/event.h **** 			struct Process *sig_proc;  /* Process to be signalled */
  71:bertos/mware/event.h **** 			sigbit_t        sig_bit;   /* Signal to send */
  72:bertos/mware/event.h **** 		} Sig;
  73:bertos/mware/event.h **** #endif
  74:bertos/mware/event.h **** 		struct
  75:bertos/mware/event.h **** 		{
  76:bertos/mware/event.h **** 			Hook  func;         /* Pointer to softint hook */
  77:bertos/mware/event.h **** 			void *user_data;    /* Data to be passed back to user hook */
  78:bertos/mware/event.h **** 		} Int;
  79:bertos/mware/event.h **** 	} Ev;
  80:bertos/mware/event.h **** } Event;
  81:bertos/mware/event.h **** 
  82:bertos/mware/event.h **** void event_hook_ignore(Event *event);
  83:bertos/mware/event.h **** void event_hook_signal(Event *event);
  84:bertos/mware/event.h **** void event_hook_softint(Event *event);
  85:bertos/mware/event.h **** 
  86:bertos/mware/event.h **** /** Initialize the event \a e as a no-op */
  87:bertos/mware/event.h **** #define event_initNone(e) \
  88:bertos/mware/event.h **** 	((e)->action = event_hook_ignore)
  89:bertos/mware/event.h **** 
  90:bertos/mware/event.h **** /** Same as event_initNone(), but returns the initialized event */
  91:bertos/mware/event.h **** INLINE Event event_createNone(void);
  92:bertos/mware/event.h **** INLINE Event event_createNone(void)
  93:bertos/mware/event.h **** {
  94:bertos/mware/event.h **** 	Event e;
  95:bertos/mware/event.h **** 	e.action = event_hook_ignore;
  96:bertos/mware/event.h **** 	return e;
  97:bertos/mware/event.h **** }
  98:bertos/mware/event.h **** 
  99:bertos/mware/event.h **** /** Initialize the event \a e with a software interrupt (call function \a f, with parameter \a u) *
 100:bertos/mware/event.h **** #define event_initSoftint(e,f,u) \
 101:bertos/mware/event.h **** 	((e)->action = event_hook_softint,(e)->Ev.Int.func = (f), (e)->Ev.Int.user_data = (u))
 102:bertos/mware/event.h **** 
 103:bertos/mware/event.h **** /** Same as event_initSoftint(), but returns the initialized event */
 104:bertos/mware/event.h **** INLINE Event event_createSoftint(Hook func, void *user_data)
 105:bertos/mware/event.h **** {
 106:bertos/mware/event.h **** 	Event e;
 107:bertos/mware/event.h **** 	e.action = event_hook_softint;
 108:bertos/mware/event.h **** 	e.Ev.Int.func = func;
 109:bertos/mware/event.h **** 	e.Ev.Int.user_data = user_data;
 110:bertos/mware/event.h **** 	return e;
 111:bertos/mware/event.h **** }
 112:bertos/mware/event.h **** 
 113:bertos/mware/event.h **** #if defined(CONFIG_KERN_SIGNALS) && CONFIG_KERN_SIGNALS
 114:bertos/mware/event.h **** 
 115:bertos/mware/event.h **** /** Initialize the event \a e with a signal (send signal \a s to process \a p) */
 116:bertos/mware/event.h **** #define event_initSignal(e,p,s) \
 117:bertos/mware/event.h **** 	((e)->action = event_hook_signal,(e)->Ev.Sig.sig_proc = (p), (e)->Ev.Sig.sig_bit = (s))
 118:bertos/mware/event.h **** 
 119:bertos/mware/event.h **** /** Same as event_initSignal(), but returns the initialized event */
 120:bertos/mware/event.h **** INLINE Event event_createSignal(struct Process *proc, sigbit_t bit)
 121:bertos/mware/event.h **** {
 122:bertos/mware/event.h **** 	Event e;
 123:bertos/mware/event.h **** 	e.action = event_hook_signal;
 124:bertos/mware/event.h **** 	e.Ev.Sig.sig_proc = proc;
 125:bertos/mware/event.h **** 	e.Ev.Sig.sig_bit = bit;
 126:bertos/mware/event.h **** 	return e;
 127:bertos/mware/event.h **** }
 128:bertos/mware/event.h **** 
 129:bertos/mware/event.h **** #endif
 130:bertos/mware/event.h **** 
 131:bertos/mware/event.h **** /** Trigger an event */
 132:bertos/mware/event.h **** INLINE void event_do(struct Event *e)
 133:bertos/mware/event.h **** {
 134:bertos/mware/event.h **** 	e->action(e);
 580               		.loc 3 134 0
 581 0080 EC85      		ldd r30,Y+12	 ;  47	*movhi/2	[length = 2]
 582 0082 FD85      		ldd r31,Y+13
 583 0084 CE01      		movw r24,r28	 ;  70	*movhi/1	[length = 1]
 584 0086 0C96      		adiw r24,12	 ;  48	*addhi3/2	[length = 1]
 585 0088 0995      		icall	 ;  49	call_insn/1	[length = 1]
 586               	.LVL28:
 587               	.L18:
 588               	.LBE73:
 589               	.LBE72:
 194:bertos/drv/timer.c **** 	while ((timer = (Timer *)LIST_HEAD(queue))->link.succ)
 590               		.loc 1 194 0
 591 008a F801      		movw r30,r16	 ;  71	*movhi/1	[length = 1]
 592 008c C081      		ld r28,Z	 ;  52	*movhi/2	[length = 2]
 593 008e D181      		ldd r29,Z+1
 594               	.LVL29:
 595 0090 8881      		ld r24,Y	 ;  55	*movhi/2	[length = 2]
 596 0092 9981      		ldd r25,Y+1
 597 0094 0097      		sbiw r24,0	 ;  56	*cmphi/1	[length = 1]
 598 0096 01F0      		breq .+2	 ;  57	branch	[length = 2]
 599 0098 00C0      		rjmp .L21
 600               	.L17:
 601               	/* epilogue start */
 602               	.LBE68:
 603               	.LBE67:
 237:bertos/drv/timer.c **** 	timer_poll(queue);
 238:bertos/drv/timer.c **** }
 604               		.loc 1 238 0
 605 009a DF91      		pop r29	 ;  80	popqi	[length = 1]
 606 009c CF91      		pop r28	 ;  81	popqi	[length = 1]
 607 009e 1F91      		pop r17	 ;  82	popqi	[length = 1]
 608 00a0 0F91      		pop r16	 ;  83	popqi	[length = 1]
 609               	.LVL30:
 610 00a2 FF90      		pop r15	 ;  84	popqi	[length = 1]
 611 00a4 EF90      		pop r14	 ;  85	popqi	[length = 1]
 612 00a6 0895      		ret	 ;  86	return_from_epilogue	[length = 1]
 613               		.cfi_endproc
 614               	.LFE33:
 616               		.section	.text.timer_delayTicks,"ax",@progbits
 617               	.global	timer_delayTicks
 619               	timer_delayTicks:
 620               	.LFB34:
 239:bertos/drv/timer.c **** 
 240:bertos/drv/timer.c **** #endif /* CONFIG_TIMER_EVENTS */
 241:bertos/drv/timer.c **** 
 242:bertos/drv/timer.c **** 
 243:bertos/drv/timer.c **** /**
 244:bertos/drv/timer.c ****  * Wait for the specified amount of timer ticks.
 245:bertos/drv/timer.c ****  *
 246:bertos/drv/timer.c ****  * \note Sleeping while preemption is disabled fallbacks to a busy wait sleep.
 247:bertos/drv/timer.c ****  */
 248:bertos/drv/timer.c **** void timer_delayTicks(ticks_t delay)
 249:bertos/drv/timer.c **** {
 621               		.loc 1 249 0
 622               		.cfi_startproc
 623               	.LVL31:
 624 0000 CF92      		push r12	 ;  46	*pushqi/1	[length = 1]
 625               	.LCFI22:
 626               		.cfi_def_cfa_offset 3
 627               		.cfi_offset 12, -2
 628 0002 DF92      		push r13	 ;  47	*pushqi/1	[length = 1]
 629               	.LCFI23:
 630               		.cfi_def_cfa_offset 4
 631               		.cfi_offset 13, -3
 632 0004 EF92      		push r14	 ;  48	*pushqi/1	[length = 1]
 633               	.LCFI24:
 634               		.cfi_def_cfa_offset 5
 635               		.cfi_offset 14, -4
 636 0006 FF92      		push r15	 ;  49	*pushqi/1	[length = 1]
 637               	.LCFI25:
 638               		.cfi_def_cfa_offset 6
 639               		.cfi_offset 15, -5
 640               	/* prologue: function */
 641               	/* frame size = 0 */
 642               	/* stack size = 4 */
 643               	.L__stack_usage = 4
 644 0008 6B01      		movw r12,r22	 ;  2	*movsi/1	[length = 2]
 645 000a 7C01      		movw r14,r24
 646               	.LBB74:
 250:bertos/drv/timer.c **** 	/* We shouldn't sleep with interrupts disabled */
 251:bertos/drv/timer.c **** 	IRQ_ASSERT_ENABLED();
 647               		.loc 1 251 0
 648               	/* #APP */
 649               	 ;  251 "bertos/drv/timer.c" 1
 650 000c 8FB7      		in r24,__SREG__
 651               		
 652               	 ;  0 "" 2
 653               	.LVL32:
 654               	/* #NOAPP */
 655               	.LBE74:
 656 000e 87FD      		sbrc r24,7	 ;  59	*sbrx_branchhi	[length = 2]
 657 0010 00C0      		rjmp .L23
 658               	.LVL33:
 659               		.loc 1 251 0 is_stmt 0 discriminator 1
 660 0012 80E0      		ldi r24,lo8(__c.1623)	 ;  15	*movhi/4	[length = 2]
 661 0014 90E0      		ldi r25,hi8(__c.1623)
 662               	.LVL34:
 663 0016 60E0      		ldi r22,lo8(__c.1625)	 ;  16	*movhi/4	[length = 2]
 664 0018 70E0      		ldi r23,hi8(__c.1625)
 665 001a 4BEF      		ldi r20,lo8(251)	 ;  17	*movhi/4	[length = 2]
 666 001c 50E0      		ldi r21,hi8(251)
 667 001e 0E94 0000 		call __bassert_P	 ;  18	call_value_insn/3	[length = 2]
 668               	.L23:
 669               	.LBB75:
 670               	.LBB76:
 671               	.LBB77:
 672               	.LBB78:
 673               		.loc 2 131 0 is_stmt 1
 674               	/* #APP */
 675               	 ;  131 "bertos/drv/timer.h" 1
 676 0022 8FB7      		in r24,__SREG__
 677 0024 F894      		cli
 678               	 ;  0 "" 2
 679               	.LVL35:
 680               	/* #NOAPP */
 681 0026 4091 0000 		lds r20,_clock	 ;  24	*movsi/3	[length = 8]
 682 002a 5091 0000 		lds r21,_clock+1
 683 002e 6091 0000 		lds r22,_clock+2
 684 0032 7091 0000 		lds r23,_clock+3
 685               	.LVL36:
 686               	/* #APP */
 687               	 ;  131 "bertos/drv/timer.h" 1
 688 0036 8FBF      		out __SREG__,r24
 689               	 ;  0 "" 2
 690               	/* #NOAPP */
 691               	.L24:
 692               	.LBE78:
 693               	.LBE77:
 694               	.LBE76:
 695               	.LBB79:
 696               	.LBB80:
 697               	.LBB81:
 698               		.loc 2 131 0 is_stmt 0 discriminator 1
 699               	/* #APP */
 700               	 ;  131 "bertos/drv/timer.h" 1
 701 0038 2FB7      		in r18,__SREG__
 702 003a F894      		cli
 703               	 ;  0 "" 2
 704               	.LVL37:
 705               	/* #NOAPP */
 706 003c 8091 0000 		lds r24,_clock	 ;  32	*movsi/3	[length = 8]
 707 0040 9091 0000 		lds r25,_clock+1
 708 0044 A091 0000 		lds r26,_clock+2
 709 0048 B091 0000 		lds r27,_clock+3
 710               	.LVL38:
 711               	/* #APP */
 712               	 ;  131 "bertos/drv/timer.h" 1
 713 004c 2FBF      		out __SREG__,r18
 714               	 ;  0 "" 2
 715               	/* #NOAPP */
 716               	.LBE81:
 717               	.LBE80:
 718               	.LBE79:
 252:bertos/drv/timer.c **** 
 253:bertos/drv/timer.c **** #if CONFIG_KERN_SIGNALS
 254:bertos/drv/timer.c **** 	Timer t;
 255:bertos/drv/timer.c **** 
 256:bertos/drv/timer.c **** 	if (proc_preemptAllowed())
 257:bertos/drv/timer.c **** 	{
 258:bertos/drv/timer.c **** 		ASSERT(!sig_check(SIG_SINGLE));
 259:bertos/drv/timer.c **** 		timer_setSignal(&t, proc_current(), SIG_SINGLE);
 260:bertos/drv/timer.c **** 		timer_setDelay(&t, delay);
 261:bertos/drv/timer.c **** 		timer_add(&t);
 262:bertos/drv/timer.c **** 		sig_wait(SIG_SINGLE);
 263:bertos/drv/timer.c **** 	}
 264:bertos/drv/timer.c **** 	else
 265:bertos/drv/timer.c **** #endif /* !CONFIG_KERN_SIGNALS */
 266:bertos/drv/timer.c **** 	{
 267:bertos/drv/timer.c **** 		ticks_t start = timer_clock();
 268:bertos/drv/timer.c **** 
 269:bertos/drv/timer.c **** 		/* Busy wait */
 270:bertos/drv/timer.c **** 		while (timer_clock() - start < delay)
 719               		.loc 1 270 0 is_stmt 1 discriminator 1
 720 004e 841B      		sub r24,r20	 ;  36	subsi3/1	[length = 4]
 721 0050 950B      		sbc r25,r21
 722 0052 A60B      		sbc r26,r22
 723 0054 B70B      		sbc r27,r23
 724 0056 8C15      		cp r24,r12	 ;  37	*cmpsi/2	[length = 4]
 725 0058 9D05      		cpc r25,r13
 726 005a AE05      		cpc r26,r14
 727 005c BF05      		cpc r27,r15
 728 005e 04F0      		brlt .L24	 ;  38	branch	[length = 1]
 729               	/* epilogue start */
 730               	.LBE75:
 271:bertos/drv/timer.c **** 			cpu_relax();
 272:bertos/drv/timer.c **** 	}
 273:bertos/drv/timer.c **** }
 731               		.loc 1 273 0
 732 0060 FF90      		pop r15	 ;  52	popqi	[length = 1]
 733 0062 EF90      		pop r14	 ;  53	popqi	[length = 1]
 734 0064 DF90      		pop r13	 ;  54	popqi	[length = 1]
 735 0066 CF90      		pop r12	 ;  55	popqi	[length = 1]
 736               	.LVL39:
 737 0068 0895      		ret	 ;  56	return_from_epilogue	[length = 1]
 738               		.cfi_endproc
 739               	.LFE34:
 741               		.section	.text.timer_busyWait,"ax",@progbits
 742               	.global	timer_busyWait
 744               	timer_busyWait:
 745               	.LFB35:
 274:bertos/drv/timer.c **** 
 275:bertos/drv/timer.c **** 
 276:bertos/drv/timer.c **** #if CONFIG_TIMER_UDELAY
 277:bertos/drv/timer.c **** 
 278:bertos/drv/timer.c **** /**
 279:bertos/drv/timer.c ****  * Busy wait until the specified amount of high-precision ticks have elapsed.
 280:bertos/drv/timer.c ****  *
 281:bertos/drv/timer.c ****  * \note This function is interrupt safe, the only
 282:bertos/drv/timer.c ****  *       requirement is a running hardware timer.
 283:bertos/drv/timer.c ****  */
 284:bertos/drv/timer.c **** void timer_busyWait(hptime_t delay)
 285:bertos/drv/timer.c **** {
 746               		.loc 1 285 0
 747               		.cfi_startproc
 748               	.LVL40:
 749 0000 CF92      		push r12	 ;  53	*pushqi/1	[length = 1]
 750               	.LCFI26:
 751               		.cfi_def_cfa_offset 3
 752               		.cfi_offset 12, -2
 753 0002 DF92      		push r13	 ;  54	*pushqi/1	[length = 1]
 754               	.LCFI27:
 755               		.cfi_def_cfa_offset 4
 756               		.cfi_offset 13, -3
 757 0004 EF92      		push r14	 ;  55	*pushqi/1	[length = 1]
 758               	.LCFI28:
 759               		.cfi_def_cfa_offset 5
 760               		.cfi_offset 14, -4
 761 0006 FF92      		push r15	 ;  56	*pushqi/1	[length = 1]
 762               	.LCFI29:
 763               		.cfi_def_cfa_offset 6
 764               		.cfi_offset 15, -5
 765 0008 CF93      		push r28	 ;  57	*pushqi/1	[length = 1]
 766               	.LCFI30:
 767               		.cfi_def_cfa_offset 7
 768               		.cfi_offset 28, -6
 769 000a DF93      		push r29	 ;  58	*pushqi/1	[length = 1]
 770               	.LCFI31:
 771               		.cfi_def_cfa_offset 8
 772               		.cfi_offset 29, -7
 773               	/* prologue: function */
 774               	/* frame size = 0 */
 775               	/* stack size = 6 */
 776               	.L__stack_usage = 6
 777 000c C82F      		mov r28,r24	 ;  2	*movqi/1	[length = 1]
 778               	.LBB82:
 779               	.LBB83:
 780               		.file 4 "bertos/cpu/avr/drv/timer_avr.h"
   1:bertos/cpu/avr/drv/timer_avr.h **** /**
   2:bertos/cpu/avr/drv/timer_avr.h ****  * \file
   3:bertos/cpu/avr/drv/timer_avr.h ****  * <!--
   4:bertos/cpu/avr/drv/timer_avr.h ****  * This file is part of BeRTOS.
   5:bertos/cpu/avr/drv/timer_avr.h ****  *
   6:bertos/cpu/avr/drv/timer_avr.h ****  * Bertos is free software; you can redistribute it and/or modify
   7:bertos/cpu/avr/drv/timer_avr.h ****  * it under the terms of the GNU General Public License as published by
   8:bertos/cpu/avr/drv/timer_avr.h ****  * the Free Software Foundation; either version 2 of the License, or
   9:bertos/cpu/avr/drv/timer_avr.h ****  * (at your option) any later version.
  10:bertos/cpu/avr/drv/timer_avr.h ****  *
  11:bertos/cpu/avr/drv/timer_avr.h ****  * This program is distributed in the hope that it will be useful,
  12:bertos/cpu/avr/drv/timer_avr.h ****  * but WITHOUT ANY WARRANTY; without even the implied warranty of
  13:bertos/cpu/avr/drv/timer_avr.h ****  * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
  14:bertos/cpu/avr/drv/timer_avr.h ****  * GNU General Public License for more details.
  15:bertos/cpu/avr/drv/timer_avr.h ****  *
  16:bertos/cpu/avr/drv/timer_avr.h ****  * You should have received a copy of the GNU General Public License
  17:bertos/cpu/avr/drv/timer_avr.h ****  * along with this program; if not, write to the Free Software
  18:bertos/cpu/avr/drv/timer_avr.h ****  * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
  19:bertos/cpu/avr/drv/timer_avr.h ****  *
  20:bertos/cpu/avr/drv/timer_avr.h ****  * As a special exception, you may use this file as part of a free software
  21:bertos/cpu/avr/drv/timer_avr.h ****  * library without restriction.  Specifically, if other files instantiate
  22:bertos/cpu/avr/drv/timer_avr.h ****  * templates or use macros or inline functions from this file, or you compile
  23:bertos/cpu/avr/drv/timer_avr.h ****  * this file and link it with other files to produce an executable, this
  24:bertos/cpu/avr/drv/timer_avr.h ****  * file does not by itself cause the resulting executable to be covered by
  25:bertos/cpu/avr/drv/timer_avr.h ****  * the GNU General Public License.  This exception does not however
  26:bertos/cpu/avr/drv/timer_avr.h ****  * invalidate any other reasons why the executable file might be covered by
  27:bertos/cpu/avr/drv/timer_avr.h ****  * the GNU General Public License.
  28:bertos/cpu/avr/drv/timer_avr.h ****  *
  29:bertos/cpu/avr/drv/timer_avr.h ****  * Copyright 2003, 2004, 2005, 2010 Develer S.r.l. (http://www.develer.com/)
  30:bertos/cpu/avr/drv/timer_avr.h ****  * Copyright 2000 Bernie Innocenti <bernie@codewiz.org>
  31:bertos/cpu/avr/drv/timer_avr.h ****  *
  32:bertos/cpu/avr/drv/timer_avr.h ****  * -->
  33:bertos/cpu/avr/drv/timer_avr.h ****  *
  34:bertos/cpu/avr/drv/timer_avr.h ****  * \brief Low-level timer module for AVR (interface).
  35:bertos/cpu/avr/drv/timer_avr.h ****  *
  36:bertos/cpu/avr/drv/timer_avr.h ****  * \author Bernie Innocenti <bernie@codewiz.org>
  37:bertos/cpu/avr/drv/timer_avr.h ****  * \author Francesco Sacchi <batt@develer.com>
  38:bertos/cpu/avr/drv/timer_avr.h ****  * \author Luca Ottaviano <lottaviano@develer.com>
  39:bertos/cpu/avr/drv/timer_avr.h ****  *
  40:bertos/cpu/avr/drv/timer_avr.h ****  */
  41:bertos/cpu/avr/drv/timer_avr.h **** 
  42:bertos/cpu/avr/drv/timer_avr.h **** #ifndef DRV_TIMER_AVR_H
  43:bertos/cpu/avr/drv/timer_avr.h **** #define DRV_TIMER_AVR_H
  44:bertos/cpu/avr/drv/timer_avr.h **** 
  45:bertos/cpu/avr/drv/timer_avr.h **** #include <hw/hw_cpufreq.h>   /* CPU_FREQ */
  46:bertos/cpu/avr/drv/timer_avr.h **** 
  47:bertos/cpu/avr/drv/timer_avr.h **** #include "cfg/cfg_timer.h"   /* CONFIG_TIMER */
  48:bertos/cpu/avr/drv/timer_avr.h **** #include <cfg/compiler.h>    /* uint8_t */
  49:bertos/cpu/avr/drv/timer_avr.h **** #include <cfg/macros.h>      /* DIV_ROUND */
  50:bertos/cpu/avr/drv/timer_avr.h **** 
  51:bertos/cpu/avr/drv/timer_avr.h **** #include <avr/io.h>
  52:bertos/cpu/avr/drv/timer_avr.h **** #include <avr/interrupt.h>
  53:bertos/cpu/avr/drv/timer_avr.h **** 
  54:bertos/cpu/avr/drv/timer_avr.h **** /**
  55:bertos/cpu/avr/drv/timer_avr.h ****  * \name Values for CONFIG_TIMER.
  56:bertos/cpu/avr/drv/timer_avr.h ****  *
  57:bertos/cpu/avr/drv/timer_avr.h ****  * Select which hardware timer interrupt to use for system clock and softtimers.
  58:bertos/cpu/avr/drv/timer_avr.h ****  * \note The timer 1 overflow mode set the timer as a 24 kHz PWM.
  59:bertos/cpu/avr/drv/timer_avr.h ****  * $WIZ$ timer_select = "TIMER_ON_OUTPUT_COMPARE0", "TIMER_ON_OVERFLOW1", "TIMER_ON_OUTPUT_COMPARE2
  60:bertos/cpu/avr/drv/timer_avr.h ****  */
  61:bertos/cpu/avr/drv/timer_avr.h **** #define TIMER_ON_OUTPUT_COMPARE0  1
  62:bertos/cpu/avr/drv/timer_avr.h **** #define TIMER_ON_OVERFLOW1        2
  63:bertos/cpu/avr/drv/timer_avr.h **** #define TIMER_ON_OUTPUT_COMPARE2  3
  64:bertos/cpu/avr/drv/timer_avr.h **** #define TIMER_ON_OVERFLOW3        4
  65:bertos/cpu/avr/drv/timer_avr.h **** 
  66:bertos/cpu/avr/drv/timer_avr.h **** #define TIMER_DEFAULT TIMER_ON_OUTPUT_COMPARE0 ///< Default system timer
  67:bertos/cpu/avr/drv/timer_avr.h **** 
  68:bertos/cpu/avr/drv/timer_avr.h **** /*
  69:bertos/cpu/avr/drv/timer_avr.h ****  * Hardware dependent timer initialization.
  70:bertos/cpu/avr/drv/timer_avr.h ****  */
  71:bertos/cpu/avr/drv/timer_avr.h **** #if (CONFIG_TIMER == TIMER_ON_OUTPUT_COMPARE0)
  72:bertos/cpu/avr/drv/timer_avr.h **** 
  73:bertos/cpu/avr/drv/timer_avr.h **** 	#define TIMER_PRESCALER      64
  74:bertos/cpu/avr/drv/timer_avr.h **** 	#define TIMER_HW_BITS        8
  75:bertos/cpu/avr/drv/timer_avr.h **** 	#if CPU_AVR_ATMEGA1281 || CPU_AVR_ATMEGA168 || CPU_AVR_ATMEGA328P
  76:bertos/cpu/avr/drv/timer_avr.h **** 		#define DEFINE_TIMER_ISR     DECLARE_ISR_CONTEXT_SWITCH(TIMER0_COMPA_vect)
  77:bertos/cpu/avr/drv/timer_avr.h **** 	#else
  78:bertos/cpu/avr/drv/timer_avr.h **** 		#define DEFINE_TIMER_ISR     DECLARE_ISR_CONTEXT_SWITCH(TIMER0_COMP_vect)
  79:bertos/cpu/avr/drv/timer_avr.h **** 	#endif
  80:bertos/cpu/avr/drv/timer_avr.h **** 	#define TIMER_TICKS_PER_SEC  1000
  81:bertos/cpu/avr/drv/timer_avr.h **** 	#define TIMER_HW_CNT         OCR_DIVISOR
  82:bertos/cpu/avr/drv/timer_avr.h **** 
  83:bertos/cpu/avr/drv/timer_avr.h **** 	/// Type of time expressed in ticks of the hardware high-precision timer
  84:bertos/cpu/avr/drv/timer_avr.h **** 	typedef uint8_t hptime_t;
  85:bertos/cpu/avr/drv/timer_avr.h **** 	#define SIZEOF_HPTIME_T 1
  86:bertos/cpu/avr/drv/timer_avr.h **** 
  87:bertos/cpu/avr/drv/timer_avr.h **** 	INLINE hptime_t timer_hw_hpread(void)
  88:bertos/cpu/avr/drv/timer_avr.h **** 	{
  89:bertos/cpu/avr/drv/timer_avr.h **** 		return TCNT0;
 781               		.loc 4 89 0
 782 000e 86B5      		in r24,70-32	 ;  7	*movqi/4	[length = 1]
 783               	.LVL41:
 784               	.LBE83:
 785               	.LBE82:
 286:bertos/drv/timer.c **** 	hptime_t now, prev = timer_hw_hpread();
 287:bertos/drv/timer.c **** 	hptime_t delta;
 288:bertos/drv/timer.c **** 
 289:bertos/drv/timer.c **** 	for(;;)
 290:bertos/drv/timer.c **** 	{
 291:bertos/drv/timer.c **** 		now = timer_hw_hpread();
 292:bertos/drv/timer.c **** 		/*
 293:bertos/drv/timer.c **** 		 * We rely on hptime_t being unsigned here to
 294:bertos/drv/timer.c **** 		 * reduce the modulo to an AND in the common
 295:bertos/drv/timer.c **** 		 * case of TIMER_HW_CNT.
 296:bertos/drv/timer.c **** 		 */
 297:bertos/drv/timer.c **** 		delta = (now - prev) % TIMER_HW_CNT;
 786               		.loc 1 297 0
 787 0010 3CE7      		ldi r19,lo8(124)	 ;  69	*reload_insi	[length = 5]
 788 0012 C32E      		mov r12,r19
 789 0014 D12C      		mov r13,__zero_reg__
 790 0016 E12C      		mov r14,__zero_reg__
 791 0018 F12C      		mov r15,__zero_reg__
 792               	.L28:
 793               	.LVL42:
 794               	.LBB84:
 795               	.LBB85:
 796               		.loc 4 89 0
 797 001a D6B5      		in r29,70-32	 ;  13	*movqi/4	[length = 1]
 798               	.LBE85:
 799               	.LBE84:
 800               		.loc 1 297 0
 801 001c 6D2F      		mov r22,r29	 ;  51	*movqi/1	[length = 1]
 802 001e 70E0      		ldi r23,lo8(0)	 ;  52	*movqi/2	[length = 1]
 803 0020 681B      		sub r22,r24	 ;  17	*subhi3_zero_extend1	[length = 2]
 804 0022 7109      		sbc r23,__zero_reg__
 805 0024 8827      		clr r24	 ;  18	extendhisi2/1	[length = 4]
 806 0026 77FD      		sbrc r23,7
 807 0028 8095      		com r24
 808 002a 982F      		mov r25,r24
 809 002c A701      		movw r20,r14	 ;  42	*movsi/1	[length = 2]
 810 002e 9601      		movw r18,r12
 811 0030 0E94 0000 		call __udivmodsi4	 ;  43	*udivmodsi4_call	[length = 2]
 812               	.LVL43:
 298:bertos/drv/timer.c **** 		if (delta >= delay)
 813               		.loc 1 298 0
 814 0034 6C17      		cp r22,r28	 ;  24	*cmpqi/2	[length = 1]
 815 0036 00F4      		brsh .L26	 ;  25	branch	[length = 1]
 299:bertos/drv/timer.c **** 			break;
 300:bertos/drv/timer.c **** 		delay -= delta;
 816               		.loc 1 300 0
 817 0038 C61B      		sub r28,r22	 ;  27	subqi3/1	[length = 1]
 818               	.LVL44:
 301:bertos/drv/timer.c **** 		prev = now;
 819               		.loc 1 301 0
 820 003a 8D2F      		mov r24,r29	 ;  30	*movqi/1	[length = 1]
 302:bertos/drv/timer.c **** 	}
 821               		.loc 1 302 0
 822 003c 00C0      		rjmp .L28	 ;  70	jump	[length = 1]
 823               	.LVL45:
 824               	.L26:
 825               	/* epilogue start */
 303:bertos/drv/timer.c **** }
 826               		.loc 1 303 0
 827 003e DF91      		pop r29	 ;  61	popqi	[length = 1]
 828 0040 CF91      		pop r28	 ;  62	popqi	[length = 1]
 829               	.LVL46:
 830 0042 FF90      		pop r15	 ;  63	popqi	[length = 1]
 831 0044 EF90      		pop r14	 ;  64	popqi	[length = 1]
 832 0046 DF90      		pop r13	 ;  65	popqi	[length = 1]
 833 0048 CF90      		pop r12	 ;  66	popqi	[length = 1]
 834 004a 0895      		ret	 ;  67	return_from_epilogue	[length = 1]
 835               		.cfi_endproc
 836               	.LFE35:
 838               		.section	.text.timer_delayHp,"ax",@progbits
 839               	.global	timer_delayHp
 841               	timer_delayHp:
 842               	.LFB36:
 304:bertos/drv/timer.c **** 
 305:bertos/drv/timer.c **** /**
 306:bertos/drv/timer.c ****  * Wait for the specified amount of time (expressed in microseconds).
 307:bertos/drv/timer.c ****  *
 308:bertos/drv/timer.c ****  * \bug In AVR arch the maximum amount of time that can be used as
 309:bertos/drv/timer.c ****  *      delay could be very limited, depending on the hardware timer
 310:bertos/drv/timer.c ****  *      used. Check timer_avr.h, and what register is used as hptime_t.
 311:bertos/drv/timer.c ****  */
 312:bertos/drv/timer.c **** void timer_delayHp(hptime_t delay)
 313:bertos/drv/timer.c **** {
 843               		.loc 1 313 0
 844               		.cfi_startproc
 845               	.LVL47:
 846 0000 CF93      		push r28	 ;  40	*pushqi/1	[length = 1]
 847               	.LCFI32:
 848               		.cfi_def_cfa_offset 3
 849               		.cfi_offset 28, -2
 850               	/* prologue: function */
 851               	/* frame size = 0 */
 852               	/* stack size = 1 */
 853               	.L__stack_usage = 1
 854               	.LVL48:
 314:bertos/drv/timer.c **** 	if (UNLIKELY(delay > us_to_hptime(1000)))
 855               		.loc 1 314 0
 856 0002 8E37      		cpi r24,lo8(126)	 ;  7	*cmpqi/3	[length = 1]
 857 0004 00F0      		brlo .L30	 ;  8	branch	[length = 1]
 315:bertos/drv/timer.c **** 	{
 316:bertos/drv/timer.c **** 		timer_delayTicks(delay / (TIMER_HW_HPTICKS_PER_SEC / TIMER_TICKS_PER_SEC));
 858               		.loc 1 316 0
 859 0006 6DE7      		ldi r22,lo8(125)	 ;  31	*movqi/2	[length = 1]
 860 0008 0E94 0000 		call __udivmodqi4	 ;  32	*udivmodqi4_call	[length = 2]
 861               	.LVL49:
 862 000c C92F      		mov r28,r25	 ;  34	*movqi/1	[length = 1]
 863 000e 682F      		mov r22,r24	 ;  38	*movqi/1	[length = 1]
 864 0010 70E0      		ldi r23,lo8(0)	 ;  39	*movqi/2	[length = 1]
 865 0012 80E0      		ldi r24,lo8(0)	 ;  37	*movhi/4	[length = 2]
 866 0014 90E0      		ldi r25,hi8(0)
 867 0016 0E94 0000 		call timer_delayTicks	 ;  15	call_insn/3	[length = 2]
 317:bertos/drv/timer.c **** 		delay %= (TIMER_HW_HPTICKS_PER_SEC / TIMER_TICKS_PER_SEC);
 868               		.loc 1 317 0
 869 001a 8C2F      		mov r24,r28	 ;  18	*movqi/1	[length = 1]
 870               	.LVL50:
 871               	.L30:
 318:bertos/drv/timer.c **** 	}
 319:bertos/drv/timer.c **** 
 320:bertos/drv/timer.c **** 	timer_busyWait(delay);
 872               		.loc 1 320 0
 873 001c 0E94 0000 		call timer_busyWait	 ;  25	call_insn/3	[length = 2]
 874               	.LVL51:
 875               	/* epilogue start */
 321:bertos/drv/timer.c **** }
 876               		.loc 1 321 0
 877 0020 CF91      		pop r28	 ;  43	popqi	[length = 1]
 878 0022 0895      		ret	 ;  44	return_from_epilogue	[length = 1]
 879               		.cfi_endproc
 880               	.LFE36:
 882               		.section	.text.__vector_14,"ax",@progbits
 883               	.global	__vector_14
 885               	__vector_14:
 886               	.LFB37:
 322:bertos/drv/timer.c **** #endif /* CONFIG_TIMER_UDELAY */
 323:bertos/drv/timer.c **** 
 324:bertos/drv/timer.c **** /**
 325:bertos/drv/timer.c ****  * Timer interrupt handler. Find soft timers expired and
 326:bertos/drv/timer.c ****  * trigger corresponding events.
 327:bertos/drv/timer.c ****  */
 328:bertos/drv/timer.c **** DEFINE_TIMER_ISR
 329:bertos/drv/timer.c **** {
 887               		.loc 1 329 0
 888               		.cfi_startproc
 889 0000 1F92      		push r1	 ;  74	*pushqi/1	[length = 1]
 890               	.LCFI33:
 891               		.cfi_def_cfa_offset 3
 892               		.cfi_offset 1, -2
 893 0002 0F92      		push r0	 ;  75	*pushqi/1	[length = 1]
 894               	.LCFI34:
 895               		.cfi_def_cfa_offset 4
 896               		.cfi_offset 0, -3
 897 0004 0FB6      		in r0,__SREG__	 ;  76	*movqi/4	[length = 1]
 898 0006 0F92      		push r0	 ;  77	*pushqi/1	[length = 1]
 899 0008 1124      		clr __zero_reg__	 ;  78	*movqi/7	[length = 1]
 900 000a 0F93      		push r16	 ;  80	*pushqi/1	[length = 1]
 901               	.LCFI35:
 902               		.cfi_def_cfa_offset 5
 903               		.cfi_offset 16, -4
 904 000c 1F93      		push r17	 ;  81	*pushqi/1	[length = 1]
 905               	.LCFI36:
 906               		.cfi_def_cfa_offset 6
 907               		.cfi_offset 17, -5
 908 000e 2F93      		push r18	 ;  82	*pushqi/1	[length = 1]
 909               	.LCFI37:
 910               		.cfi_def_cfa_offset 7
 911               		.cfi_offset 18, -6
 912 0010 3F93      		push r19	 ;  83	*pushqi/1	[length = 1]
 913               	.LCFI38:
 914               		.cfi_def_cfa_offset 8
 915               		.cfi_offset 19, -7
 916 0012 4F93      		push r20	 ;  84	*pushqi/1	[length = 1]
 917               	.LCFI39:
 918               		.cfi_def_cfa_offset 9
 919               		.cfi_offset 20, -8
 920 0014 5F93      		push r21	 ;  85	*pushqi/1	[length = 1]
 921               	.LCFI40:
 922               		.cfi_def_cfa_offset 10
 923               		.cfi_offset 21, -9
 924 0016 6F93      		push r22	 ;  86	*pushqi/1	[length = 1]
 925               	.LCFI41:
 926               		.cfi_def_cfa_offset 11
 927               		.cfi_offset 22, -10
 928 0018 7F93      		push r23	 ;  87	*pushqi/1	[length = 1]
 929               	.LCFI42:
 930               		.cfi_def_cfa_offset 12
 931               		.cfi_offset 23, -11
 932 001a 8F93      		push r24	 ;  88	*pushqi/1	[length = 1]
 933               	.LCFI43:
 934               		.cfi_def_cfa_offset 13
 935               		.cfi_offset 24, -12
 936 001c 9F93      		push r25	 ;  89	*pushqi/1	[length = 1]
 937               	.LCFI44:
 938               		.cfi_def_cfa_offset 14
 939               		.cfi_offset 25, -13
 940 001e AF93      		push r26	 ;  90	*pushqi/1	[length = 1]
 941               	.LCFI45:
 942               		.cfi_def_cfa_offset 15
 943               		.cfi_offset 26, -14
 944 0020 BF93      		push r27	 ;  91	*pushqi/1	[length = 1]
 945               	.LCFI46:
 946               		.cfi_def_cfa_offset 16
 947               		.cfi_offset 27, -15
 948 0022 CF93      		push r28	 ;  92	*pushqi/1	[length = 1]
 949               	.LCFI47:
 950               		.cfi_def_cfa_offset 17
 951               		.cfi_offset 28, -16
 952 0024 DF93      		push r29	 ;  93	*pushqi/1	[length = 1]
 953               	.LCFI48:
 954               		.cfi_def_cfa_offset 18
 955               		.cfi_offset 29, -17
 956 0026 EF93      		push r30	 ;  94	*pushqi/1	[length = 1]
 957               	.LCFI49:
 958               		.cfi_def_cfa_offset 19
 959               		.cfi_offset 30, -18
 960 0028 FF93      		push r31	 ;  95	*pushqi/1	[length = 1]
 961               	.LCFI50:
 962               		.cfi_def_cfa_offset 20
 963               		.cfi_offset 31, -19
 964               	/* prologue: Signal */
 965               	/* frame size = 0 */
 966               	/* stack size = 19 */
 967               	.L__stack_usage = 19
 330:bertos/drv/timer.c **** 	/*
 331:bertos/drv/timer.c **** 	 * With the Metrowerks compiler, the only way to force the compiler generate
 332:bertos/drv/timer.c **** 	 * an interrupt service routine is to put a pragma directive within the function
 333:bertos/drv/timer.c **** 	 * body.
 334:bertos/drv/timer.c **** 	 */
 335:bertos/drv/timer.c **** 	#ifdef __MWERKS__
 336:bertos/drv/timer.c **** 	#pragma interrupt saveall
 337:bertos/drv/timer.c **** 	#endif
 338:bertos/drv/timer.c **** 
 339:bertos/drv/timer.c **** 	/*
 340:bertos/drv/timer.c **** 	 * On systems sharing IRQ line and vector, this check is needed
 341:bertos/drv/timer.c **** 	 * to ensure that IRQ is generated by timer source.
 342:bertos/drv/timer.c **** 	 */
 343:bertos/drv/timer.c **** 	if (!timer_hw_triggered())
 344:bertos/drv/timer.c **** 		return;
 345:bertos/drv/timer.c **** 
 346:bertos/drv/timer.c **** 	TIMER_STROBE_ON;
 347:bertos/drv/timer.c **** 
 348:bertos/drv/timer.c **** 	/* Update the master ms counter */
 349:bertos/drv/timer.c **** 	++_clock;
 968               		.loc 1 349 0
 969 002a 8091 0000 		lds r24,_clock	 ;  5	*movsi/3	[length = 8]
 970 002e 9091 0000 		lds r25,_clock+1
 971 0032 A091 0000 		lds r26,_clock+2
 972 0036 B091 0000 		lds r27,_clock+3
 973 003a 0196      		adiw r24,1	 ;  6	addsi3/2	[length = 3]
 974 003c A11D      		adc r26,__zero_reg__
 975 003e B11D      		adc r27,__zero_reg__
 976 0040 8093 0000 		sts _clock,r24	 ;  7	*movsi/4	[length = 8]
 977 0044 9093 0000 		sts _clock+1,r25
 978 0048 A093 0000 		sts _clock+2,r26
 979 004c B093 0000 		sts _clock+3,r27
 980               	.LBB86:
 981               	.LBB87:
 202:bertos/drv/timer.c **** 		DB(timer->magic = TIMER_MAGIC_INACTIVE;)
 982               		.loc 1 202 0
 983 0050 0BEA      		ldi r16,lo8(-17749)	 ;  44	*movhi/4	[length = 2]
 984 0052 1AEB      		ldi r17,hi8(-17749)
 985 0054 00C0      		rjmp .L32	 ;  121	jump	[length = 1]
 986               	.LVL52:
 987               	.L35:
 988               	.LBB88:
 989               	.LBB89:
 990               	.LBB90:
 991               		.loc 2 131 0
 992               	/* #APP */
 993               	 ;  131 "bertos/drv/timer.h" 1
 994 0056 2FB7      		in r18,__SREG__
 995 0058 F894      		cli
 996               	 ;  0 "" 2
 997               	.LVL53:
 998               	/* #NOAPP */
 999 005a 8091 0000 		lds r24,_clock	 ;  14	*movsi/3	[length = 8]
 1000 005e 9091 0000 		lds r25,_clock+1
 1001 0062 A091 0000 		lds r26,_clock+2
 1002 0066 B091 0000 		lds r27,_clock+3
 1003               	.LVL54:
 1004               	/* #APP */
 1005               	 ;  131 "bertos/drv/timer.h" 1
 1006 006a 2FBF      		out __SREG__,r18
 1007               	 ;  0 "" 2
 1008               	/* #NOAPP */
 1009               	.LBE90:
 1010               	.LBE89:
 1011               	.LBE88:
 197:bertos/drv/timer.c **** 		if (timer_clock() - timer->tick < 0)
 1012               		.loc 1 197 0
 1013 006c 4885      		ldd r20,Y+8	 ;  17	*movsi/3	[length = 4]
 1014 006e 5985      		ldd r21,Y+9
 1015 0070 6A85      		ldd r22,Y+10
 1016 0072 7B85      		ldd r23,Y+11
 1017 0074 841B      		sub r24,r20	 ;  18	subsi3/1	[length = 4]
 1018 0076 950B      		sbc r25,r21
 1019 0078 A60B      		sbc r26,r22
 1020 007a B70B      		sbc r27,r23
 1021 007c B7FD      		sbrc r27,7	 ;  120	*sbrx_and_branchsi	[length = 2]
 1022 007e 00C0      		rjmp .L31
 201:bertos/drv/timer.c **** 		REMOVE(&timer->link);
 1023               		.loc 1 201 0
 1024 0080 CF3F      		cpi r28,255	 ;  23	*cmphi/4	[length = 2]
 1025 0082 D105      		cpc r29,__zero_reg__
 1026 0084 01F0      		breq .+2	 ;  24	difficult_branch	[length = 2]
 1027 0086 00F4      		brsh .L34
 1028 0088 CE01      		movw r24,r28	 ;  29	*movhi/1	[length = 1]
 1029 008a 60E0      		ldi r22,lo8(__c.1605)	 ;  67	*movhi/4	[length = 2]
 1030 008c 70E0      		ldi r23,hi8(__c.1605)
 1031 008e 40E0      		ldi r20,lo8(__c.1607)	 ;  68	*movhi/4	[length = 2]
 1032 0090 50E0      		ldi r21,hi8(__c.1607)
 1033 0092 29EC      		ldi r18,lo8(201)	 ;  32	*movhi/4	[length = 2]
 1034 0094 30E0      		ldi r19,hi8(201)
 1035 0096 0E94 0000 		call __invalid_ptr_P	 ;  33	call_value_insn/3	[length = 2]
 1036               	.L34:
 1037 009a EA81      		ldd r30,Y+2	 ;  36	*movhi/2	[length = 2]
 1038 009c FB81      		ldd r31,Y+3
 1039 009e 8881      		ld r24,Y	 ;  37	*movhi/2	[length = 2]
 1040 00a0 9981      		ldd r25,Y+1
 1041 00a2 9183      		std Z+1,r25	 ;  38	*movhi/3	[length = 2]
 1042 00a4 8083      		st Z,r24
 1043 00a6 E881      		ld r30,Y	 ;  39	*movhi/2	[length = 2]
 1044 00a8 F981      		ldd r31,Y+1
 1045 00aa 8A81      		ldd r24,Y+2	 ;  40	*movhi/2	[length = 2]
 1046 00ac 9B81      		ldd r25,Y+3
 1047 00ae 9383      		std Z+3,r25	 ;  41	*movhi/3	[length = 2]
 1048 00b0 8283      		std Z+2,r24
 1049 00b2 1B82      		std Y+3,__zero_reg__	 ;  42	*movhi/3	[length = 2]
 1050 00b4 1A82      		std Y+2,__zero_reg__
 1051 00b6 1982      		std Y+1,__zero_reg__	 ;  43	*movhi/3	[length = 2]
 1052 00b8 1882      		st Y,__zero_reg__
 202:bertos/drv/timer.c **** 		DB(timer->magic = TIMER_MAGIC_INACTIVE;)
 1053               		.loc 1 202 0
 1054 00ba 1B8B      		std Y+19,r17	 ;  45	*movhi/3	[length = 2]
 1055 00bc 0A8B      		std Y+18,r16
 1056               	.LVL55:
 1057               	.LBB91:
 1058               	.LBB92:
 1059               		.loc 3 134 0
 1060 00be EC85      		ldd r30,Y+12	 ;  49	*movhi/2	[length = 2]
 1061 00c0 FD85      		ldd r31,Y+13
 1062 00c2 CE01      		movw r24,r28	 ;  73	*movhi/1	[length = 1]
 1063 00c4 0C96      		adiw r24,12	 ;  50	*addhi3/2	[length = 1]
 1064 00c6 0995      		icall	 ;  51	call_insn/1	[length = 1]
 1065               	.LVL56:
 1066               	.L32:
 1067               	.LBE92:
 1068               	.LBE91:
 194:bertos/drv/timer.c **** 	while ((timer = (Timer *)LIST_HEAD(queue))->link.succ)
 1069               		.loc 1 194 0
 1070 00c8 C091 0000 		lds r28,timers_queue	 ;  55	*movhi/2	[length = 4]
 1071 00cc D091 0000 		lds r29,timers_queue+1
 1072               	.LVL57:
 1073 00d0 8881      		ld r24,Y	 ;  58	*movhi/2	[length = 2]
 1074 00d2 9981      		ldd r25,Y+1
 1075 00d4 0097      		sbiw r24,0	 ;  59	*cmphi/1	[length = 1]
 1076 00d6 01F0      		breq .+2	 ;  60	branch	[length = 2]
 1077 00d8 00C0      		rjmp .L35
 1078               	.L31:
 1079               	/* epilogue start */
 1080               	.LBE87:
 1081               	.LBE86:
 350:bertos/drv/timer.c **** 
 351:bertos/drv/timer.c **** 	/* Update the current task's quantum (if enabled). */
 352:bertos/drv/timer.c **** 	proc_decQuantum();
 353:bertos/drv/timer.c **** 
 354:bertos/drv/timer.c **** 	#if CONFIG_TIMER_EVENTS
 355:bertos/drv/timer.c **** 		timer_poll(&timers_queue);
 356:bertos/drv/timer.c **** 	#endif
 357:bertos/drv/timer.c **** 
 358:bertos/drv/timer.c **** 	/* Perform hw IRQ handling */
 359:bertos/drv/timer.c **** 	timer_hw_irq();
 360:bertos/drv/timer.c **** 	
 361:bertos/drv/timer.c **** 	TIMER_STROBE_OFF;
 362:bertos/drv/timer.c **** }
 1082               		.loc 1 362 0
 1083 00da FF91      		pop r31	 ;  98	popqi	[length = 1]
 1084 00dc EF91      		pop r30	 ;  99	popqi	[length = 1]
 1085 00de DF91      		pop r29	 ;  100	popqi	[length = 1]
 1086 00e0 CF91      		pop r28	 ;  101	popqi	[length = 1]
 1087 00e2 BF91      		pop r27	 ;  102	popqi	[length = 1]
 1088 00e4 AF91      		pop r26	 ;  103	popqi	[length = 1]
 1089 00e6 9F91      		pop r25	 ;  104	popqi	[length = 1]
 1090 00e8 8F91      		pop r24	 ;  105	popqi	[length = 1]
 1091 00ea 7F91      		pop r23	 ;  106	popqi	[length = 1]
 1092 00ec 6F91      		pop r22	 ;  107	popqi	[length = 1]
 1093 00ee 5F91      		pop r21	 ;  108	popqi	[length = 1]
 1094 00f0 4F91      		pop r20	 ;  109	popqi	[length = 1]
 1095 00f2 3F91      		pop r19	 ;  110	popqi	[length = 1]
 1096 00f4 2F91      		pop r18	 ;  111	popqi	[length = 1]
 1097 00f6 1F91      		pop r17	 ;  112	popqi	[length = 1]
 1098 00f8 0F91      		pop r16	 ;  113	popqi	[length = 1]
 1099 00fa 0F90      		pop r0	 ;  114	popqi	[length = 1]
 1100 00fc 0FBE      		out __SREG__,r0	 ;  115	*movqi/3	[length = 1]
 1101 00fe 0F90      		pop r0	 ;  116	popqi	[length = 1]
 1102 0100 1F90      		pop r1	 ;  117	popqi	[length = 1]
 1103 0102 1895      		reti	 ;  118	return_from_interrupt_epilogue	[length = 1]
 1104               		.cfi_endproc
 1105               	.LFE37:
 1107               		.section	.text.timer_init,"ax",@progbits
 1108               	.global	timer_init
 1110               	timer_init:
 1111               	.LFB38:
 363:bertos/drv/timer.c **** 
 364:bertos/drv/timer.c **** MOD_DEFINE(timer)
 365:bertos/drv/timer.c **** 
 366:bertos/drv/timer.c **** /**
 367:bertos/drv/timer.c ****  * Initialize timer
 368:bertos/drv/timer.c ****  */
 369:bertos/drv/timer.c **** void timer_init(void)
 370:bertos/drv/timer.c **** {
 1112               		.loc 1 370 0
 1113               		.cfi_startproc
 1114               	/* prologue: function */
 1115               	/* frame size = 0 */
 1116               	/* stack size = 0 */
 1117               	.L__stack_usage = 0
 371:bertos/drv/timer.c **** 	#if CONFIG_KERN_IRQ
 372:bertos/drv/timer.c **** 		MOD_CHECK(irq);
 373:bertos/drv/timer.c **** 	#endif
 374:bertos/drv/timer.c **** 
 375:bertos/drv/timer.c **** 	#if CONFIG_TIMER_EVENTS
 376:bertos/drv/timer.c **** 		LIST_INIT(&timers_queue);
 1118               		.loc 1 376 0
 1119 0000 80E0      		ldi r24,lo8(timers_queue)	 ;  5	*movhi/4	[length = 2]
 1120 0002 90E0      		ldi r25,hi8(timers_queue)
 1121 0004 9C01      		movw r18,r24	 ;  38	*movhi/1	[length = 1]
 1122 0006 2C5F      		subi r18,lo8(-(4))	 ;  6	*addhi3/4	[length = 2]
 1123 0008 3F4F      		sbci r19,hi8(-(4))
 1124 000a 3093 0000 		sts timers_queue+1,r19	 ;  7	*movhi/3	[length = 4]
 1125 000e 2093 0000 		sts timers_queue,r18
 1126 0012 1092 0000 		sts timers_queue+2+1,__zero_reg__	 ;  9	*movhi/3	[length = 4]
 1127 0016 1092 0000 		sts timers_queue+2,__zero_reg__
 1128 001a 1092 0000 		sts timers_queue+4+1,__zero_reg__	 ;  11	*movhi/3	[length = 4]
 1129 001e 1092 0000 		sts timers_queue+4,__zero_reg__
 1130 0022 9093 0000 		sts timers_queue+6+1,r25	 ;  14	*movhi/3	[length = 4]
 1131 0026 8093 0000 		sts timers_queue+6,r24
 377:bertos/drv/timer.c **** 	#endif
 378:bertos/drv/timer.c **** 
 379:bertos/drv/timer.c **** 	TIMER_STROBE_INIT;
 380:bertos/drv/timer.c **** 
 381:bertos/drv/timer.c **** 	_clock = 0;
 1132               		.loc 1 381 0
 1133 002a 1092 0000 		sts _clock,__zero_reg__	 ;  15	*movsi/4	[length = 8]
 1134 002e 1092 0000 		sts _clock+1,__zero_reg__
 1135 0032 1092 0000 		sts _clock+2,__zero_reg__
 1136 0036 1092 0000 		sts _clock+3,__zero_reg__
 382:bertos/drv/timer.c **** 
 383:bertos/drv/timer.c **** 	timer_hw_init();
 1137               		.loc 1 383 0
 1138 003a 0E94 0000 		call timer_hw_init	 ;  17	call_insn/3	[length = 2]
 384:bertos/drv/timer.c **** 
 385:bertos/drv/timer.c **** 	MOD_INIT(timer);
 1139               		.loc 1 385 0
 1140 003e 8091 0000 		lds r24,timer_initialized	 ;  18	*movqi/4	[length = 2]
 1141 0042 8823      		tst r24	 ;  19	*cmpqi/1	[length = 1]
 1142 0044 01F0      		breq .L37	 ;  20	branch	[length = 1]
 1143               		.loc 1 385 0 is_stmt 0 discriminator 1
 1144 0046 80E0      		ldi r24,lo8(__c.1652)	 ;  25	*movhi/4	[length = 2]
 1145 0048 90E0      		ldi r25,hi8(__c.1652)
 1146 004a 60E0      		ldi r22,lo8(__c.1654)	 ;  26	*movhi/4	[length = 2]
 1147 004c 70E0      		ldi r23,hi8(__c.1654)
 1148 004e 41E8      		ldi r20,lo8(385)	 ;  27	*movhi/4	[length = 2]
 1149 0050 51E0      		ldi r21,hi8(385)
 1150 0052 0E94 0000 		call __bassert_P	 ;  28	call_value_insn/3	[length = 2]
 1151               	.L37:
 1152               		.loc 1 385 0 discriminator 3
 1153 0056 81E0      		ldi r24,lo8(1)	 ;  31	*movqi/2	[length = 1]
 1154 0058 8093 0000 		sts timer_initialized,r24	 ;  32	*movqi/3	[length = 2]
 1155               	/* epilogue start */
 386:bertos/drv/timer.c **** }
 1156               		.loc 1 386 0 is_stmt 1 discriminator 3
 1157 005c 0895      		ret	 ;  41	return	[length = 1]
 1158               		.cfi_endproc
 1159               	.LFE38:
 1161               		.comm timer_initialized,1,1
 1162               		.comm _clock,4,1
 1163               		.section	.progmem.data,"a",@progbits
 1166               	__c.1572:
 1167 0000 7469 6D65 		.string	"timer->magic != TIMER_MAGIC_ACTIVE"
 1167      722D 3E6D 
 1167      6167 6963 
 1167      2021 3D20 
 1167      5449 4D45 
 1170               	__c.1574:
 1171 0023 6265 7274 		.string	"bertos/drv/timer.c"
 1171      6F73 2F64 
 1171      7276 2F74 
 1171      696D 6572 
 1171      2E63 00
 1172               		.section	.bss.timers_queue,"aw",@nobits
 1175               	timers_queue:
 1176 0000 0000 0000 		.skip 8,0
 1176      0000 0000 
 1177               		.section	.progmem.data
 1180               	__c.1580:
 1181 0036 2674 696D 		.string	"&timer->link"
 1181      6572 2D3E 
 1181      6C69 6E6B 
 1181      00
 1184               	__c.1582:
 1185 0043 6265 7274 		.string	"bertos/drv/timer.c"
 1185      6F73 2F64 
 1185      7276 2F74 
 1185      696D 6572 
 1185      2E63 00
 1188               	__c.1584:
 1189 0056 266E 6F64 		.string	"&node->link"
 1189      652D 3E6C 
 1189      696E 6B00 
 1192               	__c.1586:
 1193 0062 6265 7274 		.string	"bertos/drv/timer.c"
 1193      6F73 2F64 
 1193      7276 2F74 
 1193      696D 6572 
 1193      2E63 00
 1196               	__c.1596:
 1197 0075 2674 696D 		.string	"&timer->link"
 1197      6572 2D3E 
 1197      6C69 6E6B 
 1197      00
 1200               	__c.1598:
 1201 0082 6265 7274 		.string	"bertos/drv/timer.c"
 1201      6F73 2F64 
 1201      7276 2F74 
 1201      696D 6572 
 1201      2E63 00
 1204               	__c.1605:
 1205 0095 2674 696D 		.string	"&timer->link"
 1205      6572 2D3E 
 1205      6C69 6E6B 
 1205      00
 1208               	__c.1607:
 1209 00a2 6265 7274 		.string	"bertos/drv/timer.c"
 1209      6F73 2F64 
 1209      7276 2F74 
 1209      696D 6572 
 1209      2E63 00
 1212               	__c.1623:
 1213 00b5 4952 515F 		.string	"IRQ_ENABLED()"
 1213      454E 4142 
 1213      4C45 4428 
 1213      2900 
 1216               	__c.1625:
 1217 00c3 6265 7274 		.string	"bertos/drv/timer.c"
 1217      6F73 2F64 
 1217      7276 2F74 
 1217      696D 6572 
 1217      2E63 00
 1220               	__c.1652:
 1221 00d6 2174 696D 		.string	"!timer_initialized"
 1221      6572 5F69 
 1221      6E69 7469 
 1221      616C 697A 
 1221      6564 00
 1224               	__c.1654:
 1225 00e9 6265 7274 		.string	"bertos/drv/timer.c"
 1225      6F73 2F64 
 1225      7276 2F74 
 1225      696D 6572 
 1225      2E63 00
 1226               		.text
 1227               	.Letext0:
 1228               		.file 5 "/usr/local/CrossPack-AVR-20121207/lib/gcc/avr/4.6.2/../../../../avr/include/stdint.h"
 1229               		.file 6 "bertos/cfg/compiler.h"
 1230               		.file 7 "bertos/cpu/types.h"
 1231               		.file 8 "bertos/struct/list.h"
 1232               		.file 9 "bertos/kern/proc.h"
 1233               		.file 10 "bertos/cpu/power.h"
 1234               		.file 11 "bertos/kern/proc_p.h"
DEFINED SYMBOLS
                            *ABS*:00000000 timer.c
/var/folders/yq/1c5lpctj6dd1dv230ntn69lm0000gn/T//ccjwRz5z.s:2      *ABS*:0000003f __SREG__
/var/folders/yq/1c5lpctj6dd1dv230ntn69lm0000gn/T//ccjwRz5z.s:3      *ABS*:0000003e __SP_H__
/var/folders/yq/1c5lpctj6dd1dv230ntn69lm0000gn/T//ccjwRz5z.s:4      *ABS*:0000003d __SP_L__
/var/folders/yq/1c5lpctj6dd1dv230ntn69lm0000gn/T//ccjwRz5z.s:5      *ABS*:00000034 __CCP__
/var/folders/yq/1c5lpctj6dd1dv230ntn69lm0000gn/T//ccjwRz5z.s:6      *ABS*:00000000 __tmp_reg__
/var/folders/yq/1c5lpctj6dd1dv230ntn69lm0000gn/T//ccjwRz5z.s:7      *ABS*:00000001 __zero_reg__
/var/folders/yq/1c5lpctj6dd1dv230ntn69lm0000gn/T//ccjwRz5z.s:16     .text.timer_add:00000000 timer_add
/var/folders/yq/1c5lpctj6dd1dv230ntn69lm0000gn/T//ccjwRz5z.s:1166   .progmem.data:00000000 __c.1572
/var/folders/yq/1c5lpctj6dd1dv230ntn69lm0000gn/T//ccjwRz5z.s:1170   .progmem.data:00000023 __c.1574
                            *COM*:00000004 _clock
/var/folders/yq/1c5lpctj6dd1dv230ntn69lm0000gn/T//ccjwRz5z.s:1175   .bss.timers_queue:00000000 timers_queue
/var/folders/yq/1c5lpctj6dd1dv230ntn69lm0000gn/T//ccjwRz5z.s:1180   .progmem.data:00000036 __c.1580
/var/folders/yq/1c5lpctj6dd1dv230ntn69lm0000gn/T//ccjwRz5z.s:1184   .progmem.data:00000043 __c.1582
/var/folders/yq/1c5lpctj6dd1dv230ntn69lm0000gn/T//ccjwRz5z.s:1188   .progmem.data:00000056 __c.1584
/var/folders/yq/1c5lpctj6dd1dv230ntn69lm0000gn/T//ccjwRz5z.s:1192   .progmem.data:00000062 __c.1586
/var/folders/yq/1c5lpctj6dd1dv230ntn69lm0000gn/T//ccjwRz5z.s:206    .text.timer_abort:00000000 timer_abort
/var/folders/yq/1c5lpctj6dd1dv230ntn69lm0000gn/T//ccjwRz5z.s:1196   .progmem.data:00000075 __c.1596
/var/folders/yq/1c5lpctj6dd1dv230ntn69lm0000gn/T//ccjwRz5z.s:1200   .progmem.data:00000082 __c.1598
/var/folders/yq/1c5lpctj6dd1dv230ntn69lm0000gn/T//ccjwRz5z.s:293    .text.synctimer_add:00000000 synctimer_add
/var/folders/yq/1c5lpctj6dd1dv230ntn69lm0000gn/T//ccjwRz5z.s:463    .text.synctimer_poll:00000000 synctimer_poll
/var/folders/yq/1c5lpctj6dd1dv230ntn69lm0000gn/T//ccjwRz5z.s:1204   .progmem.data:00000095 __c.1605
/var/folders/yq/1c5lpctj6dd1dv230ntn69lm0000gn/T//ccjwRz5z.s:1208   .progmem.data:000000a2 __c.1607
/var/folders/yq/1c5lpctj6dd1dv230ntn69lm0000gn/T//ccjwRz5z.s:619    .text.timer_delayTicks:00000000 timer_delayTicks
/var/folders/yq/1c5lpctj6dd1dv230ntn69lm0000gn/T//ccjwRz5z.s:1212   .progmem.data:000000b5 __c.1623
/var/folders/yq/1c5lpctj6dd1dv230ntn69lm0000gn/T//ccjwRz5z.s:1216   .progmem.data:000000c3 __c.1625
/var/folders/yq/1c5lpctj6dd1dv230ntn69lm0000gn/T//ccjwRz5z.s:744    .text.timer_busyWait:00000000 timer_busyWait
/var/folders/yq/1c5lpctj6dd1dv230ntn69lm0000gn/T//ccjwRz5z.s:841    .text.timer_delayHp:00000000 timer_delayHp
/var/folders/yq/1c5lpctj6dd1dv230ntn69lm0000gn/T//ccjwRz5z.s:885    .text.__vector_14:00000000 __vector_14
/var/folders/yq/1c5lpctj6dd1dv230ntn69lm0000gn/T//ccjwRz5z.s:1110   .text.timer_init:00000000 timer_init
                            *COM*:00000001 timer_initialized
/var/folders/yq/1c5lpctj6dd1dv230ntn69lm0000gn/T//ccjwRz5z.s:1220   .progmem.data:000000d6 __c.1652
/var/folders/yq/1c5lpctj6dd1dv230ntn69lm0000gn/T//ccjwRz5z.s:1224   .progmem.data:000000e9 __c.1654

UNDEFINED SYMBOLS
__do_copy_data
__do_clear_bss
__bassert_P
__invalid_ptr_P
__udivmodsi4
__udivmodqi4
timer_hw_init
